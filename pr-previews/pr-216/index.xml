<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Langium</title><link>/</link><description>Recent content on Langium</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 17 Nov 2021 14:06:59 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Validation</title><link>/tutorials/validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorials/validation/</guid><description>Overview The Validation Registry Finding Nodes to Validate Registering Validations In this tutorial, we will be talking about implementing validation for your Langium-based language. We recommend first reading the previous tutorial about writing a grammar, as we will assume you&amp;rsquo;re familiar with the topics covered there. We&amp;rsquo;ll also assume that you have a working language to add validation to, so double check that npm run langium:generate succeeds without errors before you proceed.</description></item><item><title>Customizing the CLI</title><link>/tutorials/customizing_cli/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorials/customizing_cli/</guid><description>Overview About the Command Line Interface Adding a Parse and Validate Action Building and Running the CLI In this tutorial, we&amp;rsquo;ll be talking about customizing the command line interface for your language. We recommend reading through previous tutorials about writing a grammar and validation. Once you have a good grasp on those concepts, then you should be all set for setting up a CLI.</description></item><item><title>Generation</title><link>/tutorials/generation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorials/generation/</guid><description>Setting up the Generator API Deciding Output to Generate Generating from Statements Writing an Expression Evaluator Generating from Statements with the Evaluator Connecting the Generator to the CLI In this tutorial we&amp;rsquo;ll be showing how to implement basic generation for your language. When we&amp;rsquo;re talking about generation, we&amp;rsquo;re talking about transforming an AST from your Langium-based language into some output target. This could be another language of similar functionality (transpilation), a lower level language (compilation), or generating some artifacts/data that will be consumed by another application.</description></item><item><title>Building an Extension</title><link>/tutorials/building_an_extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorials/building_an_extension/</guid><description>Setting up the Scripts Generate an Extension Installing Adding an Icon Conclusion In this tutorial we&amp;rsquo;ll be going over how to build a VSIX extension (VSCode extension) for your Langium-based language. This will allow providing LSP support in VSCode for your language. We&amp;rsquo;ll assume that you&amp;rsquo;ve already looked at the previous tutorial, and have had time to read the guide on bundling, so that you&amp;rsquo;re ready to build an extension.</description></item><item><title>Langium + Monaco Editor</title><link>/tutorials/langium_and_monaco/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorials/langium_and_monaco/</guid><description>Technologies You&amp;rsquo;ll Need Getting your Language Setup for the Web Factoring out File System Dependencies Setting up Monaco Setting up a Static Page Serving via NodeJS Updated on Oct. 4th, 2023 for usage with monaco-editor-wrapper 3.1.0 &amp;amp; above, as well as Langium 2.0.2
In this tutorial we&amp;rsquo;ll be talking about running Langium in the web with the Monaco editor. If you&amp;rsquo;re not familiar with Monaco, it&amp;rsquo;s the editor that powers VS Code.</description></item><item><title>Generation in the Web</title><link>/tutorials/generation_in_the_web/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorials/generation_in_the_web/</guid><description>Handling Document Validations Listening for Notifications in the Client Interpreting Draw Commands (Drawing) Updated on Oct. 4th, 2023 for usage with monaco-editor-wrapper 3.1.0 &amp;amp; above.
In this tutorial we&amp;rsquo;ll be talking about how to perform generation in the web by listening for document builder notifications. There are multiple ways to hook into Langium to utilize the generator, such as by directly exporting the generator API.</description></item><item><title>Getting Started</title><link>/docs/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/</guid><description>Before diving into Langium itself, let&amp;rsquo;s get your environment ready for development:
You have a working Node environment with version 12 or higher. Install Yeoman and the Langium extension generator. npm i -g yo generator-langium For our getting started example, we would also recommend you to install the latest version of vscode.
Your first example language To create your first working DSL, execute the yeoman generator:</description></item><item><title>Qualified Name Scoping</title><link>/guides/scoping/qualified-name/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guides/scoping/qualified-name/</guid><description>Qualified name scoping refers to a style of referencing elements using a fully qualified name. Such a fully qualified name is usually composed of the original name of the target element and the names of its container elements. You will usually see this method of scoping in C-like languages using namespaces or in Java using packages. The following code snippet shows an example of how qualified name scoping works from an end-user perspective, by using a function in a C++ namespace:</description></item><item><title>State Machine</title><link>/showcase/statemachine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/statemachine/</guid><description/></item><item><title>The Grammar Language</title><link>/docs/grammar-language/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/grammar-language/</guid><description>The grammar language describes the syntax and structure of your language. The Langium grammar language is implemented using Langium itself and therefore follows the same syntactic rules as any language created with Langium. The grammar language will define the structure of the abstract syntax tree (AST) which in Langium is a collection of TypeScript types describing the content of a parsed document and organized hierarchically. The individual nodes of the tree are then represented with JavaScript objects at runtime.</description></item><item><title>Class Member Scoping</title><link>/guides/scoping/class-member/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guides/scoping/class-member/</guid><description>In this guide we will take a look at member based scoping. It&amp;rsquo;s a mechanism you are likely familiar with from object oriented languages such as Java, C# and JavaScript:
class A { b: B; } class B { value: string; } function test(): void { const a = new A(); const b = a.b; // Refers to the `b` defined in class `A` const value = b.value; // Refers to the `value` defined in class `B` } Member based scoping like this requires not only a modification of the default scoping provider, but also some other prerequisites.</description></item><item><title>Semantic Model Inference</title><link>/docs/sematic-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/sematic-model/</guid><description>When AST nodes are created during the parsing of a document, they are given a type. The language grammar dictates the shape of those types and how they might be related to each other. All types form the semantic model of your language. There are two ways by which Langium derives semantic model types from the grammar, by inference and by declaration.
Inference is the default behavior in Langium. During the generation of the semantic model types, Langium infers the possible types directly from the grammar rules.</description></item><item><title>Arithmetics</title><link>/showcase/arithmetics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/arithmetics/</guid><description/></item><item><title>Builtin Libraries</title><link>/guides/builtin-library/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guides/builtin-library/</guid><description>Languages usually offer their users some high-level programming features that they do not have to define themselves. For example, TypeScript provides users with typings for globally accessible variables such as the window, process or console objects. They are part of the JavaScript runtime, and not defined by any user or a package they might import. Instead, these features are contributed through what we call builtin libraries.
Loading a builtin library in Langium is very simple.</description></item><item><title>Configuration via Services</title><link>/docs/configuration-services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/configuration-services/</guid><description>Langium supports the configuration of most aspects of your language and language server via a set of services. Those services are configured by modules, which are essentially mappings from a service name to its implementation.
We can separate services and modules into two main categories:
Shared Services The shared services are services that are shared across all Langium languages. In many applications there is only one Langium language, but the overall structure of the services is the same.</description></item><item><title>Formatting</title><link>/guides/formatting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guides/formatting/</guid><description>Langium&amp;rsquo;s formatting API allows to easily create formatters for your language. We start building a custom formatter for our language by creating a new class that inherits from AbstractFormatter.
import { AbstractFormatter, AstNode, Formatting } from 'langium'; export class CustomFormatter extends AbstractFormatter { protected format(node: AstNode): void { // This method is called for every AstNode in a document } } ... // Bind the class in your module export const CustomModule: Module&amp;lt;CustomServices, PartialLangiumServices&amp;gt; = { lsp: { Formatter: () =&amp;gt; new CustomFormatter() } }; The entry point for the formatter is the abstract format(AstNode) method.</description></item><item><title>MiniLogo</title><link>/showcase/minilogo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/minilogo/</guid><description/></item><item><title>Document Lifecycle</title><link>/docs/document-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/document-lifecycle/</guid><description>LangiumDocument is the central data structure in Langium that represents a text file of your DSL. Its main purpose is to hold the parsed Abstract Syntax Tree (AST) plus additional information derived from it. After its creation, a LangiumDocument must be &amp;ldquo;built&amp;rdquo; before it can be used in any way. The service responsible for building documents is called DocumentBuilder.
A LangiumDocument goes through seven different states during its lifecycle:
Parsed when an AST has been generated from the content of the document.</description></item><item><title>SQL</title><link>/showcase/sql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/sql/</guid><description/></item><item><title>Domain Model</title><link>/showcase/domainmodel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/showcase/domainmodel/</guid><description/></item><item><title>Imprint</title><link>/imprint/</link><pubDate>Wed, 17 Nov 2021 14:06:59 +0000</pubDate><guid>/imprint/</guid><description>Imprint Langium.org is administered by TypeFox GmbH Managing Directors: Daniel Dietrich, Dr. Miro Spönemann Am Germaniahafen 1 24143 Kiel HRB 17385, Amtsgericht Kiel VAT-ID : DE304247102 Phone: +49 431 99026870 Email: contact@typefox.io Responsible for all content according to § 18 (1) (MStV): TypeFox GmbH, Am Germaniahafen 1, 24143 Kiel Authorized to represent: Herr Dr. Miro Spönemann &amp; Herr Daniel Dietrich Disclaimer Liability for content As a service provider we are responsible according to § 7 paragraph 1 of TMG for own contents on these pages under the general laws.</description></item><item><title>Code Bundling</title><link>/guides/code-bundling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/guides/code-bundling/</guid><description>When you first create a Langium project using the Yeoman generator, it will only contain a plain TypeScript configuration, without any additional build processes. However, if you want to make your language available for consumption in a non-development context, you&amp;rsquo;ll want to create a bundle. It is not absolutely necessary in a Node.js context, since you can always resolve local node_modules but it&amp;rsquo;s still recommended for vscode extensions. It improves performance and decreases file size by minifying your code and only including what you actually need.</description></item><item><title>Langium Overview</title><link>/docs/langium-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/langium-overview/</guid><description>Designing programming languages from the ground up is hard, independent of whether your language is a &amp;ldquo;simple&amp;rdquo; domain specific language or a full-fledged general-purpose programming language. Not only do you have to keep up with the requirements of your domain experts, but you have to deal with all the technical complexity that comes with building a language, including questions such as:
How do I get from a string to a semantic model which I can work with?</description></item><item><title>Writing a Grammar</title><link>/tutorials/writing_a_grammar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorials/writing_a_grammar/</guid><description>Planning Sketching the Grammar Adding Commands Adding Expressions Adding Terminals In this tutorial we will be talking about writing a grammar for your language in Langium. As a motivating example, we&amp;rsquo;ll be describing how to write a grammar for the MiniLogo language. If you&amp;rsquo;re not familiar with MiniLogo, it&amp;rsquo;s a smaller implementation of the Logo programming language. Logo itself is a lot like Turtle from Python.</description></item></channel></rss>