<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Documentation on Langium</title><link>/docs/</link><description>Recent content in Documentation on Langium</description><generator>Hugo -- gohugo.io</generator><atom:link href="/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting Started</title><link>/docs/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/</guid><description>Before diving into Langium itself, let&amp;rsquo;s get your environment ready for development:
You have a working Node environment with version 12 or higher. Install Yeoman and the Langium extension generator. npm i -g yo generator-langium For our getting started example, we would also recommend you to install the latest version of vscode.
Your first example language To create your first working DSL, execute the yeoman generator:</description></item><item><title>The Grammar Language</title><link>/docs/grammar-language/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/grammar-language/</guid><description>The grammar language describes the syntax and structure of your language. The Langium grammar language is implemented using Langium itself and therefore follows the same syntactic rules as any language created with Langium. The grammar language will define the structure of the abstract syntax tree (AST) which in Langium is a collection of TypeScript types describing the content of a parsed document and organized hierarchically. The individual nodes of the tree are then represented with JavaScript objects at runtime.</description></item><item><title>Semantic Model Inference</title><link>/docs/sematic-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/sematic-model/</guid><description>When AST nodes are created during the parsing of a document, they are given a type. The language grammar dictates the shape of those types and how they might be related to each other. All types form the semantic model of your language. There are two ways by which Langium derives semantic model types from the grammar, by inference and by declaration.
Inference is the default behavior in Langium. During the generation of the semantic model types, Langium infers the possible types directly from the grammar rules.</description></item><item><title>Configuration via Services</title><link>/docs/configuration-services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/configuration-services/</guid><description>Langium supports the configuration of most aspects of your language and language server via a set of services. Those services are configured by modules, which are essentially mappings from a service name to its implementation.
We can separate services and modules into two main categories:
Shared Services The shared services are services that are shared across all Langium languages. In many applications there is only one Langium language, but the overall structure of the services is the same.</description></item><item><title>Document Lifecycle</title><link>/docs/document-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/document-lifecycle/</guid><description>LangiumDocument is the central data structure in Langium that represents a text file of your DSL. Its main purpose is to hold the parsed Abstract Syntax Tree (AST) plus additional information derived from it. After its creation, a LangiumDocument must be &amp;ldquo;built&amp;rdquo; before it can be used in any way. The service responsible for building documents is called DocumentBuilder.
A LangiumDocument goes through seven different states during its lifecycle:
Parsed when an AST has been generated from the content of the document.</description></item><item><title>Langium Overview</title><link>/docs/langium-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/langium-overview/</guid><description>Designing programming languages from the ground up is hard, independent of whether your language is a &amp;ldquo;simple&amp;rdquo; domain specific language or a full-fledged general-purpose programming language. Not only do you have to keep up with the requirements of your domain experts, but you have to deal with all the technical complexity that comes with building a language, including questions such as:
How do I get from a string to a semantic model which I can work with?</description></item></channel></rss>