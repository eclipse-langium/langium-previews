(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../node_modules/langium/node_modules/vscode-languageserver-types/lib/esm/main.js
  var main_exports = {};
  __export(main_exports, {
    AnnotatedTextEdit: () => AnnotatedTextEdit,
    ChangeAnnotation: () => ChangeAnnotation,
    ChangeAnnotationIdentifier: () => ChangeAnnotationIdentifier,
    CodeAction: () => CodeAction,
    CodeActionContext: () => CodeActionContext,
    CodeActionKind: () => CodeActionKind,
    CodeActionTriggerKind: () => CodeActionTriggerKind,
    CodeDescription: () => CodeDescription,
    CodeLens: () => CodeLens,
    Color: () => Color,
    ColorInformation: () => ColorInformation,
    ColorPresentation: () => ColorPresentation,
    Command: () => Command,
    CompletionItem: () => CompletionItem,
    CompletionItemKind: () => CompletionItemKind,
    CompletionItemLabelDetails: () => CompletionItemLabelDetails,
    CompletionItemTag: () => CompletionItemTag,
    CompletionList: () => CompletionList,
    CreateFile: () => CreateFile,
    DeleteFile: () => DeleteFile,
    Diagnostic: () => Diagnostic,
    DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
    DiagnosticSeverity: () => DiagnosticSeverity,
    DiagnosticTag: () => DiagnosticTag,
    DocumentHighlight: () => DocumentHighlight,
    DocumentHighlightKind: () => DocumentHighlightKind,
    DocumentLink: () => DocumentLink,
    DocumentSymbol: () => DocumentSymbol,
    DocumentUri: () => DocumentUri,
    EOL: () => EOL,
    FoldingRange: () => FoldingRange,
    FoldingRangeKind: () => FoldingRangeKind,
    FormattingOptions: () => FormattingOptions,
    Hover: () => Hover,
    InlayHint: () => InlayHint,
    InlayHintKind: () => InlayHintKind,
    InlayHintLabelPart: () => InlayHintLabelPart,
    InlineCompletionContext: () => InlineCompletionContext,
    InlineCompletionItem: () => InlineCompletionItem,
    InlineCompletionList: () => InlineCompletionList,
    InlineCompletionTriggerKind: () => InlineCompletionTriggerKind,
    InlineValueContext: () => InlineValueContext,
    InlineValueEvaluatableExpression: () => InlineValueEvaluatableExpression,
    InlineValueText: () => InlineValueText,
    InlineValueVariableLookup: () => InlineValueVariableLookup,
    InsertReplaceEdit: () => InsertReplaceEdit,
    InsertTextFormat: () => InsertTextFormat,
    InsertTextMode: () => InsertTextMode,
    Location: () => Location,
    LocationLink: () => LocationLink,
    MarkedString: () => MarkedString,
    MarkupContent: () => MarkupContent,
    MarkupKind: () => MarkupKind,
    OptionalVersionedTextDocumentIdentifier: () => OptionalVersionedTextDocumentIdentifier,
    ParameterInformation: () => ParameterInformation,
    Position: () => Position,
    Range: () => Range,
    RenameFile: () => RenameFile,
    SelectedCompletionInfo: () => SelectedCompletionInfo,
    SelectionRange: () => SelectionRange,
    SemanticTokenModifiers: () => SemanticTokenModifiers,
    SemanticTokenTypes: () => SemanticTokenTypes,
    SemanticTokens: () => SemanticTokens,
    SignatureInformation: () => SignatureInformation,
    StringValue: () => StringValue,
    SymbolInformation: () => SymbolInformation,
    SymbolKind: () => SymbolKind,
    SymbolTag: () => SymbolTag,
    TextDocument: () => TextDocument,
    TextDocumentEdit: () => TextDocumentEdit,
    TextDocumentIdentifier: () => TextDocumentIdentifier,
    TextDocumentItem: () => TextDocumentItem,
    TextEdit: () => TextEdit,
    URI: () => URI,
    VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
    WorkspaceChange: () => WorkspaceChange,
    WorkspaceEdit: () => WorkspaceEdit,
    WorkspaceFolder: () => WorkspaceFolder,
    WorkspaceSymbol: () => WorkspaceSymbol,
    integer: () => integer,
    uinteger: () => uinteger
  });
  var DocumentUri, URI, integer, uinteger, Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, CodeDescription, Diagnostic, Command, TextEdit, ChangeAnnotation, ChangeAnnotationIdentifier, AnnotatedTextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, ChangeAnnotations, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, OptionalVersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, InsertReplaceEdit, InsertTextMode, CompletionItemLabelDetails, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, WorkspaceSymbol, DocumentSymbol, CodeActionKind, CodeActionTriggerKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, SemanticTokenTypes, SemanticTokenModifiers, SemanticTokens, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineValueContext, InlayHintKind, InlayHintLabelPart, InlayHint, StringValue, InlineCompletionItem, InlineCompletionList, InlineCompletionTriggerKind, SelectedCompletionInfo, InlineCompletionContext, WorkspaceFolder, EOL, TextDocument, FullTextDocument, Is;
  var init_main = __esm({
    "../node_modules/langium/node_modules/vscode-languageserver-types/lib/esm/main.js"() {
      "use strict";
      (function(DocumentUri3) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri3.is = is;
      })(DocumentUri || (DocumentUri = {}));
      (function(URI4) {
        function is(value) {
          return typeof value === "string";
        }
        URI4.is = is;
      })(URI || (URI = {}));
      (function(integer3) {
        integer3.MIN_VALUE = -2147483648;
        integer3.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer3.MIN_VALUE <= value && value <= integer3.MAX_VALUE;
        }
        integer3.is = is;
      })(integer || (integer = {}));
      (function(uinteger3) {
        uinteger3.MIN_VALUE = 0;
        uinteger3.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger3.MIN_VALUE <= value && value <= uinteger3.MAX_VALUE;
        }
        uinteger3.is = is;
      })(uinteger || (uinteger = {}));
      (function(Position4) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position4.create = create;
        function is(value) {
          let candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position4.is = is;
      })(Position || (Position = {}));
      (function(Range3) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
          }
        }
        Range3.create = create;
        function is(value) {
          let candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range3.is = is;
      })(Range || (Range = {}));
      (function(Location4) {
        function create(uri, range) {
          return { uri, range };
        }
        Location4.create = create;
        function is(value) {
          let candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location4.is = is;
      })(Location || (Location = {}));
      (function(LocationLink4) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink4.create = create;
        function is(value) {
          let candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink4.is = is;
      })(LocationLink || (LocationLink = {}));
      (function(Color3) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color3.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color3.is = is;
      })(Color || (Color = {}));
      (function(ColorInformation3) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation3.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation3.is = is;
      })(ColorInformation || (ColorInformation = {}));
      (function(ColorPresentation3) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation3.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation3.is = is;
      })(ColorPresentation || (ColorPresentation = {}));
      (function(FoldingRangeKind4) {
        FoldingRangeKind4.Comment = "comment";
        FoldingRangeKind4.Imports = "imports";
        FoldingRangeKind4.Region = "region";
      })(FoldingRangeKind || (FoldingRangeKind = {}));
      (function(FoldingRange4) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          const result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange4.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange4.is = is;
      })(FoldingRange || (FoldingRange = {}));
      (function(DiagnosticRelatedInformation3) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation3.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation3.is = is;
      })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
      (function(DiagnosticSeverity3) {
        DiagnosticSeverity3.Error = 1;
        DiagnosticSeverity3.Warning = 2;
        DiagnosticSeverity3.Information = 3;
        DiagnosticSeverity3.Hint = 4;
      })(DiagnosticSeverity || (DiagnosticSeverity = {}));
      (function(DiagnosticTag3) {
        DiagnosticTag3.Unnecessary = 1;
        DiagnosticTag3.Deprecated = 2;
      })(DiagnosticTag || (DiagnosticTag = {}));
      (function(CodeDescription3) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription3.is = is;
      })(CodeDescription || (CodeDescription = {}));
      (function(Diagnostic3) {
        function create(range, message, severity, code, source, relatedInformation) {
          let result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic3.create = create;
        function is(value) {
          var _a;
          let candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic3.is = is;
      })(Diagnostic || (Diagnostic = {}));
      (function(Command3) {
        function create(title, command, ...args) {
          let result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command3.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command3.is = is;
      })(Command || (Command = {}));
      (function(TextEdit3) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit3.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit3.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit3.del = del;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit3.is = is;
      })(TextEdit || (TextEdit = {}));
      (function(ChangeAnnotation3) {
        function create(label, needsConfirmation, description) {
          const result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation3.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation3.is = is;
      })(ChangeAnnotation || (ChangeAnnotation = {}));
      (function(ChangeAnnotationIdentifier3) {
        function is(value) {
          const candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier3.is = is;
      })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
      (function(AnnotatedTextEdit3) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit3.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit3.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit3.del = del;
        function is(value) {
          const candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit3.is = is;
      })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
      (function(TextDocumentEdit3) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit3.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit3.is = is;
      })(TextDocumentEdit || (TextDocumentEdit = {}));
      (function(CreateFile3) {
        function create(uri, options, annotation) {
          let result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile3.create = create;
        function is(value) {
          let candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile3.is = is;
      })(CreateFile || (CreateFile = {}));
      (function(RenameFile3) {
        function create(oldUri, newUri, options, annotation) {
          let result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile3.create = create;
        function is(value) {
          let candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile3.is = is;
      })(RenameFile || (RenameFile = {}));
      (function(DeleteFile3) {
        function create(uri, options, annotation) {
          let result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile3.create = create;
        function is(value) {
          let candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile3.is = is;
      })(DeleteFile || (DeleteFile = {}));
      (function(WorkspaceEdit3) {
        function is(value) {
          let candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit3.is = is;
      })(WorkspaceEdit || (WorkspaceEdit = {}));
      TextEditChangeImpl = class {
        constructor(edits, changeAnnotations) {
          this.edits = edits;
          this.changeAnnotations = changeAnnotations;
        }
        insert(position, newText, annotation) {
          let edit;
          let id;
          if (annotation === void 0) {
            edit = TextEdit.insert(position, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        }
        replace(range, newText, annotation) {
          let edit;
          let id;
          if (annotation === void 0) {
            edit = TextEdit.replace(range, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        }
        delete(range, annotation) {
          let edit;
          let id;
          if (annotation === void 0) {
            edit = TextEdit.del(range);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        }
        add(edit) {
          this.edits.push(edit);
        }
        all() {
          return this.edits;
        }
        clear() {
          this.edits.splice(0, this.edits.length);
        }
        assertChangeAnnotations(value) {
          if (value === void 0) {
            throw new Error(`Text edit change is not configured to manage change annotations.`);
          }
        }
      };
      ChangeAnnotations = class {
        constructor(annotations) {
          this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
          this._counter = 0;
          this._size = 0;
        }
        all() {
          return this._annotations;
        }
        get size() {
          return this._size;
        }
        manage(idOrAnnotation, annotation) {
          let id;
          if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
          } else {
            id = this.nextId();
            annotation = idOrAnnotation;
          }
          if (this._annotations[id] !== void 0) {
            throw new Error(`Id ${id} is already in use.`);
          }
          if (annotation === void 0) {
            throw new Error(`No annotation provided for id ${id}`);
          }
          this._annotations[id] = annotation;
          this._size++;
          return id;
        }
        nextId() {
          this._counter++;
          return this._counter.toString();
        }
      };
      WorkspaceChange = class {
        constructor(workspaceEdit) {
          this._textEditChanges = /* @__PURE__ */ Object.create(null);
          if (workspaceEdit !== void 0) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
              this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
              workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              workspaceEdit.documentChanges.forEach((change) => {
                if (TextDocumentEdit.is(change)) {
                  const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                  this._textEditChanges[change.textDocument.uri] = textEditChange;
                }
              });
            } else if (workspaceEdit.changes) {
              Object.keys(workspaceEdit.changes).forEach((key) => {
                const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                this._textEditChanges[key] = textEditChange;
              });
            }
          } else {
            this._workspaceEdit = {};
          }
        }
        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */
        get edit() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== void 0) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = void 0;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        }
        getTextEditChange(key) {
          if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            const textDocument = { uri: key.uri, version: key.version };
            let result = this._textEditChanges[textDocument.uri];
            if (!result) {
              const edits = [];
              const textDocumentEdit = {
                textDocument,
                edits
              };
              this._workspaceEdit.documentChanges.push(textDocumentEdit);
              result = new TextEditChangeImpl(edits, this._changeAnnotations);
              this._textEditChanges[textDocument.uri] = result;
            }
            return result;
          } else {
            this.initChanges();
            if (this._workspaceEdit.changes === void 0) {
              throw new Error("Workspace edit is not configured for normal text edit changes.");
            }
            let result = this._textEditChanges[key];
            if (!result) {
              let edits = [];
              this._workspaceEdit.changes[key] = edits;
              result = new TextEditChangeImpl(edits);
              this._textEditChanges[key] = result;
            }
            return result;
          }
        }
        initDocumentChanges() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        }
        initChanges() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
          }
        }
        createFile(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          let annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          let operation;
          let id;
          if (annotation === void 0) {
            operation = CreateFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        }
        renameFile(oldUri, newUri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          let annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          let operation;
          let id;
          if (annotation === void 0) {
            operation = RenameFile.create(oldUri, newUri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        }
        deleteFile(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          let annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          let operation;
          let id;
          if (annotation === void 0) {
            operation = DeleteFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        }
      };
      (function(TextDocumentIdentifier3) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier3.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier3.is = is;
      })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
      (function(VersionedTextDocumentIdentifier3) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier3.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier3.is = is;
      })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
      (function(OptionalVersionedTextDocumentIdentifier3) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier3.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier3.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
      (function(TextDocumentItem3) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem3.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem3.is = is;
      })(TextDocumentItem || (TextDocumentItem = {}));
      (function(MarkupKind3) {
        MarkupKind3.PlainText = "plaintext";
        MarkupKind3.Markdown = "markdown";
        function is(value) {
          const candidate = value;
          return candidate === MarkupKind3.PlainText || candidate === MarkupKind3.Markdown;
        }
        MarkupKind3.is = is;
      })(MarkupKind || (MarkupKind = {}));
      (function(MarkupContent3) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent3.is = is;
      })(MarkupContent || (MarkupContent = {}));
      (function(CompletionItemKind6) {
        CompletionItemKind6.Text = 1;
        CompletionItemKind6.Method = 2;
        CompletionItemKind6.Function = 3;
        CompletionItemKind6.Constructor = 4;
        CompletionItemKind6.Field = 5;
        CompletionItemKind6.Variable = 6;
        CompletionItemKind6.Class = 7;
        CompletionItemKind6.Interface = 8;
        CompletionItemKind6.Module = 9;
        CompletionItemKind6.Property = 10;
        CompletionItemKind6.Unit = 11;
        CompletionItemKind6.Value = 12;
        CompletionItemKind6.Enum = 13;
        CompletionItemKind6.Keyword = 14;
        CompletionItemKind6.Snippet = 15;
        CompletionItemKind6.Color = 16;
        CompletionItemKind6.File = 17;
        CompletionItemKind6.Reference = 18;
        CompletionItemKind6.Folder = 19;
        CompletionItemKind6.EnumMember = 20;
        CompletionItemKind6.Constant = 21;
        CompletionItemKind6.Struct = 22;
        CompletionItemKind6.Event = 23;
        CompletionItemKind6.Operator = 24;
        CompletionItemKind6.TypeParameter = 25;
      })(CompletionItemKind || (CompletionItemKind = {}));
      (function(InsertTextFormat3) {
        InsertTextFormat3.PlainText = 1;
        InsertTextFormat3.Snippet = 2;
      })(InsertTextFormat || (InsertTextFormat = {}));
      (function(CompletionItemTag3) {
        CompletionItemTag3.Deprecated = 1;
      })(CompletionItemTag || (CompletionItemTag = {}));
      (function(InsertReplaceEdit3) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit3.create = create;
        function is(value) {
          const candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit3.is = is;
      })(InsertReplaceEdit || (InsertReplaceEdit = {}));
      (function(InsertTextMode3) {
        InsertTextMode3.asIs = 1;
        InsertTextMode3.adjustIndentation = 2;
      })(InsertTextMode || (InsertTextMode = {}));
      (function(CompletionItemLabelDetails3) {
        function is(value) {
          const candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails3.is = is;
      })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
      (function(CompletionItem3) {
        function create(label) {
          return { label };
        }
        CompletionItem3.create = create;
      })(CompletionItem || (CompletionItem = {}));
      (function(CompletionList4) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList4.create = create;
      })(CompletionList || (CompletionList = {}));
      (function(MarkedString3) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString3.fromPlainText = fromPlainText;
        function is(value) {
          const candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString3.is = is;
      })(MarkedString || (MarkedString = {}));
      (function(Hover3) {
        function is(value) {
          let candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover3.is = is;
      })(Hover || (Hover = {}));
      (function(ParameterInformation3) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation3.create = create;
      })(ParameterInformation || (ParameterInformation = {}));
      (function(SignatureInformation3) {
        function create(label, documentation, ...parameters) {
          let result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation3.create = create;
      })(SignatureInformation || (SignatureInformation = {}));
      (function(DocumentHighlightKind3) {
        DocumentHighlightKind3.Text = 1;
        DocumentHighlightKind3.Read = 2;
        DocumentHighlightKind3.Write = 3;
      })(DocumentHighlightKind || (DocumentHighlightKind = {}));
      (function(DocumentHighlight4) {
        function create(range, kind) {
          let result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight4.create = create;
      })(DocumentHighlight || (DocumentHighlight = {}));
      (function(SymbolKind6) {
        SymbolKind6.File = 1;
        SymbolKind6.Module = 2;
        SymbolKind6.Namespace = 3;
        SymbolKind6.Package = 4;
        SymbolKind6.Class = 5;
        SymbolKind6.Method = 6;
        SymbolKind6.Property = 7;
        SymbolKind6.Field = 8;
        SymbolKind6.Constructor = 9;
        SymbolKind6.Enum = 10;
        SymbolKind6.Interface = 11;
        SymbolKind6.Function = 12;
        SymbolKind6.Variable = 13;
        SymbolKind6.Constant = 14;
        SymbolKind6.String = 15;
        SymbolKind6.Number = 16;
        SymbolKind6.Boolean = 17;
        SymbolKind6.Array = 18;
        SymbolKind6.Object = 19;
        SymbolKind6.Key = 20;
        SymbolKind6.Null = 21;
        SymbolKind6.EnumMember = 22;
        SymbolKind6.Struct = 23;
        SymbolKind6.Event = 24;
        SymbolKind6.Operator = 25;
        SymbolKind6.TypeParameter = 26;
      })(SymbolKind || (SymbolKind = {}));
      (function(SymbolTag3) {
        SymbolTag3.Deprecated = 1;
      })(SymbolTag || (SymbolTag = {}));
      (function(SymbolInformation3) {
        function create(name, kind, range, uri, containerName) {
          let result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation3.create = create;
      })(SymbolInformation || (SymbolInformation = {}));
      (function(WorkspaceSymbol3) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol3.create = create;
      })(WorkspaceSymbol || (WorkspaceSymbol = {}));
      (function(DocumentSymbol3) {
        function create(name, detail, kind, range, selectionRange, children) {
          let result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol3.create = create;
        function is(value) {
          let candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol3.is = is;
      })(DocumentSymbol || (DocumentSymbol = {}));
      (function(CodeActionKind3) {
        CodeActionKind3.Empty = "";
        CodeActionKind3.QuickFix = "quickfix";
        CodeActionKind3.Refactor = "refactor";
        CodeActionKind3.RefactorExtract = "refactor.extract";
        CodeActionKind3.RefactorInline = "refactor.inline";
        CodeActionKind3.RefactorRewrite = "refactor.rewrite";
        CodeActionKind3.Source = "source";
        CodeActionKind3.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind3.SourceFixAll = "source.fixAll";
      })(CodeActionKind || (CodeActionKind = {}));
      (function(CodeActionTriggerKind3) {
        CodeActionTriggerKind3.Invoked = 1;
        CodeActionTriggerKind3.Automatic = 2;
      })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
      (function(CodeActionContext3) {
        function create(diagnostics, only, triggerKind) {
          let result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext3.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext3.is = is;
      })(CodeActionContext || (CodeActionContext = {}));
      (function(CodeAction3) {
        function create(title, kindOrCommandOrEdit, kind) {
          let result = { title };
          let checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction3.create = create;
        function is(value) {
          let candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction3.is = is;
      })(CodeAction || (CodeAction = {}));
      (function(CodeLens3) {
        function create(range, data) {
          let result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens3.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens3.is = is;
      })(CodeLens || (CodeLens = {}));
      (function(FormattingOptions3) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions3.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions3.is = is;
      })(FormattingOptions || (FormattingOptions = {}));
      (function(DocumentLink3) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink3.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink3.is = is;
      })(DocumentLink || (DocumentLink = {}));
      (function(SelectionRange3) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange3.create = create;
        function is(value) {
          let candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange3.is(candidate.parent));
        }
        SelectionRange3.is = is;
      })(SelectionRange || (SelectionRange = {}));
      (function(SemanticTokenTypes5) {
        SemanticTokenTypes5["namespace"] = "namespace";
        SemanticTokenTypes5["type"] = "type";
        SemanticTokenTypes5["class"] = "class";
        SemanticTokenTypes5["enum"] = "enum";
        SemanticTokenTypes5["interface"] = "interface";
        SemanticTokenTypes5["struct"] = "struct";
        SemanticTokenTypes5["typeParameter"] = "typeParameter";
        SemanticTokenTypes5["parameter"] = "parameter";
        SemanticTokenTypes5["variable"] = "variable";
        SemanticTokenTypes5["property"] = "property";
        SemanticTokenTypes5["enumMember"] = "enumMember";
        SemanticTokenTypes5["event"] = "event";
        SemanticTokenTypes5["function"] = "function";
        SemanticTokenTypes5["method"] = "method";
        SemanticTokenTypes5["macro"] = "macro";
        SemanticTokenTypes5["keyword"] = "keyword";
        SemanticTokenTypes5["modifier"] = "modifier";
        SemanticTokenTypes5["comment"] = "comment";
        SemanticTokenTypes5["string"] = "string";
        SemanticTokenTypes5["number"] = "number";
        SemanticTokenTypes5["regexp"] = "regexp";
        SemanticTokenTypes5["operator"] = "operator";
        SemanticTokenTypes5["decorator"] = "decorator";
      })(SemanticTokenTypes || (SemanticTokenTypes = {}));
      (function(SemanticTokenModifiers4) {
        SemanticTokenModifiers4["declaration"] = "declaration";
        SemanticTokenModifiers4["definition"] = "definition";
        SemanticTokenModifiers4["readonly"] = "readonly";
        SemanticTokenModifiers4["static"] = "static";
        SemanticTokenModifiers4["deprecated"] = "deprecated";
        SemanticTokenModifiers4["abstract"] = "abstract";
        SemanticTokenModifiers4["async"] = "async";
        SemanticTokenModifiers4["modification"] = "modification";
        SemanticTokenModifiers4["documentation"] = "documentation";
        SemanticTokenModifiers4["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
      (function(SemanticTokens3) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens3.is = is;
      })(SemanticTokens || (SemanticTokens = {}));
      (function(InlineValueText3) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText3.create = create;
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText3.is = is;
      })(InlineValueText || (InlineValueText = {}));
      (function(InlineValueVariableLookup3) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup3.create = create;
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup3.is = is;
      })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
      (function(InlineValueEvaluatableExpression3) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression3.create = create;
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression3.is = is;
      })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
      (function(InlineValueContext3) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext3.create = create;
        function is(value) {
          const candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext3.is = is;
      })(InlineValueContext || (InlineValueContext = {}));
      (function(InlayHintKind3) {
        InlayHintKind3.Type = 1;
        InlayHintKind3.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind3.is = is;
      })(InlayHintKind || (InlayHintKind = {}));
      (function(InlayHintLabelPart3) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart3.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart3.is = is;
      })(InlayHintLabelPart || (InlayHintLabelPart = {}));
      (function(InlayHint3) {
        function create(position, label, kind) {
          const result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint3.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint3.is = is;
      })(InlayHint || (InlayHint = {}));
      (function(StringValue3) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue3.createSnippet = createSnippet;
      })(StringValue || (StringValue = {}));
      (function(InlineCompletionItem3) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem3.create = create;
      })(InlineCompletionItem || (InlineCompletionItem = {}));
      (function(InlineCompletionList3) {
        function create(items) {
          return { items };
        }
        InlineCompletionList3.create = create;
      })(InlineCompletionList || (InlineCompletionList = {}));
      (function(InlineCompletionTriggerKind3) {
        InlineCompletionTriggerKind3.Invoked = 0;
        InlineCompletionTriggerKind3.Automatic = 1;
      })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
      (function(SelectedCompletionInfo3) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo3.create = create;
      })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
      (function(InlineCompletionContext3) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext3.create = create;
      })(InlineCompletionContext || (InlineCompletionContext = {}));
      (function(WorkspaceFolder3) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder3.is = is;
      })(WorkspaceFolder || (WorkspaceFolder = {}));
      EOL = ["\n", "\r\n", "\r"];
      (function(TextDocument4) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument4.create = create;
        function is(value) {
          let candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument4.is = is;
        function applyEdits(document, edits) {
          let text = document.getText();
          let sortedEdits = mergeSort2(edits, (a2, b) => {
            let diff = a2.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a2.range.start.character - b.range.start.character;
            }
            return diff;
          });
          let lastModifiedOffset = text.length;
          for (let i = sortedEdits.length - 1; i >= 0; i--) {
            let e = sortedEdits[i];
            let startOffset = document.offsetAt(e.range.start);
            let endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument4.applyEdits = applyEdits;
        function mergeSort2(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          const p = data.length / 2 | 0;
          const left = data.slice(0, p);
          const right = data.slice(p);
          mergeSort2(left, compare);
          mergeSort2(right, compare);
          let leftIdx = 0;
          let rightIdx = 0;
          let i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            let ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument || (TextDocument = {}));
      FullTextDocument = class {
        constructor(uri, languageId, version, content) {
          this._uri = uri;
          this._languageId = languageId;
          this._version = version;
          this._content = content;
          this._lineOffsets = void 0;
        }
        get uri() {
          return this._uri;
        }
        get languageId() {
          return this._languageId;
        }
        get version() {
          return this._version;
        }
        getText(range) {
          if (range) {
            let start = this.offsetAt(range.start);
            let end = this.offsetAt(range.end);
            return this._content.substring(start, end);
          }
          return this._content;
        }
        update(event, version) {
          this._content = event.text;
          this._version = version;
          this._lineOffsets = void 0;
        }
        getLineOffsets() {
          if (this._lineOffsets === void 0) {
            let lineOffsets = [];
            let text = this._content;
            let isLineStart = true;
            for (let i = 0; i < text.length; i++) {
              if (isLineStart) {
                lineOffsets.push(i);
                isLineStart = false;
              }
              let ch = text.charAt(i);
              isLineStart = ch === "\r" || ch === "\n";
              if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                i++;
              }
            }
            if (isLineStart && text.length > 0) {
              lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
          }
          return this._lineOffsets;
        }
        positionAt(offset) {
          offset = Math.max(Math.min(offset, this._content.length), 0);
          let lineOffsets = this.getLineOffsets();
          let low = 0, high = lineOffsets.length;
          if (high === 0) {
            return Position.create(0, offset);
          }
          while (low < high) {
            let mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
              high = mid;
            } else {
              low = mid + 1;
            }
          }
          let line = low - 1;
          return Position.create(line, offset - lineOffsets[line]);
        }
        offsetAt(position) {
          let lineOffsets = this.getLineOffsets();
          if (position.line >= lineOffsets.length) {
            return this._content.length;
          } else if (position.line < 0) {
            return 0;
          }
          let lineOffset = lineOffsets[position.line];
          let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
          return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        }
        get lineCount() {
          return this.getLineOffsets().length;
        }
      };
      (function(Is3) {
        const toString4 = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is3.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is3.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is3.boolean = boolean;
        function string(value) {
          return toString4.call(value) === "[object String]";
        }
        Is3.string = string;
        function number(value) {
          return toString4.call(value) === "[object Number]";
        }
        Is3.number = number;
        function numberRange(value, min2, max) {
          return toString4.call(value) === "[object Number]" && min2 <= value && value <= max;
        }
        Is3.numberRange = numberRange;
        function integer3(value) {
          return toString4.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is3.integer = integer3;
        function uinteger3(value) {
          return toString4.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is3.uinteger = uinteger3;
        function func(value) {
          return toString4.call(value) === "[object Function]";
        }
        Is3.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is3.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is3.typedArray = typedArray;
      })(Is || (Is = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/ral.js
  var require_ral = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var _ral;
      function RAL() {
        if (_ral === void 0) {
          throw new Error(`No runtime abstraction layer installed`);
        }
        return _ral;
      }
      (function(RAL2) {
        function install(ral) {
          if (ral === void 0) {
            throw new Error(`No runtime abstraction layer provided`);
          }
          _ral = ral;
        }
        RAL2.install = install;
      })(RAL || (RAL = {}));
      exports2.default = RAL;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/is.js
  var require_is = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/events.js
  var require_events = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Emitter = exports2.Event = void 0;
      var ral_1 = require_ral();
      var Event;
      (function(Event2) {
        const _disposable = { dispose() {
        } };
        Event2.None = function() {
          return _disposable;
        };
      })(Event || (exports2.Event = Event = {}));
      var CallbackList = class {
        add(callback, context = null, bucket) {
          if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
          }
          this._callbacks.push(callback);
          this._contexts.push(context);
          if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
          }
        }
        remove(callback, context = null) {
          if (!this._callbacks) {
            return;
          }
          let foundCallbackWithDifferentContext = false;
          for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
              if (this._contexts[i] === context) {
                this._callbacks.splice(i, 1);
                this._contexts.splice(i, 1);
                return;
              } else {
                foundCallbackWithDifferentContext = true;
              }
            }
          }
          if (foundCallbackWithDifferentContext) {
            throw new Error("When adding a listener with a context, you should remove it with the same context");
          }
        }
        invoke(...args) {
          if (!this._callbacks) {
            return [];
          }
          const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
          for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
              ret.push(callbacks[i].apply(contexts[i], args));
            } catch (e) {
              (0, ral_1.default)().console.error(e);
            }
          }
          return ret;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          this._callbacks = void 0;
          this._contexts = void 0;
        }
      };
      var Emitter3 = class _Emitter {
        constructor(_options) {
          this._options = _options;
        }
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get event() {
          if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
              if (!this._callbacks) {
                this._callbacks = new CallbackList();
              }
              if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                this._options.onFirstListenerAdd(this);
              }
              this._callbacks.add(listener, thisArgs);
              const result = {
                dispose: () => {
                  if (!this._callbacks) {
                    return;
                  }
                  this._callbacks.remove(listener, thisArgs);
                  result.dispose = _Emitter._noop;
                  if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                    this._options.onLastListenerRemove(this);
                  }
                }
              };
              if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event) {
          if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
          }
        }
        dispose() {
          if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = void 0;
          }
        }
      };
      exports2.Emitter = Emitter3;
      Emitter3._noop = function() {
      };
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/cancellation.js
  var require_cancellation = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
      var ral_1 = require_ral();
      var Is3 = require_is();
      var events_1 = require_events();
      var CancellationToken18;
      (function(CancellationToken19) {
        CancellationToken19.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: events_1.Event.None
        });
        CancellationToken19.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: events_1.Event.None
        });
        function is(value) {
          const candidate = value;
          return candidate && (candidate === CancellationToken19.None || candidate === CancellationToken19.Cancelled || Is3.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
        }
        CancellationToken19.is = is;
      })(CancellationToken18 || (exports2.CancellationToken = CancellationToken18 = {}));
      var shortcutEvent = Object.freeze(function(callback, context) {
        const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
        return { dispose() {
          handle.dispose();
        } };
      });
      var MutableToken = class {
        constructor() {
          this._isCancelled = false;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new events_1.Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = void 0;
          }
        }
      };
      var CancellationTokenSource3 = class {
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken18.Cancelled;
          } else {
            this._token.cancel();
          }
        }
        dispose() {
          if (!this._token) {
            this._token = CancellationToken18.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
      exports2.CancellationTokenSource = CancellationTokenSource3;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/messages.js
  var require_messages = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
      var is = require_is();
      var ErrorCodes;
      (function(ErrorCodes2) {
        ErrorCodes2.ParseError = -32700;
        ErrorCodes2.InvalidRequest = -32600;
        ErrorCodes2.MethodNotFound = -32601;
        ErrorCodes2.InvalidParams = -32602;
        ErrorCodes2.InternalError = -32603;
        ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
        ErrorCodes2.serverErrorStart = -32099;
        ErrorCodes2.MessageWriteError = -32099;
        ErrorCodes2.MessageReadError = -32098;
        ErrorCodes2.PendingResponseRejected = -32097;
        ErrorCodes2.ConnectionInactive = -32096;
        ErrorCodes2.ServerNotInitialized = -32002;
        ErrorCodes2.UnknownErrorCode = -32001;
        ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
        ErrorCodes2.serverErrorEnd = -32e3;
      })(ErrorCodes || (exports2.ErrorCodes = ErrorCodes = {}));
      var ResponseError2 = class _ResponseError extends Error {
        constructor(code, message, data) {
          super(message);
          this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
          this.data = data;
          Object.setPrototypeOf(this, _ResponseError.prototype);
        }
        toJson() {
          const result = {
            code: this.code,
            message: this.message
          };
          if (this.data !== void 0) {
            result.data = this.data;
          }
          return result;
        }
      };
      exports2.ResponseError = ResponseError2;
      var ParameterStructures = class _ParameterStructures {
        constructor(kind) {
          this.kind = kind;
        }
        static is(value) {
          return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
        }
        toString() {
          return this.kind;
        }
      };
      exports2.ParameterStructures = ParameterStructures;
      ParameterStructures.auto = new ParameterStructures("auto");
      ParameterStructures.byPosition = new ParameterStructures("byPosition");
      ParameterStructures.byName = new ParameterStructures("byName");
      var AbstractMessageSignature = class {
        constructor(method, numberOfParams) {
          this.method = method;
          this.numberOfParams = numberOfParams;
        }
        get parameterStructures() {
          return ParameterStructures.auto;
        }
      };
      exports2.AbstractMessageSignature = AbstractMessageSignature;
      var RequestType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports2.RequestType0 = RequestType0;
      var RequestType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.RequestType = RequestType;
      var RequestType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.RequestType1 = RequestType1;
      var RequestType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports2.RequestType2 = RequestType2;
      var RequestType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports2.RequestType3 = RequestType3;
      var RequestType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports2.RequestType4 = RequestType4;
      var RequestType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports2.RequestType5 = RequestType5;
      var RequestType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports2.RequestType6 = RequestType6;
      var RequestType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports2.RequestType7 = RequestType7;
      var RequestType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports2.RequestType8 = RequestType8;
      var RequestType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports2.RequestType9 = RequestType9;
      var NotificationType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.NotificationType = NotificationType;
      var NotificationType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports2.NotificationType0 = NotificationType0;
      var NotificationType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.NotificationType1 = NotificationType1;
      var NotificationType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports2.NotificationType2 = NotificationType2;
      var NotificationType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports2.NotificationType3 = NotificationType3;
      var NotificationType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports2.NotificationType4 = NotificationType4;
      var NotificationType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports2.NotificationType5 = NotificationType5;
      var NotificationType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports2.NotificationType6 = NotificationType6;
      var NotificationType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports2.NotificationType7 = NotificationType7;
      var NotificationType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports2.NotificationType8 = NotificationType8;
      var NotificationType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports2.NotificationType9 = NotificationType9;
      var Message;
      (function(Message2) {
        function isRequest(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
        }
        Message2.isRequest = isRequest;
        function isNotification(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && message.id === void 0;
        }
        Message2.isNotification = isNotification;
        function isResponse(message) {
          const candidate = message;
          return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
        }
        Message2.isResponse = isResponse;
      })(Message || (exports2.Message = Message = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
  var require_linkedMap = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
      "use strict";
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
      var Touch;
      (function(Touch2) {
        Touch2.None = 0;
        Touch2.First = 1;
        Touch2.AsOld = Touch2.First;
        Touch2.Last = 2;
        Touch2.AsNew = Touch2.Last;
      })(Touch || (exports2.Touch = Touch = {}));
      var LinkedMap = class {
        constructor() {
          this[_a] = "LinkedMap";
          this._map = /* @__PURE__ */ new Map();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state = 0;
        }
        clear() {
          this._map.clear();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          return this._head?.value;
        }
        get last() {
          return this._tail?.value;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key, touch = Touch.None) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
          return item.value;
        }
        set(key, value, touch = Touch.None) {
          let item = this._map.get(key);
          if (item) {
            item.value = value;
            if (touch !== Touch.None) {
              this.touch(item, touch);
            }
          } else {
            item = { key, value, next: void 0, previous: void 0 };
            switch (touch) {
              case Touch.None:
                this.addItemLast(item);
                break;
              case Touch.First:
                this.addItemFirst(item);
                break;
              case Touch.Last:
                this.addItemLast(item);
                break;
              default:
                this.addItemLast(item);
                break;
            }
            this._map.set(key, item);
            this._size++;
          }
          return this;
        }
        delete(key) {
          return !!this.remove(key);
        }
        remove(key) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          this._map.delete(key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        shift() {
          if (!this._head && !this._tail) {
            return void 0;
          }
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          const item = this._head;
          this._map.delete(item.key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        forEach(callbackfn, thisArg) {
          const state = this._state;
          let current = this._head;
          while (current) {
            if (thisArg) {
              callbackfn.bind(thisArg)(current.value, current.key, this);
            } else {
              callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
          }
        }
        keys() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.key, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        values() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.value, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        entries() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: [current.key, current.value], done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        [(_a = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(newSize) {
          if (newSize >= this.size) {
            return;
          }
          if (newSize === 0) {
            this.clear();
            return;
          }
          let current = this._head;
          let currentSize = this.size;
          while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          if (current) {
            current.previous = void 0;
          }
          this._state++;
        }
        addItemFirst(item) {
          if (!this._head && !this._tail) {
            this._tail = item;
          } else if (!this._head) {
            throw new Error("Invalid list");
          } else {
            item.next = this._head;
            this._head.previous = item;
          }
          this._head = item;
          this._state++;
        }
        addItemLast(item) {
          if (!this._head && !this._tail) {
            this._head = item;
          } else if (!this._tail) {
            throw new Error("Invalid list");
          } else {
            item.previous = this._tail;
            this._tail.next = item;
          }
          this._tail = item;
          this._state++;
        }
        removeItem(item) {
          if (item === this._head && item === this._tail) {
            this._head = void 0;
            this._tail = void 0;
          } else if (item === this._head) {
            if (!item.next) {
              throw new Error("Invalid list");
            }
            item.next.previous = void 0;
            this._head = item.next;
          } else if (item === this._tail) {
            if (!item.previous) {
              throw new Error("Invalid list");
            }
            item.previous.next = void 0;
            this._tail = item.previous;
          } else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
              throw new Error("Invalid list");
            }
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = void 0;
          this._state++;
        }
        touch(item, touch) {
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          if (touch !== Touch.First && touch !== Touch.Last) {
            return;
          }
          if (touch === Touch.First) {
            if (item === this._head) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._tail) {
              previous.next = void 0;
              this._tail = previous;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.previous = void 0;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
          } else if (touch === Touch.Last) {
            if (item === this._tail) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._head) {
              next.previous = void 0;
              this._head = next;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.next = void 0;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
          }
        }
        toJSON() {
          const data = [];
          this.forEach((value, key) => {
            data.push([key, value]);
          });
          return data;
        }
        fromJSON(data) {
          this.clear();
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      };
      exports2.LinkedMap = LinkedMap;
      var LRUCache = class extends LinkedMap {
        constructor(limit, ratio = 1) {
          super();
          this._limit = limit;
          this._ratio = Math.min(Math.max(0, ratio), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(limit) {
          this._limit = limit;
          this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(ratio) {
          this._ratio = Math.min(Math.max(0, ratio), 1);
          this.checkTrim();
        }
        get(key, touch = Touch.AsNew) {
          return super.get(key, touch);
        }
        peek(key) {
          return super.get(key, Touch.None);
        }
        set(key, value) {
          super.set(key, value, Touch.Last);
          this.checkTrim();
          return this;
        }
        checkTrim() {
          if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
          }
        }
      };
      exports2.LRUCache = LRUCache;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/disposable.js
  var require_disposable = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Disposable = void 0;
      var Disposable2;
      (function(Disposable3) {
        function create(func) {
          return {
            dispose: func
          };
        }
        Disposable3.create = create;
      })(Disposable2 || (exports2.Disposable = Disposable2 = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
  var require_sharedArrayCancellation = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
      var cancellation_1 = require_cancellation();
      var CancellationState;
      (function(CancellationState2) {
        CancellationState2.Continue = 0;
        CancellationState2.Cancelled = 1;
      })(CancellationState || (CancellationState = {}));
      var SharedArraySenderStrategy = class {
        constructor() {
          this.buffers = /* @__PURE__ */ new Map();
        }
        enableCancellation(request) {
          if (request.id === null) {
            return;
          }
          const buffer = new SharedArrayBuffer(4);
          const data = new Int32Array(buffer, 0, 1);
          data[0] = CancellationState.Continue;
          this.buffers.set(request.id, buffer);
          request.$cancellationData = buffer;
        }
        async sendCancellation(_conn, id) {
          const buffer = this.buffers.get(id);
          if (buffer === void 0) {
            return;
          }
          const data = new Int32Array(buffer, 0, 1);
          Atomics.store(data, 0, CancellationState.Cancelled);
        }
        cleanup(id) {
          this.buffers.delete(id);
        }
        dispose() {
          this.buffers.clear();
        }
      };
      exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
      var SharedArrayBufferCancellationToken = class {
        constructor(buffer) {
          this.data = new Int32Array(buffer, 0, 1);
        }
        get isCancellationRequested() {
          return Atomics.load(this.data, 0) === CancellationState.Cancelled;
        }
        get onCancellationRequested() {
          throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
        }
      };
      var SharedArrayBufferCancellationTokenSource = class {
        constructor(buffer) {
          this.token = new SharedArrayBufferCancellationToken(buffer);
        }
        cancel() {
        }
        dispose() {
        }
      };
      var SharedArrayReceiverStrategy = class {
        constructor() {
          this.kind = "request";
        }
        createCancellationTokenSource(request) {
          const buffer = request.$cancellationData;
          if (buffer === void 0) {
            return new cancellation_1.CancellationTokenSource();
          }
          return new SharedArrayBufferCancellationTokenSource(buffer);
        }
      };
      exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/semaphore.js
  var require_semaphore = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Semaphore = void 0;
      var ral_1 = require_ral();
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve, reject2) => {
            this._waiting.push({ thunk, resolve, reject: reject2 });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports2.Semaphore = Semaphore;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/messageReader.js
  var require_messageReader = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
      var ral_1 = require_ral();
      var Is3 = require_is();
      var events_1 = require_events();
      var semaphore_1 = require_semaphore();
      var MessageReader;
      (function(MessageReader2) {
        function is(value) {
          let candidate = value;
          return candidate && Is3.func(candidate.listen) && Is3.func(candidate.dispose) && Is3.func(candidate.onError) && Is3.func(candidate.onClose) && Is3.func(candidate.onPartialMessage);
        }
        MessageReader2.is = is;
      })(MessageReader || (exports2.MessageReader = MessageReader = {}));
      var AbstractMessageReader = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
          this.partialMessageEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error) {
          this.errorEmitter.fire(this.asError(error));
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        get onPartialMessage() {
          return this.partialMessageEmitter.event;
        }
        firePartialMessage(info) {
          this.partialMessageEmitter.fire(info);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Reader received error. Reason: ${Is3.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports2.AbstractMessageReader = AbstractMessageReader;
      var ResolvedMessageReaderOptions;
      (function(ResolvedMessageReaderOptions2) {
        function fromOptions(options) {
          let charset;
          let result;
          let contentDecoder;
          const contentDecoders = /* @__PURE__ */ new Map();
          let contentTypeDecoder;
          const contentTypeDecoders = /* @__PURE__ */ new Map();
          if (options === void 0 || typeof options === "string") {
            charset = options ?? "utf-8";
          } else {
            charset = options.charset ?? "utf-8";
            if (options.contentDecoder !== void 0) {
              contentDecoder = options.contentDecoder;
              contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== void 0) {
              for (const decoder of options.contentDecoders) {
                contentDecoders.set(decoder.name, decoder);
              }
            }
            if (options.contentTypeDecoder !== void 0) {
              contentTypeDecoder = options.contentTypeDecoder;
              contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== void 0) {
              for (const decoder of options.contentTypeDecoders) {
                contentTypeDecoders.set(decoder.name, decoder);
              }
            }
          }
          if (contentTypeDecoder === void 0) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
        }
        ResolvedMessageReaderOptions2.fromOptions = fromOptions;
      })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
      var ReadableStreamMessageReader = class extends AbstractMessageReader {
        constructor(readable, options) {
          super();
          this.readable = readable;
          this.options = ResolvedMessageReaderOptions.fromOptions(options);
          this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
          this._partialMessageTimeout = 1e4;
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.readSemaphore = new semaphore_1.Semaphore(1);
        }
        set partialMessageTimeout(timeout) {
          this._partialMessageTimeout = timeout;
        }
        get partialMessageTimeout() {
          return this._partialMessageTimeout;
        }
        listen(callback) {
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.partialMessageTimer = void 0;
          this.callback = callback;
          const result = this.readable.onData((data) => {
            this.onData(data);
          });
          this.readable.onError((error) => this.fireError(error));
          this.readable.onClose(() => this.fireClose());
          return result;
        }
        onData(data) {
          try {
            this.buffer.append(data);
            while (true) {
              if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders(true);
                if (!headers) {
                  return;
                }
                const contentLength = headers.get("content-length");
                if (!contentLength) {
                  this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                  return;
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                  this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                  return;
                }
                this.nextMessageLength = length;
              }
              const body = this.buffer.tryReadBody(this.nextMessageLength);
              if (body === void 0) {
                this.setPartialMessageTimer();
                return;
              }
              this.clearPartialMessageTimer();
              this.nextMessageLength = -1;
              this.readSemaphore.lock(async () => {
                const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                this.callback(message);
              }).catch((error) => {
                this.fireError(error);
              });
            }
          } catch (error) {
            this.fireError(error);
          }
        }
        clearPartialMessageTimer() {
          if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = void 0;
          }
        }
        setPartialMessageTimer() {
          this.clearPartialMessageTimer();
          if (this._partialMessageTimeout <= 0) {
            return;
          }
          this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = void 0;
            if (token === this.messageToken) {
              this.firePartialMessage({ messageToken: token, waitingTime: timeout });
              this.setPartialMessageTimer();
            }
          }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
        }
      };
      exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
  var require_messageWriter = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
      var ral_1 = require_ral();
      var Is3 = require_is();
      var semaphore_1 = require_semaphore();
      var events_1 = require_events();
      var ContentLength = "Content-Length: ";
      var CRLF = "\r\n";
      var MessageWriter;
      (function(MessageWriter2) {
        function is(value) {
          let candidate = value;
          return candidate && Is3.func(candidate.dispose) && Is3.func(candidate.onClose) && Is3.func(candidate.onError) && Is3.func(candidate.write);
        }
        MessageWriter2.is = is;
      })(MessageWriter || (exports2.MessageWriter = MessageWriter = {}));
      var AbstractMessageWriter = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error, message, count) {
          this.errorEmitter.fire([this.asError(error), message, count]);
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Writer received error. Reason: ${Is3.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports2.AbstractMessageWriter = AbstractMessageWriter;
      var ResolvedMessageWriterOptions;
      (function(ResolvedMessageWriterOptions2) {
        function fromOptions(options) {
          if (options === void 0 || typeof options === "string") {
            return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
          } else {
            return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
          }
        }
        ResolvedMessageWriterOptions2.fromOptions = fromOptions;
      })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
      var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
        constructor(writable, options) {
          super();
          this.writable = writable;
          this.options = ResolvedMessageWriterOptions.fromOptions(options);
          this.errorCount = 0;
          this.writeSemaphore = new semaphore_1.Semaphore(1);
          this.writable.onError((error) => this.fireError(error));
          this.writable.onClose(() => this.fireClose());
        }
        async write(msg) {
          return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
              if (this.options.contentEncoder !== void 0) {
                return this.options.contentEncoder.encode(buffer);
              } else {
                return buffer;
              }
            });
            return payload.then((buffer) => {
              const headers = [];
              headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
              headers.push(CRLF);
              return this.doWrite(msg, headers, buffer);
            }, (error) => {
              this.fireError(error);
              throw error;
            });
          });
        }
        async doWrite(msg, headers, data) {
          try {
            await this.writable.write(headers.join(""), "ascii");
            return this.writable.write(data);
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
          this.writable.end();
        }
      };
      exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
  var require_messageBuffer = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AbstractMessageBuffer = void 0;
      var CR = 13;
      var LF = 10;
      var CRLF = "\r\n";
      var AbstractMessageBuffer = class {
        constructor(encoding = "utf-8") {
          this._encoding = encoding;
          this._chunks = [];
          this._totalLength = 0;
        }
        get encoding() {
          return this._encoding;
        }
        append(chunk) {
          const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
          this._chunks.push(toAppend);
          this._totalLength += toAppend.byteLength;
        }
        tryReadHeaders(lowerCaseKeys = false) {
          if (this._chunks.length === 0) {
            return void 0;
          }
          let state = 0;
          let chunkIndex = 0;
          let offset = 0;
          let chunkBytesRead = 0;
          row:
            while (chunkIndex < this._chunks.length) {
              const chunk = this._chunks[chunkIndex];
              offset = 0;
              column:
                while (offset < chunk.length) {
                  const value = chunk[offset];
                  switch (value) {
                    case CR:
                      switch (state) {
                        case 0:
                          state = 1;
                          break;
                        case 2:
                          state = 3;
                          break;
                        default:
                          state = 0;
                      }
                      break;
                    case LF:
                      switch (state) {
                        case 1:
                          state = 2;
                          break;
                        case 3:
                          state = 4;
                          offset++;
                          break row;
                        default:
                          state = 0;
                      }
                      break;
                    default:
                      state = 0;
                  }
                  offset++;
                }
              chunkBytesRead += chunk.byteLength;
              chunkIndex++;
            }
          if (state !== 4) {
            return void 0;
          }
          const buffer = this._read(chunkBytesRead + offset);
          const result = /* @__PURE__ */ new Map();
          const headers = this.toString(buffer, "ascii").split(CRLF);
          if (headers.length < 2) {
            return result;
          }
          for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(":");
            if (index === -1) {
              throw new Error(`Message header must separate key and value using ':'
${header}`);
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
          }
          return result;
        }
        tryReadBody(length) {
          if (this._totalLength < length) {
            return void 0;
          }
          return this._read(length);
        }
        get numberOfBytes() {
          return this._totalLength;
        }
        _read(byteCount) {
          if (byteCount === 0) {
            return this.emptyBuffer();
          }
          if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
          }
          if (this._chunks[0].byteLength === byteCount) {
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
          }
          if (this._chunks[0].byteLength > byteCount) {
            const chunk = this._chunks[0];
            const result2 = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result2;
          }
          const result = this.allocNative(byteCount);
          let resultOffset = 0;
          let chunkIndex = 0;
          while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
              const chunkPart = chunk.slice(0, byteCount);
              result.set(chunkPart, resultOffset);
              resultOffset += byteCount;
              this._chunks[chunkIndex] = chunk.slice(byteCount);
              this._totalLength -= byteCount;
              byteCount -= byteCount;
            } else {
              result.set(chunk, resultOffset);
              resultOffset += chunk.byteLength;
              this._chunks.shift();
              this._totalLength -= chunk.byteLength;
              byteCount -= chunk.byteLength;
            }
          }
          return result;
        }
      };
      exports2.AbstractMessageBuffer = AbstractMessageBuffer;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/connection.js
  var require_connection = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
      var ral_1 = require_ral();
      var Is3 = require_is();
      var messages_1 = require_messages();
      var linkedMap_1 = require_linkedMap();
      var events_1 = require_events();
      var cancellation_1 = require_cancellation();
      var CancelNotification;
      (function(CancelNotification2) {
        CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
      })(CancelNotification || (CancelNotification = {}));
      var ProgressToken;
      (function(ProgressToken2) {
        function is(value) {
          return typeof value === "string" || typeof value === "number";
        }
        ProgressToken2.is = is;
      })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
      var ProgressNotification;
      (function(ProgressNotification2) {
        ProgressNotification2.type = new messages_1.NotificationType("$/progress");
      })(ProgressNotification || (ProgressNotification = {}));
      var ProgressType = class {
        constructor() {
        }
      };
      exports2.ProgressType = ProgressType;
      var StarRequestHandler;
      (function(StarRequestHandler2) {
        function is(value) {
          return Is3.func(value);
        }
        StarRequestHandler2.is = is;
      })(StarRequestHandler || (StarRequestHandler = {}));
      exports2.NullLogger = Object.freeze({
        error: () => {
        },
        warn: () => {
        },
        info: () => {
        },
        log: () => {
        }
      });
      var Trace;
      (function(Trace2) {
        Trace2[Trace2["Off"] = 0] = "Off";
        Trace2[Trace2["Messages"] = 1] = "Messages";
        Trace2[Trace2["Compact"] = 2] = "Compact";
        Trace2[Trace2["Verbose"] = 3] = "Verbose";
      })(Trace || (exports2.Trace = Trace = {}));
      var TraceValues;
      (function(TraceValues2) {
        TraceValues2.Off = "off";
        TraceValues2.Messages = "messages";
        TraceValues2.Compact = "compact";
        TraceValues2.Verbose = "verbose";
      })(TraceValues || (exports2.TraceValues = TraceValues = {}));
      (function(Trace2) {
        function fromString(value) {
          if (!Is3.string(value)) {
            return Trace2.Off;
          }
          value = value.toLowerCase();
          switch (value) {
            case "off":
              return Trace2.Off;
            case "messages":
              return Trace2.Messages;
            case "compact":
              return Trace2.Compact;
            case "verbose":
              return Trace2.Verbose;
            default:
              return Trace2.Off;
          }
        }
        Trace2.fromString = fromString;
        function toString4(value) {
          switch (value) {
            case Trace2.Off:
              return "off";
            case Trace2.Messages:
              return "messages";
            case Trace2.Compact:
              return "compact";
            case Trace2.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        Trace2.toString = toString4;
      })(Trace || (exports2.Trace = Trace = {}));
      var TraceFormat;
      (function(TraceFormat2) {
        TraceFormat2["Text"] = "text";
        TraceFormat2["JSON"] = "json";
      })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
      (function(TraceFormat2) {
        function fromString(value) {
          if (!Is3.string(value)) {
            return TraceFormat2.Text;
          }
          value = value.toLowerCase();
          if (value === "json") {
            return TraceFormat2.JSON;
          } else {
            return TraceFormat2.Text;
          }
        }
        TraceFormat2.fromString = fromString;
      })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
      var SetTraceNotification;
      (function(SetTraceNotification2) {
        SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
      })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
      var LogTraceNotification;
      (function(LogTraceNotification2) {
        LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
      })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
      var ConnectionErrors;
      (function(ConnectionErrors2) {
        ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
        ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
        ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
      })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
      var ConnectionError = class _ConnectionError extends Error {
        constructor(code, message) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, _ConnectionError.prototype);
        }
      };
      exports2.ConnectionError = ConnectionError;
      var ConnectionStrategy;
      (function(ConnectionStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is3.func(candidate.cancelUndispatched);
        }
        ConnectionStrategy2.is = is;
      })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
      var IdCancellationReceiverStrategy;
      (function(IdCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is3.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is3.func(candidate.dispose));
        }
        IdCancellationReceiverStrategy2.is = is;
      })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
      var RequestCancellationReceiverStrategy;
      (function(RequestCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && candidate.kind === "request" && Is3.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is3.func(candidate.dispose));
        }
        RequestCancellationReceiverStrategy2.is = is;
      })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
      var CancellationReceiverStrategy;
      (function(CancellationReceiverStrategy2) {
        CancellationReceiverStrategy2.Message = Object.freeze({
          createCancellationTokenSource(_5) {
            return new cancellation_1.CancellationTokenSource();
          }
        });
        function is(value) {
          return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
        }
        CancellationReceiverStrategy2.is = is;
      })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
      var CancellationSenderStrategy;
      (function(CancellationSenderStrategy2) {
        CancellationSenderStrategy2.Message = Object.freeze({
          sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
          },
          cleanup(_5) {
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is3.func(candidate.sendCancellation) && Is3.func(candidate.cleanup);
        }
        CancellationSenderStrategy2.is = is;
      })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
      var CancellationStrategy;
      (function(CancellationStrategy2) {
        CancellationStrategy2.Message = Object.freeze({
          receiver: CancellationReceiverStrategy.Message,
          sender: CancellationSenderStrategy.Message
        });
        function is(value) {
          const candidate = value;
          return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
        }
        CancellationStrategy2.is = is;
      })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
      var MessageStrategy;
      (function(MessageStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is3.func(candidate.handleMessage);
        }
        MessageStrategy2.is = is;
      })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
      var ConnectionOptions;
      (function(ConnectionOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
        }
        ConnectionOptions2.is = is;
      })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["New"] = 1] = "New";
        ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
        ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
        ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
      })(ConnectionState || (ConnectionState = {}));
      function createMessageConnection(messageReader2, messageWriter2, _logger, options) {
        const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
        let sequenceNumber = 0;
        let notificationSequenceNumber = 0;
        let unknownResponseSequenceNumber = 0;
        const version = "2.0";
        let starRequestHandler = void 0;
        const requestHandlers = /* @__PURE__ */ new Map();
        let starNotificationHandler = void 0;
        const notificationHandlers = /* @__PURE__ */ new Map();
        const progressHandlers = /* @__PURE__ */ new Map();
        let timer2;
        let messageQueue = new linkedMap_1.LinkedMap();
        let responsePromises = /* @__PURE__ */ new Map();
        let knownCanceledRequests = /* @__PURE__ */ new Set();
        let requestTokens = /* @__PURE__ */ new Map();
        let trace = Trace.Off;
        let traceFormat = TraceFormat.Text;
        let tracer;
        let state = ConnectionState.New;
        const errorEmitter = new events_1.Emitter();
        const closeEmitter = new events_1.Emitter();
        const unhandledNotificationEmitter = new events_1.Emitter();
        const unhandledProgressEmitter = new events_1.Emitter();
        const disposeEmitter = new events_1.Emitter();
        const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
        function createRequestQueueKey(id) {
          if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
          }
          return "req-" + id.toString();
        }
        function createResponseQueueKey(id) {
          if (id === null) {
            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
          } else {
            return "res-" + id.toString();
          }
        }
        function createNotificationQueueKey() {
          return "not-" + (++notificationSequenceNumber).toString();
        }
        function addMessageToQueue(queue, message) {
          if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
          } else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
          } else {
            queue.set(createNotificationQueueKey(), message);
          }
        }
        function cancelUndispatched(_message) {
          return void 0;
        }
        function isListening() {
          return state === ConnectionState.Listening;
        }
        function isClosed() {
          return state === ConnectionState.Closed;
        }
        function isDisposed() {
          return state === ConnectionState.Disposed;
        }
        function closeHandler() {
          if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(void 0);
          }
        }
        function readErrorHandler(error) {
          errorEmitter.fire([error, void 0, void 0]);
        }
        function writeErrorHandler(data) {
          errorEmitter.fire(data);
        }
        messageReader2.onClose(closeHandler);
        messageReader2.onError(readErrorHandler);
        messageWriter2.onClose(closeHandler);
        messageWriter2.onError(writeErrorHandler);
        function triggerMessageQueue() {
          if (timer2 || messageQueue.size === 0) {
            return;
          }
          timer2 = (0, ral_1.default)().timer.setImmediate(() => {
            timer2 = void 0;
            processMessageQueue();
          });
        }
        function handleMessage(message) {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        }
        function processMessageQueue() {
          if (messageQueue.size === 0) {
            return;
          }
          const message = messageQueue.shift();
          try {
            const messageStrategy = options?.messageStrategy;
            if (MessageStrategy.is(messageStrategy)) {
              messageStrategy.handleMessage(message, handleMessage);
            } else {
              handleMessage(message);
            }
          } finally {
            triggerMessageQueue();
          }
        }
        const callback = (message) => {
          try {
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
              const cancelId = message.params.id;
              const key = createRequestQueueKey(cancelId);
              const toCancel = messageQueue.get(key);
              if (messages_1.Message.isRequest(toCancel)) {
                const strategy = options?.connectionStrategy;
                const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                if (response && (response.error !== void 0 || response.result !== void 0)) {
                  messageQueue.delete(key);
                  requestTokens.delete(cancelId);
                  response.id = toCancel.id;
                  traceSendingResponse(response, message.method, Date.now());
                  messageWriter2.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                  return;
                }
              }
              const cancellationToken = requestTokens.get(cancelId);
              if (cancellationToken !== void 0) {
                cancellationToken.cancel();
                traceReceivedNotification(message);
                return;
              } else {
                knownCanceledRequests.add(cancelId);
              }
            }
            addMessageToQueue(messageQueue, message);
          } finally {
            triggerMessageQueue();
          }
        };
        function handleRequest(requestMessage) {
          if (isDisposed()) {
            return;
          }
          function reply(resultOrError, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
              message.error = resultOrError.toJson();
            } else {
              message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replyError(error, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              error: error.toJson()
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replySuccess(result, method, startTime2) {
            if (result === void 0) {
              result = null;
            }
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              result
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          traceReceivedRequest(requestMessage);
          const element = requestHandlers.get(requestMessage.method);
          let type;
          let requestHandler;
          if (element) {
            type = element.type;
            requestHandler = element.handler;
          }
          const startTime = Date.now();
          if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now());
            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
              cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
              requestTokens.set(tokenKey, cancellationSource);
            }
            try {
              let handlerResult;
              if (requestHandler) {
                if (requestMessage.params === void 0) {
                  if (type !== void 0 && type.numberOfParams !== 0) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(cancellationSource.token);
                } else if (Array.isArray(requestMessage.params)) {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                }
              } else if (starRequestHandler) {
                handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
              }
              const promise = handlerResult;
              if (!handlerResult) {
                requestTokens.delete(tokenKey);
                replySuccess(handlerResult, requestMessage.method, startTime);
              } else if (promise.then) {
                promise.then((resultOrError) => {
                  requestTokens.delete(tokenKey);
                  reply(resultOrError, requestMessage.method, startTime);
                }, (error) => {
                  requestTokens.delete(tokenKey);
                  if (error instanceof messages_1.ResponseError) {
                    replyError(error, requestMessage.method, startTime);
                  } else if (error && Is3.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                  } else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                  }
                });
              } else {
                requestTokens.delete(tokenKey);
                reply(handlerResult, requestMessage.method, startTime);
              }
            } catch (error) {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                reply(error, requestMessage.method, startTime);
              } else if (error && Is3.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            }
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
          }
        }
        function handleResponse(responseMessage) {
          if (isDisposed()) {
            return;
          }
          if (responseMessage.id === null) {
            if (responseMessage.error) {
              logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
            } else {
              logger.error(`Received response message without id. No further error information provided.`);
            }
          } else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== void 0) {
              responsePromises.delete(key);
              try {
                if (responseMessage.error) {
                  const error = responseMessage.error;
                  responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                } else if (responseMessage.result !== void 0) {
                  responsePromise.resolve(responseMessage.result);
                } else {
                  throw new Error("Should never happen.");
                }
              } catch (error) {
                if (error.message) {
                  logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                } else {
                  logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                }
              }
            }
          }
        }
        function handleNotification(message) {
          if (isDisposed()) {
            return;
          }
          let type = void 0;
          let notificationHandler;
          if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
          } else {
            const element = notificationHandlers.get(message.method);
            if (element) {
              notificationHandler = element.handler;
              type = element.type;
            }
          }
          if (notificationHandler || starNotificationHandler) {
            try {
              traceReceivedNotification(message);
              if (notificationHandler) {
                if (message.params === void 0) {
                  if (type !== void 0) {
                    if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                    }
                  }
                  notificationHandler();
                } else if (Array.isArray(message.params)) {
                  const params = message.params;
                  if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                    notificationHandler({ token: params[0], value: params[1] });
                  } else {
                    if (type !== void 0) {
                      if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                        logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                      }
                      if (type.numberOfParams !== message.params.length) {
                        logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                      }
                    }
                    notificationHandler(...params);
                  }
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                  }
                  notificationHandler(message.params);
                }
              } else if (starNotificationHandler) {
                starNotificationHandler(message.method, message.params);
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
              }
            }
          } else {
            unhandledNotificationEmitter.fire(message);
          }
        }
        function handleInvalidMessage(message) {
          if (!message) {
            logger.error("Received empty message.");
            return;
          }
          logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
          const responseMessage = message;
          if (Is3.string(responseMessage.id) || Is3.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
              responseHandler.reject(new Error("The received response has neither a result nor an error property."));
            }
          }
        }
        function stringifyTrace(params) {
          if (params === void 0 || params === null) {
            return void 0;
          }
          switch (trace) {
            case Trace.Verbose:
              return JSON.stringify(params, null, 4);
            case Trace.Compact:
              return JSON.stringify(params);
            default:
              return void 0;
          }
        }
        function traceSendingRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("send-request", message);
          }
        }
        function traceSendingNotification(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
          } else {
            logLSPMessage("send-notification", message);
          }
        }
        function traceSendingResponse(message, method, startTime) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
          } else {
            logLSPMessage("send-response", message);
          }
        }
        function traceReceivedRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("receive-request", message);
          }
        }
        function traceReceivedNotification(message) {
          if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
          } else {
            logLSPMessage("receive-notification", message);
          }
        }
        function traceReceivedResponse(message, responsePromise) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            if (responsePromise) {
              const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
              tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            } else {
              tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
          } else {
            logLSPMessage("receive-response", message);
          }
        }
        function logLSPMessage(type, message) {
          if (!tracer || trace === Trace.Off) {
            return;
          }
          const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
          };
          tracer.log(lspMessage);
        }
        function throwIfClosedOrDisposed() {
          if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
          }
          if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
          }
        }
        function throwIfListening() {
          if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
          }
        }
        function throwIfNotListening() {
          if (!isListening()) {
            throw new Error("Call listen() first.");
          }
        }
        function undefinedToNull(param) {
          if (param === void 0) {
            return null;
          } else {
            return param;
          }
        }
        function nullToUndefined(param) {
          if (param === null) {
            return void 0;
          } else {
            return param;
          }
        }
        function isNamedParam(param) {
          return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
        }
        function computeSingleParam(parameterStructures, param) {
          switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
              if (isNamedParam(param)) {
                return nullToUndefined(param);
              } else {
                return [undefinedToNull(param)];
              }
            case messages_1.ParameterStructures.byName:
              if (!isNamedParam(param)) {
                throw new Error(`Received parameters by name but param is not an object literal.`);
              }
              return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
              return [undefinedToNull(param)];
            default:
              throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
          }
        }
        function computeMessageParams(type, params) {
          let result;
          const numberOfParams = type.numberOfParams;
          switch (numberOfParams) {
            case 0:
              result = void 0;
              break;
            case 1:
              result = computeSingleParam(type.parameterStructures, params[0]);
              break;
            default:
              result = [];
              for (let i = 0; i < params.length && i < numberOfParams; i++) {
                result.push(undefinedToNull(params[i]));
              }
              if (params.length < numberOfParams) {
                for (let i = params.length; i < numberOfParams; i++) {
                  result.push(null);
                }
              }
              break;
          }
          return result;
        }
        const connection2 = {
          sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is3.string(type)) {
              method = type;
              const first2 = args[0];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first2)) {
                paramStart = 1;
                parameterStructures = first2;
              }
              let paramEnd = args.length;
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
              jsonrpc: version,
              method,
              params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter2.write(notificationMessage).catch((error) => {
              logger.error(`Sending notification failed.`);
              throw error;
            });
          },
          onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is3.func(type)) {
              starNotificationHandler = type;
            } else if (handler) {
              if (Is3.string(type)) {
                method = type;
                notificationHandlers.set(type, { type: void 0, handler });
              } else {
                method = type.method;
                notificationHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method !== void 0) {
                  notificationHandlers.delete(method);
                } else {
                  starNotificationHandler = void 0;
                }
              }
            };
          },
          onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
              throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
              dispose: () => {
                progressHandlers.delete(token);
              }
            };
          },
          sendProgress: (_type, token, value) => {
            return connection2.sendNotification(ProgressNotification.type, { token, value });
          },
          onUnhandledProgress: unhandledProgressEmitter.event,
          sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = void 0;
            if (Is3.string(type)) {
              method = type;
              const first2 = args[0];
              const last2 = args[args.length - 1];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first2)) {
                paramStart = 1;
                parameterStructures = first2;
              }
              let paramEnd = args.length;
              if (cancellation_1.CancellationToken.is(last2)) {
                paramEnd = paramEnd - 1;
                token = last2;
              }
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
              const numberOfParams = type.numberOfParams;
              token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
              disposable = token.onCancellationRequested(() => {
                const p = cancellationStrategy.sender.sendCancellation(connection2, id);
                if (p === void 0) {
                  logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                  return Promise.resolve();
                } else {
                  return p.catch(() => {
                    logger.log(`Sending cancellation messages for id ${id} failed`);
                  });
                }
              });
            }
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            traceSendingRequest(requestMessage);
            if (typeof cancellationStrategy.sender.enableCancellation === "function") {
              cancellationStrategy.sender.enableCancellation(requestMessage);
            }
            return new Promise(async (resolve, reject2) => {
              const resolveWithCleanup = (r) => {
                resolve(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const rejectWithCleanup = (r) => {
                reject2(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
              try {
                await messageWriter2.write(requestMessage);
                responsePromises.set(id, responsePromise);
              } catch (error) {
                logger.error(`Sending request failed.`);
                responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
                throw error;
              }
            });
          },
          onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
              method = void 0;
              starRequestHandler = type;
            } else if (Is3.string(type)) {
              method = null;
              if (handler !== void 0) {
                method = type;
                requestHandlers.set(type, { handler, type: void 0 });
              }
            } else {
              if (handler !== void 0) {
                method = type.method;
                requestHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method === null) {
                  return;
                }
                if (method !== void 0) {
                  requestHandlers.delete(method);
                } else {
                  starRequestHandler = void 0;
                }
              }
            };
          },
          hasPendingResponse: () => {
            return responsePromises.size > 0;
          },
          trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
              if (Is3.boolean(sendNotificationOrTraceOptions)) {
                _sendNotification = sendNotificationOrTraceOptions;
              } else {
                _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
              }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
              tracer = void 0;
            } else {
              tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
              await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
          },
          onError: errorEmitter.event,
          onClose: closeEmitter.event,
          onUnhandledNotification: unhandledNotificationEmitter.event,
          onDispose: disposeEmitter.event,
          end: () => {
            messageWriter2.end();
          },
          dispose: () => {
            if (isDisposed()) {
              return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(void 0);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
            for (const promise of responsePromises.values()) {
              promise.reject(error);
            }
            responsePromises = /* @__PURE__ */ new Map();
            requestTokens = /* @__PURE__ */ new Map();
            knownCanceledRequests = /* @__PURE__ */ new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            if (Is3.func(messageWriter2.dispose)) {
              messageWriter2.dispose();
            }
            if (Is3.func(messageReader2.dispose)) {
              messageReader2.dispose();
            }
          },
          listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader2.listen(callback);
          },
          inspect: () => {
            (0, ral_1.default)().console.log("inspect");
          }
        };
        connection2.onNotification(LogTraceNotification.type, (params) => {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          const verbose = trace === Trace.Verbose || trace === Trace.Compact;
          tracer.log(params.message, verbose ? params.verbose : void 0);
        });
        connection2.onNotification(ProgressNotification.type, (params) => {
          const handler = progressHandlers.get(params.token);
          if (handler) {
            handler(params.value);
          } else {
            unhandledProgressEmitter.fire(params);
          }
        });
        return connection2;
      }
      exports2.createMessageConnection = createMessageConnection;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/api.js
  var require_api = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
      exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
      var messages_1 = require_messages();
      Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
        return messages_1.Message;
      } });
      Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
        return messages_1.RequestType;
      } });
      Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
        return messages_1.RequestType0;
      } });
      Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
        return messages_1.RequestType1;
      } });
      Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
        return messages_1.RequestType2;
      } });
      Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
        return messages_1.RequestType3;
      } });
      Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
        return messages_1.RequestType4;
      } });
      Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
        return messages_1.RequestType5;
      } });
      Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
        return messages_1.RequestType6;
      } });
      Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
        return messages_1.RequestType7;
      } });
      Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
        return messages_1.RequestType8;
      } });
      Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
        return messages_1.RequestType9;
      } });
      Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
        return messages_1.ResponseError;
      } });
      Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
        return messages_1.ErrorCodes;
      } });
      Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
        return messages_1.NotificationType;
      } });
      Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
        return messages_1.NotificationType0;
      } });
      Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
        return messages_1.NotificationType1;
      } });
      Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
        return messages_1.NotificationType2;
      } });
      Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
        return messages_1.NotificationType3;
      } });
      Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
        return messages_1.NotificationType4;
      } });
      Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
        return messages_1.NotificationType5;
      } });
      Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
        return messages_1.NotificationType6;
      } });
      Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
        return messages_1.NotificationType7;
      } });
      Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
        return messages_1.NotificationType8;
      } });
      Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
        return messages_1.NotificationType9;
      } });
      Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
        return messages_1.ParameterStructures;
      } });
      var linkedMap_1 = require_linkedMap();
      Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
        return linkedMap_1.LinkedMap;
      } });
      Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
        return linkedMap_1.LRUCache;
      } });
      Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
        return linkedMap_1.Touch;
      } });
      var disposable_1 = require_disposable();
      Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
        return disposable_1.Disposable;
      } });
      var events_1 = require_events();
      Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
        return events_1.Event;
      } });
      Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
        return events_1.Emitter;
      } });
      var cancellation_1 = require_cancellation();
      Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
        return cancellation_1.CancellationTokenSource;
      } });
      Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
        return cancellation_1.CancellationToken;
      } });
      var sharedArrayCancellation_1 = require_sharedArrayCancellation();
      Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArraySenderStrategy;
      } });
      Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
      } });
      var messageReader_1 = require_messageReader();
      Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
        return messageReader_1.MessageReader;
      } });
      Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
        return messageReader_1.AbstractMessageReader;
      } });
      Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return messageReader_1.ReadableStreamMessageReader;
      } });
      var messageWriter_1 = require_messageWriter();
      Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.MessageWriter;
      } });
      Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.AbstractMessageWriter;
      } });
      Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.WriteableStreamMessageWriter;
      } });
      var messageBuffer_1 = require_messageBuffer();
      Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
        return messageBuffer_1.AbstractMessageBuffer;
      } });
      var connection_1 = require_connection();
      Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
        return connection_1.ConnectionStrategy;
      } });
      Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
        return connection_1.ConnectionOptions;
      } });
      Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
        return connection_1.NullLogger;
      } });
      Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
        return connection_1.createMessageConnection;
      } });
      Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
        return connection_1.ProgressToken;
      } });
      Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
        return connection_1.ProgressType;
      } });
      Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
        return connection_1.Trace;
      } });
      Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
        return connection_1.TraceValues;
      } });
      Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
        return connection_1.TraceFormat;
      } });
      Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
        return connection_1.SetTraceNotification;
      } });
      Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
        return connection_1.LogTraceNotification;
      } });
      Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
        return connection_1.ConnectionErrors;
      } });
      Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
        return connection_1.ConnectionError;
      } });
      Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationReceiverStrategy;
      } });
      Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationSenderStrategy;
      } });
      Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationStrategy;
      } });
      Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
        return connection_1.MessageStrategy;
      } });
      var ral_1 = require_ral();
      exports2.RAL = ral_1.default;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/browser/ril.js
  var require_ril = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var api_1 = require_api();
      var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
        constructor(encoding = "utf-8") {
          super(encoding);
          this.asciiDecoder = new TextDecoder("ascii");
        }
        emptyBuffer() {
          return _MessageBuffer.emptyBuffer;
        }
        fromString(value, _encoding) {
          return new TextEncoder().encode(value);
        }
        toString(value, encoding) {
          if (encoding === "ascii") {
            return this.asciiDecoder.decode(value);
          } else {
            return new TextDecoder(encoding).decode(value);
          }
        }
        asNative(buffer, length) {
          if (length === void 0) {
            return buffer;
          } else {
            return buffer.slice(0, length);
          }
        }
        allocNative(length) {
          return new Uint8Array(length);
        }
      };
      MessageBuffer.emptyBuffer = new Uint8Array(0);
      var ReadableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
              this._onData.fire(new Uint8Array(buffer));
            }, () => {
              (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
            });
          };
          this.socket.addEventListener("message", this._messageListener);
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        onData(listener) {
          return this._onData.event(listener);
        }
      };
      var WritableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        write(data, encoding) {
          if (typeof data === "string") {
            if (encoding !== void 0 && encoding !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
          } else {
            this.socket.send(data);
          }
          return Promise.resolve();
        }
        end() {
          this.socket.close();
        }
      };
      var _textEncoder = new TextEncoder();
      var _ril = Object.freeze({
        messageBuffer: Object.freeze({
          create: (encoding) => new MessageBuffer(encoding)
        }),
        applicationJson: Object.freeze({
          encoder: Object.freeze({
            name: "application/json",
            encode: (msg, options) => {
              if (options.charset !== "utf-8") {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
              }
              return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
            }
          }),
          decoder: Object.freeze({
            name: "application/json",
            decode: (buffer, options) => {
              if (!(buffer instanceof Uint8Array)) {
                throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
              }
              return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
          })
        }),
        stream: Object.freeze({
          asReadableStream: (socket) => new ReadableStreamWrapper(socket),
          asWritableStream: (socket) => new WritableStreamWrapper(socket)
        }),
        console,
        timer: Object.freeze({
          setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
          }
        })
      });
      function RIL() {
        return _ril;
      }
      (function(RIL2) {
        function install() {
          api_1.RAL.install(_ril);
        }
        RIL2.install = install;
      })(RIL || (RIL = {}));
      exports2.default = RIL;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/lib/browser/main.js
  var require_main = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createMessageConnection = exports2.BrowserMessageWriter = exports2.BrowserMessageReader = void 0;
      var ril_1 = require_ril();
      ril_1.default.install();
      var api_1 = require_api();
      __exportStar(require_api(), exports2);
      var BrowserMessageReader2 = class extends api_1.AbstractMessageReader {
        constructor(port) {
          super();
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            this._onData.fire(event.data);
          };
          port.addEventListener("error", (event) => this.fireError(event));
          port.onmessage = this._messageListener;
        }
        listen(callback) {
          return this._onData.event(callback);
        }
      };
      exports2.BrowserMessageReader = BrowserMessageReader2;
      var BrowserMessageWriter2 = class extends api_1.AbstractMessageWriter {
        constructor(port) {
          super();
          this.port = port;
          this.errorCount = 0;
          port.addEventListener("error", (event) => this.fireError(event));
        }
        write(msg) {
          try {
            this.port.postMessage(msg);
            return Promise.resolve();
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
        }
      };
      exports2.BrowserMessageWriter = BrowserMessageWriter2;
      function createMessageConnection(reader, writer, logger, options) {
        if (logger === void 0) {
          logger = api_1.NullLogger;
        }
        if (api_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, api_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports2.createMessageConnection = createMessageConnection;
    }
  });

  // ../node_modules/langium/node_modules/vscode-jsonrpc/browser.js
  var require_browser = __commonJS({
    "../node_modules/langium/node_modules/vscode-jsonrpc/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = require_main();
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/messages.js
  var require_messages2 = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
      var vscode_jsonrpc_1 = require_main();
      var MessageDirection;
      (function(MessageDirection2) {
        MessageDirection2["clientToServer"] = "clientToServer";
        MessageDirection2["serverToClient"] = "serverToClient";
        MessageDirection2["both"] = "both";
      })(MessageDirection || (exports2.MessageDirection = MessageDirection = {}));
      var RegistrationType = class {
        constructor(method) {
          this.method = method;
        }
      };
      exports2.RegistrationType = RegistrationType;
      var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
        constructor(method) {
          super(method);
        }
      };
      exports2.ProtocolRequestType0 = ProtocolRequestType0;
      var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports2.ProtocolRequestType = ProtocolRequestType;
      var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
        constructor(method) {
          super(method);
        }
      };
      exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
      var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports2.ProtocolNotificationType = ProtocolNotificationType;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
  var require_is2 = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports2.typedArray = typedArray;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      exports2.objectLiteral = objectLiteral;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
  var require_protocol_implementation = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ImplementationRequest = void 0;
      var messages_1 = require_messages2();
      var ImplementationRequest;
      (function(ImplementationRequest2) {
        ImplementationRequest2.method = "textDocument/implementation";
        ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
      })(ImplementationRequest || (exports2.ImplementationRequest = ImplementationRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
  var require_protocol_typeDefinition = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeDefinitionRequest = void 0;
      var messages_1 = require_messages2();
      var TypeDefinitionRequest;
      (function(TypeDefinitionRequest2) {
        TypeDefinitionRequest2.method = "textDocument/typeDefinition";
        TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
      })(TypeDefinitionRequest || (exports2.TypeDefinitionRequest = TypeDefinitionRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
  var require_protocol_workspaceFolder = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
      var messages_1 = require_messages2();
      var WorkspaceFoldersRequest;
      (function(WorkspaceFoldersRequest2) {
        WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
        WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
      })(WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
      var DidChangeWorkspaceFoldersNotification;
      (function(DidChangeWorkspaceFoldersNotification2) {
        DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
        DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
      })(DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
  var require_protocol_configuration = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConfigurationRequest = void 0;
      var messages_1 = require_messages2();
      var ConfigurationRequest;
      (function(ConfigurationRequest2) {
        ConfigurationRequest2.method = "workspace/configuration";
        ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
      })(ConfigurationRequest || (exports2.ConfigurationRequest = ConfigurationRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
  var require_protocol_colorProvider = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
      var messages_1 = require_messages2();
      var DocumentColorRequest;
      (function(DocumentColorRequest2) {
        DocumentColorRequest2.method = "textDocument/documentColor";
        DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
      })(DocumentColorRequest || (exports2.DocumentColorRequest = DocumentColorRequest = {}));
      var ColorPresentationRequest;
      (function(ColorPresentationRequest2) {
        ColorPresentationRequest2.method = "textDocument/colorPresentation";
        ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
      })(ColorPresentationRequest || (exports2.ColorPresentationRequest = ColorPresentationRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
  var require_protocol_foldingRange = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = void 0;
      var messages_1 = require_messages2();
      var FoldingRangeRequest;
      (function(FoldingRangeRequest2) {
        FoldingRangeRequest2.method = "textDocument/foldingRange";
        FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
      })(FoldingRangeRequest || (exports2.FoldingRangeRequest = FoldingRangeRequest = {}));
      var FoldingRangeRefreshRequest;
      (function(FoldingRangeRefreshRequest2) {
        FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
        FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
      })(FoldingRangeRefreshRequest || (exports2.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
  var require_protocol_declaration = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DeclarationRequest = void 0;
      var messages_1 = require_messages2();
      var DeclarationRequest;
      (function(DeclarationRequest2) {
        DeclarationRequest2.method = "textDocument/declaration";
        DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
      })(DeclarationRequest || (exports2.DeclarationRequest = DeclarationRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
  var require_protocol_selectionRange = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SelectionRangeRequest = void 0;
      var messages_1 = require_messages2();
      var SelectionRangeRequest;
      (function(SelectionRangeRequest2) {
        SelectionRangeRequest2.method = "textDocument/selectionRange";
        SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
      })(SelectionRangeRequest || (exports2.SelectionRangeRequest = SelectionRangeRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
  var require_protocol_progress = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
      var vscode_jsonrpc_1 = require_main();
      var messages_1 = require_messages2();
      var WorkDoneProgress;
      (function(WorkDoneProgress2) {
        WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
        function is(value) {
          return value === WorkDoneProgress2.type;
        }
        WorkDoneProgress2.is = is;
      })(WorkDoneProgress || (exports2.WorkDoneProgress = WorkDoneProgress = {}));
      var WorkDoneProgressCreateRequest;
      (function(WorkDoneProgressCreateRequest2) {
        WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
        WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
      })(WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
      var WorkDoneProgressCancelNotification;
      (function(WorkDoneProgressCancelNotification2) {
        WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
        WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
      })(WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
  var require_protocol_callHierarchy = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages2();
      var CallHierarchyPrepareRequest;
      (function(CallHierarchyPrepareRequest2) {
        CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
        CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
      })(CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
      var CallHierarchyIncomingCallsRequest;
      (function(CallHierarchyIncomingCallsRequest2) {
        CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
        CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
      })(CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
      var CallHierarchyOutgoingCallsRequest;
      (function(CallHierarchyOutgoingCallsRequest2) {
        CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
        CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
      })(CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
  var require_protocol_semanticTokens = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
      var messages_1 = require_messages2();
      var TokenFormat;
      (function(TokenFormat2) {
        TokenFormat2.Relative = "relative";
      })(TokenFormat || (exports2.TokenFormat = TokenFormat = {}));
      var SemanticTokensRegistrationType;
      (function(SemanticTokensRegistrationType2) {
        SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
        SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
      })(SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
      var SemanticTokensRequest;
      (function(SemanticTokensRequest2) {
        SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
        SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
        SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensRequest || (exports2.SemanticTokensRequest = SemanticTokensRequest = {}));
      var SemanticTokensDeltaRequest;
      (function(SemanticTokensDeltaRequest2) {
        SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
        SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
        SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
      var SemanticTokensRangeRequest;
      (function(SemanticTokensRangeRequest2) {
        SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
        SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
        SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
      var SemanticTokensRefreshRequest;
      (function(SemanticTokensRefreshRequest2) {
        SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
        SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
      })(SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
  var require_protocol_showDocument = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ShowDocumentRequest = void 0;
      var messages_1 = require_messages2();
      var ShowDocumentRequest;
      (function(ShowDocumentRequest2) {
        ShowDocumentRequest2.method = "window/showDocument";
        ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
      })(ShowDocumentRequest || (exports2.ShowDocumentRequest = ShowDocumentRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
  var require_protocol_linkedEditingRange = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LinkedEditingRangeRequest = void 0;
      var messages_1 = require_messages2();
      var LinkedEditingRangeRequest;
      (function(LinkedEditingRangeRequest2) {
        LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
        LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
      })(LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
  var require_protocol_fileOperations = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
      var messages_1 = require_messages2();
      var FileOperationPatternKind;
      (function(FileOperationPatternKind2) {
        FileOperationPatternKind2.file = "file";
        FileOperationPatternKind2.folder = "folder";
      })(FileOperationPatternKind || (exports2.FileOperationPatternKind = FileOperationPatternKind = {}));
      var WillCreateFilesRequest;
      (function(WillCreateFilesRequest2) {
        WillCreateFilesRequest2.method = "workspace/willCreateFiles";
        WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
      })(WillCreateFilesRequest || (exports2.WillCreateFilesRequest = WillCreateFilesRequest = {}));
      var DidCreateFilesNotification;
      (function(DidCreateFilesNotification2) {
        DidCreateFilesNotification2.method = "workspace/didCreateFiles";
        DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
      })(DidCreateFilesNotification || (exports2.DidCreateFilesNotification = DidCreateFilesNotification = {}));
      var WillRenameFilesRequest;
      (function(WillRenameFilesRequest2) {
        WillRenameFilesRequest2.method = "workspace/willRenameFiles";
        WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
      })(WillRenameFilesRequest || (exports2.WillRenameFilesRequest = WillRenameFilesRequest = {}));
      var DidRenameFilesNotification;
      (function(DidRenameFilesNotification2) {
        DidRenameFilesNotification2.method = "workspace/didRenameFiles";
        DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
      })(DidRenameFilesNotification || (exports2.DidRenameFilesNotification = DidRenameFilesNotification = {}));
      var DidDeleteFilesNotification;
      (function(DidDeleteFilesNotification2) {
        DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
        DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
      })(DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
      var WillDeleteFilesRequest;
      (function(WillDeleteFilesRequest2) {
        WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
        WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
      })(WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
  var require_protocol_moniker = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
      var messages_1 = require_messages2();
      var UniquenessLevel;
      (function(UniquenessLevel2) {
        UniquenessLevel2.document = "document";
        UniquenessLevel2.project = "project";
        UniquenessLevel2.group = "group";
        UniquenessLevel2.scheme = "scheme";
        UniquenessLevel2.global = "global";
      })(UniquenessLevel || (exports2.UniquenessLevel = UniquenessLevel = {}));
      var MonikerKind;
      (function(MonikerKind2) {
        MonikerKind2.$import = "import";
        MonikerKind2.$export = "export";
        MonikerKind2.local = "local";
      })(MonikerKind || (exports2.MonikerKind = MonikerKind = {}));
      var MonikerRequest;
      (function(MonikerRequest2) {
        MonikerRequest2.method = "textDocument/moniker";
        MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
      })(MonikerRequest || (exports2.MonikerRequest = MonikerRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
  var require_protocol_typeHierarchy = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages2();
      var TypeHierarchyPrepareRequest;
      (function(TypeHierarchyPrepareRequest2) {
        TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
        TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
      })(TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
      var TypeHierarchySupertypesRequest;
      (function(TypeHierarchySupertypesRequest2) {
        TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
        TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
      })(TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
      var TypeHierarchySubtypesRequest;
      (function(TypeHierarchySubtypesRequest2) {
        TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
        TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
      })(TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
  var require_protocol_inlineValue = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
      var messages_1 = require_messages2();
      var InlineValueRequest;
      (function(InlineValueRequest2) {
        InlineValueRequest2.method = "textDocument/inlineValue";
        InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
      })(InlineValueRequest || (exports2.InlineValueRequest = InlineValueRequest = {}));
      var InlineValueRefreshRequest;
      (function(InlineValueRefreshRequest2) {
        InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
        InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
      })(InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
  var require_protocol_inlayHint = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
      var messages_1 = require_messages2();
      var InlayHintRequest;
      (function(InlayHintRequest2) {
        InlayHintRequest2.method = "textDocument/inlayHint";
        InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
      })(InlayHintRequest || (exports2.InlayHintRequest = InlayHintRequest = {}));
      var InlayHintResolveRequest;
      (function(InlayHintResolveRequest2) {
        InlayHintResolveRequest2.method = "inlayHint/resolve";
        InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
      })(InlayHintResolveRequest || (exports2.InlayHintResolveRequest = InlayHintResolveRequest = {}));
      var InlayHintRefreshRequest;
      (function(InlayHintRefreshRequest2) {
        InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
        InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
      })(InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
  var require_protocol_diagnostic = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
      var vscode_jsonrpc_1 = require_main();
      var Is3 = require_is2();
      var messages_1 = require_messages2();
      var DiagnosticServerCancellationData;
      (function(DiagnosticServerCancellationData2) {
        function is(value) {
          const candidate = value;
          return candidate && Is3.boolean(candidate.retriggerRequest);
        }
        DiagnosticServerCancellationData2.is = is;
      })(DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
      var DocumentDiagnosticReportKind;
      (function(DocumentDiagnosticReportKind2) {
        DocumentDiagnosticReportKind2.Full = "full";
        DocumentDiagnosticReportKind2.Unchanged = "unchanged";
      })(DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
      var DocumentDiagnosticRequest;
      (function(DocumentDiagnosticRequest2) {
        DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
        DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
        DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
      var WorkspaceDiagnosticRequest;
      (function(WorkspaceDiagnosticRequest2) {
        WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
        WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
        WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
      var DiagnosticRefreshRequest;
      (function(DiagnosticRefreshRequest2) {
        DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
        DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
      })(DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
  var require_protocol_notebook = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
      var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
      var Is3 = require_is2();
      var messages_1 = require_messages2();
      var NotebookCellKind;
      (function(NotebookCellKind2) {
        NotebookCellKind2.Markup = 1;
        NotebookCellKind2.Code = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        NotebookCellKind2.is = is;
      })(NotebookCellKind || (exports2.NotebookCellKind = NotebookCellKind = {}));
      var ExecutionSummary;
      (function(ExecutionSummary2) {
        function create(executionOrder, success) {
          const result = { executionOrder };
          if (success === true || success === false) {
            result.success = success;
          }
          return result;
        }
        ExecutionSummary2.create = create;
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is3.boolean(candidate.success));
        }
        ExecutionSummary2.is = is;
        function equals(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          return one.executionOrder === other.executionOrder && one.success === other.success;
        }
        ExecutionSummary2.equals = equals;
      })(ExecutionSummary || (exports2.ExecutionSummary = ExecutionSummary = {}));
      var NotebookCell;
      (function(NotebookCell2) {
        function create(kind, document) {
          return { kind, document };
        }
        NotebookCell2.create = create;
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is3.objectLiteral(candidate.metadata));
        }
        NotebookCell2.is = is;
        function diff(one, two) {
          const result = /* @__PURE__ */ new Set();
          if (one.document !== two.document) {
            result.add("document");
          }
          if (one.kind !== two.kind) {
            result.add("kind");
          }
          if (one.executionSummary !== two.executionSummary) {
            result.add("executionSummary");
          }
          if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add("metadata");
          }
          if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add("executionSummary");
          }
          return result;
        }
        NotebookCell2.diff = diff;
        function equalsMetadata(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          if (typeof one !== typeof other) {
            return false;
          }
          if (typeof one !== "object") {
            return false;
          }
          const oneArray = Array.isArray(one);
          const otherArray = Array.isArray(other);
          if (oneArray !== otherArray) {
            return false;
          }
          if (oneArray && otherArray) {
            if (one.length !== other.length) {
              return false;
            }
            for (let i = 0; i < one.length; i++) {
              if (!equalsMetadata(one[i], other[i])) {
                return false;
              }
            }
          }
          if (Is3.objectLiteral(one) && Is3.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
              return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
              return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
              const prop = oneKeys[i];
              if (!equalsMetadata(one[prop], other[prop])) {
                return false;
              }
            }
          }
          return true;
        }
      })(NotebookCell || (exports2.NotebookCell = NotebookCell = {}));
      var NotebookDocument;
      (function(NotebookDocument2) {
        function create(uri, notebookType, version, cells) {
          return { uri, notebookType, version, cells };
        }
        NotebookDocument2.create = create;
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && Is3.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is3.typedArray(candidate.cells, NotebookCell.is);
        }
        NotebookDocument2.is = is;
      })(NotebookDocument || (exports2.NotebookDocument = NotebookDocument = {}));
      var NotebookDocumentSyncRegistrationType;
      (function(NotebookDocumentSyncRegistrationType2) {
        NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
        NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
        NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
      })(NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
      var DidOpenNotebookDocumentNotification;
      (function(DidOpenNotebookDocumentNotification2) {
        DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
        DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
        DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
      var NotebookCellArrayChange;
      (function(NotebookCellArrayChange2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is3.typedArray(candidate.cells, NotebookCell.is));
        }
        NotebookCellArrayChange2.is = is;
        function create(start, deleteCount, cells) {
          const result = { start, deleteCount };
          if (cells !== void 0) {
            result.cells = cells;
          }
          return result;
        }
        NotebookCellArrayChange2.create = create;
      })(NotebookCellArrayChange || (exports2.NotebookCellArrayChange = NotebookCellArrayChange = {}));
      var DidChangeNotebookDocumentNotification;
      (function(DidChangeNotebookDocumentNotification2) {
        DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
        DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
        DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
      var DidSaveNotebookDocumentNotification;
      (function(DidSaveNotebookDocumentNotification2) {
        DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
        DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
        DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
      var DidCloseNotebookDocumentNotification;
      (function(DidCloseNotebookDocumentNotification2) {
        DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
        DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
        DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
  var require_protocol_inlineCompletion = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineCompletionRequest = void 0;
      var messages_1 = require_messages2();
      var InlineCompletionRequest;
      (function(InlineCompletionRequest2) {
        InlineCompletionRequest2.method = "textDocument/inlineCompletion";
        InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
      })(InlineCompletionRequest || (exports2.InlineCompletionRequest = InlineCompletionRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.js
  var require_protocol = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
      exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangesFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
      exports2.InlineCompletionRequest = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages2();
      var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
      var Is3 = require_is2();
      var protocol_implementation_1 = require_protocol_implementation();
      Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
        return protocol_implementation_1.ImplementationRequest;
      } });
      var protocol_typeDefinition_1 = require_protocol_typeDefinition();
      Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
        return protocol_typeDefinition_1.TypeDefinitionRequest;
      } });
      var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
      Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
      } });
      Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
      } });
      var protocol_configuration_1 = require_protocol_configuration();
      Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
        return protocol_configuration_1.ConfigurationRequest;
      } });
      var protocol_colorProvider_1 = require_protocol_colorProvider();
      Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.DocumentColorRequest;
      } });
      Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.ColorPresentationRequest;
      } });
      var protocol_foldingRange_1 = require_protocol_foldingRange();
      Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
        return protocol_foldingRange_1.FoldingRangeRequest;
      } });
      Object.defineProperty(exports2, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
        return protocol_foldingRange_1.FoldingRangeRefreshRequest;
      } });
      var protocol_declaration_1 = require_protocol_declaration();
      Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
        return protocol_declaration_1.DeclarationRequest;
      } });
      var protocol_selectionRange_1 = require_protocol_selectionRange();
      Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
        return protocol_selectionRange_1.SelectionRangeRequest;
      } });
      var protocol_progress_1 = require_protocol_progress();
      Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgress;
      } });
      Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCreateRequest;
      } });
      Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCancelNotification;
      } });
      var protocol_callHierarchy_1 = require_protocol_callHierarchy();
      Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
      } });
      Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
      } });
      Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
      } });
      var protocol_semanticTokens_1 = require_protocol_semanticTokens();
      Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.TokenFormat;
      } });
      Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
      } });
      var protocol_showDocument_1 = require_protocol_showDocument();
      Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
        return protocol_showDocument_1.ShowDocumentRequest;
      } });
      var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
      Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
      } });
      var protocol_fileOperations_1 = require_protocol_fileOperations();
      Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
        return protocol_fileOperations_1.FileOperationPatternKind;
      } });
      Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidCreateFilesNotification;
      } });
      Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillCreateFilesRequest;
      } });
      Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidRenameFilesNotification;
      } });
      Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillRenameFilesRequest;
      } });
      Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidDeleteFilesNotification;
      } });
      Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillDeleteFilesRequest;
      } });
      var protocol_moniker_1 = require_protocol_moniker();
      Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
        return protocol_moniker_1.UniquenessLevel;
      } });
      Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerKind;
      } });
      Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerRequest;
      } });
      var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
      Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
      } });
      Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
      } });
      Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
      } });
      var protocol_inlineValue_1 = require_protocol_inlineValue();
      Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRequest;
      } });
      Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRefreshRequest;
      } });
      var protocol_inlayHint_1 = require_protocol_inlayHint();
      Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRequest;
      } });
      Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintResolveRequest;
      } });
      Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRefreshRequest;
      } });
      var protocol_diagnostic_1 = require_protocol_diagnostic();
      Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticServerCancellationData;
      } });
      Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
      } });
      Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticRequest;
      } });
      Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
      } });
      Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticRefreshRequest;
      } });
      var protocol_notebook_1 = require_protocol_notebook();
      Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellKind;
      } });
      Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
        return protocol_notebook_1.ExecutionSummary;
      } });
      Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCell;
      } });
      Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocument;
      } });
      Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
      } });
      Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellArrayChange;
      } });
      Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
      } });
      var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
      Object.defineProperty(exports2, "InlineCompletionRequest", { enumerable: true, get: function() {
        return protocol_inlineCompletion_1.InlineCompletionRequest;
      } });
      var TextDocumentFilter;
      (function(TextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is3.string(candidate) || (Is3.string(candidate.language) || Is3.string(candidate.scheme) || Is3.string(candidate.pattern));
        }
        TextDocumentFilter2.is = is;
      })(TextDocumentFilter || (exports2.TextDocumentFilter = TextDocumentFilter = {}));
      var NotebookDocumentFilter;
      (function(NotebookDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (Is3.string(candidate.notebookType) || Is3.string(candidate.scheme) || Is3.string(candidate.pattern));
        }
        NotebookDocumentFilter2.is = is;
      })(NotebookDocumentFilter || (exports2.NotebookDocumentFilter = NotebookDocumentFilter = {}));
      var NotebookCellTextDocumentFilter;
      (function(NotebookCellTextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (Is3.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is3.string(candidate.language));
        }
        NotebookCellTextDocumentFilter2.is = is;
      })(NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
      var DocumentSelector;
      (function(DocumentSelector2) {
        function is(value) {
          if (!Array.isArray(value)) {
            return false;
          }
          for (let elem of value) {
            if (!Is3.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
              return false;
            }
          }
          return true;
        }
        DocumentSelector2.is = is;
      })(DocumentSelector || (exports2.DocumentSelector = DocumentSelector = {}));
      var RegistrationRequest;
      (function(RegistrationRequest2) {
        RegistrationRequest2.method = "client/registerCapability";
        RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
      })(RegistrationRequest || (exports2.RegistrationRequest = RegistrationRequest = {}));
      var UnregistrationRequest;
      (function(UnregistrationRequest2) {
        UnregistrationRequest2.method = "client/unregisterCapability";
        UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
      })(UnregistrationRequest || (exports2.UnregistrationRequest = UnregistrationRequest = {}));
      var ResourceOperationKind;
      (function(ResourceOperationKind2) {
        ResourceOperationKind2.Create = "create";
        ResourceOperationKind2.Rename = "rename";
        ResourceOperationKind2.Delete = "delete";
      })(ResourceOperationKind || (exports2.ResourceOperationKind = ResourceOperationKind = {}));
      var FailureHandlingKind;
      (function(FailureHandlingKind2) {
        FailureHandlingKind2.Abort = "abort";
        FailureHandlingKind2.Transactional = "transactional";
        FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
        FailureHandlingKind2.Undo = "undo";
      })(FailureHandlingKind || (exports2.FailureHandlingKind = FailureHandlingKind = {}));
      var PositionEncodingKind;
      (function(PositionEncodingKind2) {
        PositionEncodingKind2.UTF8 = "utf-8";
        PositionEncodingKind2.UTF16 = "utf-16";
        PositionEncodingKind2.UTF32 = "utf-32";
      })(PositionEncodingKind || (exports2.PositionEncodingKind = PositionEncodingKind = {}));
      var StaticRegistrationOptions;
      (function(StaticRegistrationOptions2) {
        function hasId(value) {
          const candidate = value;
          return candidate && Is3.string(candidate.id) && candidate.id.length > 0;
        }
        StaticRegistrationOptions2.hasId = hasId;
      })(StaticRegistrationOptions || (exports2.StaticRegistrationOptions = StaticRegistrationOptions = {}));
      var TextDocumentRegistrationOptions;
      (function(TextDocumentRegistrationOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
        }
        TextDocumentRegistrationOptions2.is = is;
      })(TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
      var WorkDoneProgressOptions;
      (function(WorkDoneProgressOptions2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is3.boolean(candidate.workDoneProgress));
        }
        WorkDoneProgressOptions2.is = is;
        function hasWorkDoneProgress(value) {
          const candidate = value;
          return candidate && Is3.boolean(candidate.workDoneProgress);
        }
        WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
      })(WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
      var InitializeRequest;
      (function(InitializeRequest2) {
        InitializeRequest2.method = "initialize";
        InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
      })(InitializeRequest || (exports2.InitializeRequest = InitializeRequest = {}));
      var InitializeErrorCodes;
      (function(InitializeErrorCodes2) {
        InitializeErrorCodes2.unknownProtocolVersion = 1;
      })(InitializeErrorCodes || (exports2.InitializeErrorCodes = InitializeErrorCodes = {}));
      var InitializedNotification;
      (function(InitializedNotification2) {
        InitializedNotification2.method = "initialized";
        InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
      })(InitializedNotification || (exports2.InitializedNotification = InitializedNotification = {}));
      var ShutdownRequest;
      (function(ShutdownRequest2) {
        ShutdownRequest2.method = "shutdown";
        ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
      })(ShutdownRequest || (exports2.ShutdownRequest = ShutdownRequest = {}));
      var ExitNotification;
      (function(ExitNotification2) {
        ExitNotification2.method = "exit";
        ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
      })(ExitNotification || (exports2.ExitNotification = ExitNotification = {}));
      var DidChangeConfigurationNotification2;
      (function(DidChangeConfigurationNotification3) {
        DidChangeConfigurationNotification3.method = "workspace/didChangeConfiguration";
        DidChangeConfigurationNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeConfigurationNotification3.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification3.method);
      })(DidChangeConfigurationNotification2 || (exports2.DidChangeConfigurationNotification = DidChangeConfigurationNotification2 = {}));
      var MessageType;
      (function(MessageType2) {
        MessageType2.Error = 1;
        MessageType2.Warning = 2;
        MessageType2.Info = 3;
        MessageType2.Log = 4;
        MessageType2.Debug = 5;
      })(MessageType || (exports2.MessageType = MessageType = {}));
      var ShowMessageNotification;
      (function(ShowMessageNotification2) {
        ShowMessageNotification2.method = "window/showMessage";
        ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
      })(ShowMessageNotification || (exports2.ShowMessageNotification = ShowMessageNotification = {}));
      var ShowMessageRequest;
      (function(ShowMessageRequest2) {
        ShowMessageRequest2.method = "window/showMessageRequest";
        ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
      })(ShowMessageRequest || (exports2.ShowMessageRequest = ShowMessageRequest = {}));
      var LogMessageNotification;
      (function(LogMessageNotification2) {
        LogMessageNotification2.method = "window/logMessage";
        LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
      })(LogMessageNotification || (exports2.LogMessageNotification = LogMessageNotification = {}));
      var TelemetryEventNotification;
      (function(TelemetryEventNotification2) {
        TelemetryEventNotification2.method = "telemetry/event";
        TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
      })(TelemetryEventNotification || (exports2.TelemetryEventNotification = TelemetryEventNotification = {}));
      var TextDocumentSyncKind2;
      (function(TextDocumentSyncKind3) {
        TextDocumentSyncKind3.None = 0;
        TextDocumentSyncKind3.Full = 1;
        TextDocumentSyncKind3.Incremental = 2;
      })(TextDocumentSyncKind2 || (exports2.TextDocumentSyncKind = TextDocumentSyncKind2 = {}));
      var DidOpenTextDocumentNotification;
      (function(DidOpenTextDocumentNotification2) {
        DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
        DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
      })(DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
      var TextDocumentContentChangeEvent;
      (function(TextDocumentContentChangeEvent2) {
        function isIncremental(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
        }
        TextDocumentContentChangeEvent2.isIncremental = isIncremental;
        function isFull(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
        }
        TextDocumentContentChangeEvent2.isFull = isFull;
      })(TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
      var DidChangeTextDocumentNotification;
      (function(DidChangeTextDocumentNotification2) {
        DidChangeTextDocumentNotification2.method = "textDocument/didChange";
        DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
      })(DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
      var DidCloseTextDocumentNotification;
      (function(DidCloseTextDocumentNotification2) {
        DidCloseTextDocumentNotification2.method = "textDocument/didClose";
        DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
      })(DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
      var DidSaveTextDocumentNotification;
      (function(DidSaveTextDocumentNotification2) {
        DidSaveTextDocumentNotification2.method = "textDocument/didSave";
        DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
      })(DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
      var TextDocumentSaveReason;
      (function(TextDocumentSaveReason2) {
        TextDocumentSaveReason2.Manual = 1;
        TextDocumentSaveReason2.AfterDelay = 2;
        TextDocumentSaveReason2.FocusOut = 3;
      })(TextDocumentSaveReason || (exports2.TextDocumentSaveReason = TextDocumentSaveReason = {}));
      var WillSaveTextDocumentNotification;
      (function(WillSaveTextDocumentNotification2) {
        WillSaveTextDocumentNotification2.method = "textDocument/willSave";
        WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
      })(WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
      var WillSaveTextDocumentWaitUntilRequest;
      (function(WillSaveTextDocumentWaitUntilRequest2) {
        WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
        WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
      })(WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
      var DidChangeWatchedFilesNotification2;
      (function(DidChangeWatchedFilesNotification3) {
        DidChangeWatchedFilesNotification3.method = "workspace/didChangeWatchedFiles";
        DidChangeWatchedFilesNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeWatchedFilesNotification3.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification3.method);
      })(DidChangeWatchedFilesNotification2 || (exports2.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification2 = {}));
      var FileChangeType2;
      (function(FileChangeType3) {
        FileChangeType3.Created = 1;
        FileChangeType3.Changed = 2;
        FileChangeType3.Deleted = 3;
      })(FileChangeType2 || (exports2.FileChangeType = FileChangeType2 = {}));
      var RelativePattern;
      (function(RelativePattern2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is3.string(candidate.pattern);
        }
        RelativePattern2.is = is;
      })(RelativePattern || (exports2.RelativePattern = RelativePattern = {}));
      var WatchKind;
      (function(WatchKind2) {
        WatchKind2.Create = 1;
        WatchKind2.Change = 2;
        WatchKind2.Delete = 4;
      })(WatchKind || (exports2.WatchKind = WatchKind = {}));
      var PublishDiagnosticsNotification;
      (function(PublishDiagnosticsNotification2) {
        PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
        PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
      })(PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
      var CompletionTriggerKind;
      (function(CompletionTriggerKind2) {
        CompletionTriggerKind2.Invoked = 1;
        CompletionTriggerKind2.TriggerCharacter = 2;
        CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
      })(CompletionTriggerKind || (exports2.CompletionTriggerKind = CompletionTriggerKind = {}));
      var CompletionRequest;
      (function(CompletionRequest2) {
        CompletionRequest2.method = "textDocument/completion";
        CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
      })(CompletionRequest || (exports2.CompletionRequest = CompletionRequest = {}));
      var CompletionResolveRequest;
      (function(CompletionResolveRequest2) {
        CompletionResolveRequest2.method = "completionItem/resolve";
        CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
      })(CompletionResolveRequest || (exports2.CompletionResolveRequest = CompletionResolveRequest = {}));
      var HoverRequest;
      (function(HoverRequest2) {
        HoverRequest2.method = "textDocument/hover";
        HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
      })(HoverRequest || (exports2.HoverRequest = HoverRequest = {}));
      var SignatureHelpTriggerKind;
      (function(SignatureHelpTriggerKind2) {
        SignatureHelpTriggerKind2.Invoked = 1;
        SignatureHelpTriggerKind2.TriggerCharacter = 2;
        SignatureHelpTriggerKind2.ContentChange = 3;
      })(SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
      var SignatureHelpRequest;
      (function(SignatureHelpRequest2) {
        SignatureHelpRequest2.method = "textDocument/signatureHelp";
        SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
      })(SignatureHelpRequest || (exports2.SignatureHelpRequest = SignatureHelpRequest = {}));
      var DefinitionRequest;
      (function(DefinitionRequest2) {
        DefinitionRequest2.method = "textDocument/definition";
        DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
      })(DefinitionRequest || (exports2.DefinitionRequest = DefinitionRequest = {}));
      var ReferencesRequest;
      (function(ReferencesRequest2) {
        ReferencesRequest2.method = "textDocument/references";
        ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
      })(ReferencesRequest || (exports2.ReferencesRequest = ReferencesRequest = {}));
      var DocumentHighlightRequest;
      (function(DocumentHighlightRequest2) {
        DocumentHighlightRequest2.method = "textDocument/documentHighlight";
        DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
      })(DocumentHighlightRequest || (exports2.DocumentHighlightRequest = DocumentHighlightRequest = {}));
      var DocumentSymbolRequest;
      (function(DocumentSymbolRequest2) {
        DocumentSymbolRequest2.method = "textDocument/documentSymbol";
        DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
      })(DocumentSymbolRequest || (exports2.DocumentSymbolRequest = DocumentSymbolRequest = {}));
      var CodeActionRequest;
      (function(CodeActionRequest2) {
        CodeActionRequest2.method = "textDocument/codeAction";
        CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
      })(CodeActionRequest || (exports2.CodeActionRequest = CodeActionRequest = {}));
      var CodeActionResolveRequest;
      (function(CodeActionResolveRequest2) {
        CodeActionResolveRequest2.method = "codeAction/resolve";
        CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
      })(CodeActionResolveRequest || (exports2.CodeActionResolveRequest = CodeActionResolveRequest = {}));
      var WorkspaceSymbolRequest;
      (function(WorkspaceSymbolRequest2) {
        WorkspaceSymbolRequest2.method = "workspace/symbol";
        WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
      })(WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
      var WorkspaceSymbolResolveRequest;
      (function(WorkspaceSymbolResolveRequest2) {
        WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
        WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
      })(WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
      var CodeLensRequest;
      (function(CodeLensRequest2) {
        CodeLensRequest2.method = "textDocument/codeLens";
        CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
      })(CodeLensRequest || (exports2.CodeLensRequest = CodeLensRequest = {}));
      var CodeLensResolveRequest;
      (function(CodeLensResolveRequest2) {
        CodeLensResolveRequest2.method = "codeLens/resolve";
        CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
      })(CodeLensResolveRequest || (exports2.CodeLensResolveRequest = CodeLensResolveRequest = {}));
      var CodeLensRefreshRequest;
      (function(CodeLensRefreshRequest2) {
        CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
        CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
      })(CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
      var DocumentLinkRequest;
      (function(DocumentLinkRequest2) {
        DocumentLinkRequest2.method = "textDocument/documentLink";
        DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
      })(DocumentLinkRequest || (exports2.DocumentLinkRequest = DocumentLinkRequest = {}));
      var DocumentLinkResolveRequest;
      (function(DocumentLinkResolveRequest2) {
        DocumentLinkResolveRequest2.method = "documentLink/resolve";
        DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
      })(DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
      var DocumentFormattingRequest;
      (function(DocumentFormattingRequest2) {
        DocumentFormattingRequest2.method = "textDocument/formatting";
        DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
      })(DocumentFormattingRequest || (exports2.DocumentFormattingRequest = DocumentFormattingRequest = {}));
      var DocumentRangeFormattingRequest;
      (function(DocumentRangeFormattingRequest2) {
        DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
        DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
      })(DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
      var DocumentRangesFormattingRequest;
      (function(DocumentRangesFormattingRequest2) {
        DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
        DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
      })(DocumentRangesFormattingRequest || (exports2.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
      var DocumentOnTypeFormattingRequest;
      (function(DocumentOnTypeFormattingRequest2) {
        DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
        DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
      })(DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
      var PrepareSupportDefaultBehavior;
      (function(PrepareSupportDefaultBehavior2) {
        PrepareSupportDefaultBehavior2.Identifier = 1;
      })(PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
      var RenameRequest;
      (function(RenameRequest2) {
        RenameRequest2.method = "textDocument/rename";
        RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
      })(RenameRequest || (exports2.RenameRequest = RenameRequest = {}));
      var PrepareRenameRequest;
      (function(PrepareRenameRequest2) {
        PrepareRenameRequest2.method = "textDocument/prepareRename";
        PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
      })(PrepareRenameRequest || (exports2.PrepareRenameRequest = PrepareRenameRequest = {}));
      var ExecuteCommandRequest;
      (function(ExecuteCommandRequest2) {
        ExecuteCommandRequest2.method = "workspace/executeCommand";
        ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
      })(ExecuteCommandRequest || (exports2.ExecuteCommandRequest = ExecuteCommandRequest = {}));
      var ApplyWorkspaceEditRequest;
      (function(ApplyWorkspaceEditRequest2) {
        ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
        ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
      })(ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/connection.js
  var require_connection2 = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createProtocolConnection = void 0;
      var vscode_jsonrpc_1 = require_main();
      function createProtocolConnection(input, output, logger, options) {
        if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
      }
      exports2.createProtocolConnection = createProtocolConnection;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/api.js
  var require_api2 = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
      __exportStar(require_main(), exports2);
      __exportStar((init_main(), __toCommonJS(main_exports)), exports2);
      __exportStar(require_messages2(), exports2);
      __exportStar(require_protocol(), exports2);
      var connection_1 = require_connection2();
      Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
        return connection_1.createProtocolConnection;
      } });
      var LSPErrorCodes2;
      (function(LSPErrorCodes3) {
        LSPErrorCodes3.lspReservedErrorRangeStart = -32899;
        LSPErrorCodes3.RequestFailed = -32803;
        LSPErrorCodes3.ServerCancelled = -32802;
        LSPErrorCodes3.ContentModified = -32801;
        LSPErrorCodes3.RequestCancelled = -32800;
        LSPErrorCodes3.lspReservedErrorRangeEnd = -32800;
      })(LSPErrorCodes2 || (exports2.LSPErrorCodes = LSPErrorCodes2 = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/browser/main.js
  var require_main2 = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createProtocolConnection = void 0;
      var browser_1 = require_browser();
      __exportStar(require_browser(), exports2);
      __exportStar(require_api2(), exports2);
      function createProtocolConnection(reader, writer, logger, options) {
        return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports2.createProtocolConnection = createProtocolConnection;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/semanticTokens.js
  var require_semanticTokens = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var SemanticTokensFeature = (Base) => {
        return class extends Base {
          get semanticTokens() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
              },
              on: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onDelta: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onRange: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.SemanticTokensFeature = SemanticTokensFeature;
      var SemanticTokensDiff = class {
        constructor(originalSequence, modifiedSequence) {
          this.originalSequence = originalSequence;
          this.modifiedSequence = modifiedSequence;
        }
        computeDiff() {
          const originalLength = this.originalSequence.length;
          const modifiedLength = this.modifiedSequence.length;
          let startIndex = 0;
          while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
            startIndex++;
          }
          if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
              originalEndIndex--;
              modifiedEndIndex--;
            }
            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
              originalEndIndex++;
              modifiedEndIndex++;
            }
            const deleteCount = originalEndIndex - startIndex + 1;
            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
              return [
                { start: startIndex, deleteCount: deleteCount - 1 }
              ];
            } else {
              return [
                { start: startIndex, deleteCount, data: newData }
              ];
            }
          } else if (startIndex < modifiedLength) {
            return [
              { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
            ];
          } else if (startIndex < originalLength) {
            return [
              { start: startIndex, deleteCount: originalLength - startIndex }
            ];
          } else {
            return [];
          }
        }
      };
      exports2.SemanticTokensDiff = SemanticTokensDiff;
      var SemanticTokensBuilder2 = class {
        constructor() {
          this._prevData = void 0;
          this.initialize();
        }
        initialize() {
          this._id = Date.now();
          this._prevLine = 0;
          this._prevChar = 0;
          this._data = [];
          this._dataLen = 0;
        }
        push(line, char, length, tokenType, tokenModifiers) {
          let pushLine = line;
          let pushChar = char;
          if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
              pushChar -= this._prevChar;
            }
          }
          this._data[this._dataLen++] = pushLine;
          this._data[this._dataLen++] = pushChar;
          this._data[this._dataLen++] = length;
          this._data[this._dataLen++] = tokenType;
          this._data[this._dataLen++] = tokenModifiers;
          this._prevLine = line;
          this._prevChar = char;
        }
        get id() {
          return this._id.toString();
        }
        previousResult(id) {
          if (this.id === id) {
            this._prevData = this._data;
          }
          this.initialize();
        }
        build() {
          this._prevData = void 0;
          return {
            resultId: this.id,
            data: this._data
          };
        }
        canBuildEdits() {
          return this._prevData !== void 0;
        }
        buildEdits() {
          if (this._prevData !== void 0) {
            return {
              resultId: this.id,
              edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
            };
          } else {
            return this.build();
          }
        }
      };
      exports2.SemanticTokensBuilder = SemanticTokensBuilder2;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
  var require_inlineCompletion_proposed = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineCompletionFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var InlineCompletionFeature = (Base) => {
        return class extends Base {
          get inlineCompletion() {
            return {
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params));
                });
              }
            };
          }
        };
      };
      exports2.InlineCompletionFeature = InlineCompletionFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/textDocuments.js
  var require_textDocuments = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TextDocuments = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var TextDocuments2 = class {
        /**
         * Create a new text document manager.
         */
        constructor(configuration) {
          this._configuration = configuration;
          this._syncedDocuments = /* @__PURE__ */ new Map();
          this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
          this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
          this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
          this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
          this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been opened.
         */
        get onDidOpen() {
          return this._onDidOpen.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been opened or the content changes.
         */
        get onDidChangeContent() {
          return this._onDidChangeContent.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * will be saved.
         */
        get onWillSave() {
          return this._onWillSave.event;
        }
        /**
         * Sets a handler that will be called if a participant wants to provide
         * edits during a text document save.
         */
        onWillSaveWaitUntil(handler) {
          this._willSaveWaitUntil = handler;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been saved.
         */
        get onDidSave() {
          return this._onDidSave.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been closed.
         */
        get onDidClose() {
          return this._onDidClose.event;
        }
        /**
         * Returns the document for the given URI. Returns undefined if
         * the document is not managed by this instance.
         *
         * @param uri The text document's URI to retrieve.
         * @return the text document or `undefined`.
         */
        get(uri) {
          return this._syncedDocuments.get(uri);
        }
        /**
         * Returns all text documents managed by this instance.
         *
         * @return all text documents.
         */
        all() {
          return Array.from(this._syncedDocuments.values());
        }
        /**
         * Returns the URIs of all text documents managed by this instance.
         *
         * @return the URI's of all text documents.
         */
        keys() {
          return Array.from(this._syncedDocuments.keys());
        }
        /**
         * Listens for `low level` notification on the given connection to
         * update the text documents managed by this instance.
         *
         * Please note that the connection only provides handlers not an event model. Therefore
         * listening on a connection will overwrite the following handlers on a connection:
         * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
         * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
         *
         * Use the corresponding events on the TextDocuments instance instead.
         *
         * @param connection The connection to listen on.
         */
        listen(connection2) {
          connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
          const disposables = [];
          disposables.push(connection2.onDidOpenTextDocument((event) => {
            const td = event.textDocument;
            const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
            this._syncedDocuments.set(td.uri, document);
            const toFire = Object.freeze({ document });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
          }));
          disposables.push(connection2.onDidChangeTextDocument((event) => {
            const td = event.textDocument;
            const changes = event.contentChanges;
            if (changes.length === 0) {
              return;
            }
            const { version } = td;
            if (version === null || version === void 0) {
              throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
            }
            let syncedDocument = this._syncedDocuments.get(td.uri);
            if (syncedDocument !== void 0) {
              syncedDocument = this._configuration.update(syncedDocument, changes, version);
              this._syncedDocuments.set(td.uri, syncedDocument);
              this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          disposables.push(connection2.onDidCloseTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._syncedDocuments.delete(event.textDocument.uri);
              this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          disposables.push(connection2.onWillSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
            }
          }));
          disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
              return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
            } else {
              return [];
            }
          }));
          disposables.push(connection2.onDidSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            disposables.forEach((disposable) => disposable.dispose());
          });
        }
      };
      exports2.TextDocuments = TextDocuments2;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/notebook.js
  var require_notebook = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var textDocuments_1 = require_textDocuments();
      var NotebookSyncFeature = (Base) => {
        return class extends Base {
          get synchronization() {
            return {
              onDidOpenNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidChangeNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidSaveNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidCloseNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              }
            };
          }
        };
      };
      exports2.NotebookSyncFeature = NotebookSyncFeature;
      var CellTextDocumentConnection = class _CellTextDocumentConnection {
        onDidOpenTextDocument(handler) {
          this.openHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.openHandler = void 0;
          });
        }
        openTextDocument(params) {
          this.openHandler && this.openHandler(params);
        }
        onDidChangeTextDocument(handler) {
          this.changeHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.changeHandler = handler;
          });
        }
        changeTextDocument(params) {
          this.changeHandler && this.changeHandler(params);
        }
        onDidCloseTextDocument(handler) {
          this.closeHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.closeHandler = void 0;
          });
        }
        closeTextDocument(params) {
          this.closeHandler && this.closeHandler(params);
        }
        onWillSaveTextDocument() {
          return _CellTextDocumentConnection.NULL_DISPOSE;
        }
        onWillSaveTextDocumentWaitUntil() {
          return _CellTextDocumentConnection.NULL_DISPOSE;
        }
        onDidSaveTextDocument() {
          return _CellTextDocumentConnection.NULL_DISPOSE;
        }
      };
      CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
      } });
      var NotebookDocuments = class {
        constructor(configurationOrTextDocuments) {
          if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
            this._cellTextDocuments = configurationOrTextDocuments;
          } else {
            this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
          }
          this.notebookDocuments = /* @__PURE__ */ new Map();
          this.notebookCellMap = /* @__PURE__ */ new Map();
          this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
          this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
          this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
          this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        }
        get cellTextDocuments() {
          return this._cellTextDocuments;
        }
        getCellTextDocument(cell) {
          return this._cellTextDocuments.get(cell.document);
        }
        getNotebookDocument(uri) {
          return this.notebookDocuments.get(uri);
        }
        getNotebookCell(uri) {
          const value = this.notebookCellMap.get(uri);
          return value && value[0];
        }
        findNotebookDocumentForCell(cell) {
          const key = typeof cell === "string" ? cell : cell.document;
          const value = this.notebookCellMap.get(key);
          return value && value[1];
        }
        get onDidOpen() {
          return this._onDidOpen.event;
        }
        get onDidSave() {
          return this._onDidSave.event;
        }
        get onDidChange() {
          return this._onDidChange.event;
        }
        get onDidClose() {
          return this._onDidClose.event;
        }
        /**
         * Listens for `low level` notification on the given connection to
         * update the notebook documents managed by this instance.
         *
         * Please note that the connection only provides handlers not an event model. Therefore
         * listening on a connection will overwrite the following handlers on a connection:
         * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
         *  and `onDidCloseNotebookDocument`.
         *
         * @param connection The connection to listen on.
         */
        listen(connection2) {
          const cellTextDocumentConnection = new CellTextDocumentConnection();
          const disposables = [];
          disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
          disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
            this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
              cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
            }
            this.updateCellMap(params.notebookDocument);
            this._onDidOpen.fire(params.notebookDocument);
          }));
          disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            notebookDocument.version = params.notebookDocument.version;
            const oldMetadata = notebookDocument.metadata;
            let metadataChanged = false;
            const change = params.change;
            if (change.metadata !== void 0) {
              metadataChanged = true;
              notebookDocument.metadata = change.metadata;
            }
            const opened = [];
            const closed = [];
            const data = [];
            const text = [];
            if (change.cells !== void 0) {
              const changedCells = change.cells;
              if (changedCells.structure !== void 0) {
                const array = changedCells.structure.array;
                notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
                if (changedCells.structure.didOpen !== void 0) {
                  for (const open of changedCells.structure.didOpen) {
                    cellTextDocumentConnection.openTextDocument({ textDocument: open });
                    opened.push(open.uri);
                  }
                }
                if (changedCells.structure.didClose) {
                  for (const close of changedCells.structure.didClose) {
                    cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                    closed.push(close.uri);
                  }
                }
              }
              if (changedCells.data !== void 0) {
                const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
                for (let i = 0; i <= notebookDocument.cells.length; i++) {
                  const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                  if (change2 !== void 0) {
                    const old = notebookDocument.cells.splice(i, 1, change2);
                    data.push({ old: old[0], new: change2 });
                    cellUpdates.delete(change2.document);
                    if (cellUpdates.size === 0) {
                      break;
                    }
                  }
                }
              }
              if (changedCells.textContent !== void 0) {
                for (const cellTextDocument of changedCells.textContent) {
                  cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                  text.push(cellTextDocument.document.uri);
                }
              }
            }
            this.updateCellMap(notebookDocument);
            const changeEvent = { notebookDocument };
            if (metadataChanged) {
              changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
            }
            const added = [];
            for (const open of opened) {
              added.push(this.getNotebookCell(open));
            }
            const removed = [];
            for (const close of closed) {
              removed.push(this.getNotebookCell(close));
            }
            const textContent = [];
            for (const change2 of text) {
              textContent.push(this.getNotebookCell(change2));
            }
            if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
              changeEvent.cells = { added, removed, changed: { data, textContent } };
            }
            if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
              this._onDidChange.fire(changeEvent);
            }
          }));
          disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            this._onDidSave.fire(notebookDocument);
          }));
          disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            this._onDidClose.fire(notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
              cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
            }
            this.notebookDocuments.delete(params.notebookDocument.uri);
            for (const cell of notebookDocument.cells) {
              this.notebookCellMap.delete(cell.document);
            }
          }));
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            disposables.forEach((disposable) => disposable.dispose());
          });
        }
        updateCellMap(notebookDocument) {
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
          }
        }
      };
      exports2.NotebookDocuments = NotebookDocuments;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/utils/is.js
  var require_is3 = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports2.typedArray = typedArray;
      function thenable(value) {
        return value && func(value.then);
      }
      exports2.thenable = thenable;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/utils/uuid.js
  var require_uuid = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
      var ValueUUID = class {
        constructor(_value) {
          this._value = _value;
        }
        asHex() {
          return this._value;
        }
        equals(other) {
          return this.asHex() === other.asHex();
        }
      };
      var V4UUID = class _V4UUID extends ValueUUID {
        static _oneOf(array) {
          return array[Math.floor(array.length * Math.random())];
        }
        static _randomHex() {
          return _V4UUID._oneOf(_V4UUID._chars);
        }
        constructor() {
          super([
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            "4",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._oneOf(_V4UUID._timeHighBits),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex()
          ].join(""));
        }
      };
      V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      V4UUID._timeHighBits = ["8", "9", "a", "b"];
      exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
      function v4() {
        return new V4UUID();
      }
      exports2.v4 = v4;
      var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      function isUUID(value) {
        return _UUIDPattern.test(value);
      }
      exports2.isUUID = isUUID;
      function parse(value) {
        if (!isUUID(value)) {
          throw new Error("invalid uuid");
        }
        return new ValueUUID(value);
      }
      exports2.parse = parse;
      function generateUuid() {
        return v4().asHex();
      }
      exports2.generateUuid = generateUuid;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/progress.js
  var require_progress = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var uuid_1 = require_uuid();
      var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
        constructor(_connection, _token) {
          this._connection = _connection;
          this._token = _token;
          _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
        }
        begin(title, percentage, message, cancellable) {
          let param = {
            kind: "begin",
            title,
            percentage,
            message,
            cancellable
          };
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
        }
        report(arg0, arg1) {
          let param = {
            kind: "report"
          };
          if (typeof arg0 === "number") {
            param.percentage = arg0;
            if (arg1 !== void 0) {
              param.message = arg1;
            }
          } else {
            param.message = arg0;
          }
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
        }
        done() {
          _WorkDoneProgressReporterImpl.Instances.delete(this._token);
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
        }
      };
      WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
      var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
        constructor(connection2, token) {
          super(connection2, token);
          this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        }
        get token() {
          return this._source.token;
        }
        done() {
          this._source.dispose();
          super.done();
        }
        cancel() {
          this._source.cancel();
        }
      };
      var NullProgressReporter = class {
        constructor() {
        }
        begin() {
        }
        report() {
        }
        done() {
        }
      };
      var NullProgressServerReporter = class extends NullProgressReporter {
        constructor() {
          super();
          this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        }
        get token() {
          return this._source.token;
        }
        done() {
          this._source.dispose();
        }
        cancel() {
          this._source.cancel();
        }
      };
      function attachWorkDone(connection2, params) {
        if (params === void 0 || params.workDoneToken === void 0) {
          return new NullProgressReporter();
        }
        const token = params.workDoneToken;
        delete params.workDoneToken;
        return new WorkDoneProgressReporterImpl(connection2, token);
      }
      exports2.attachWorkDone = attachWorkDone;
      var ProgressFeature = (Base) => {
        return class extends Base {
          constructor() {
            super();
            this._progressSupported = false;
          }
          initialize(capabilities) {
            super.initialize(capabilities);
            if (capabilities?.window?.workDoneProgress === true) {
              this._progressSupported = true;
              this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
                let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
                if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                  progress.cancel();
                }
              });
            }
          }
          attachWorkDoneProgress(token) {
            if (token === void 0) {
              return new NullProgressReporter();
            } else {
              return new WorkDoneProgressReporterImpl(this.connection, token);
            }
          }
          createWorkDoneProgress() {
            if (this._progressSupported) {
              const token = (0, uuid_1.generateUuid)();
              return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
                return result;
              });
            } else {
              return Promise.resolve(new NullProgressServerReporter());
            }
          }
        };
      };
      exports2.ProgressFeature = ProgressFeature;
      var ResultProgress;
      (function(ResultProgress2) {
        ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
      })(ResultProgress || (ResultProgress = {}));
      var ResultProgressReporterImpl = class {
        constructor(_connection, _token) {
          this._connection = _connection;
          this._token = _token;
        }
        report(data) {
          this._connection.sendProgress(ResultProgress.type, this._token, data);
        }
      };
      function attachPartialResult(connection2, params) {
        if (params === void 0 || params.partialResultToken === void 0) {
          return void 0;
        }
        const token = params.partialResultToken;
        delete params.partialResultToken;
        return new ResultProgressReporterImpl(connection2, token);
      }
      exports2.attachPartialResult = attachPartialResult;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/configuration.js
  var require_configuration = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConfigurationFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var Is3 = require_is3();
      var ConfigurationFeature = (Base) => {
        return class extends Base {
          getConfiguration(arg) {
            if (!arg) {
              return this._getConfiguration({});
            } else if (Is3.string(arg)) {
              return this._getConfiguration({ section: arg });
            } else {
              return this._getConfiguration(arg);
            }
          }
          _getConfiguration(arg) {
            let params = {
              items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
              if (Array.isArray(result)) {
                return Array.isArray(arg) ? result : result[0];
              } else {
                return Array.isArray(arg) ? [] : null;
              }
            });
          }
        };
      };
      exports2.ConfigurationFeature = ConfigurationFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/workspaceFolder.js
  var require_workspaceFolder = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkspaceFoldersFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var WorkspaceFoldersFeature = (Base) => {
        return class extends Base {
          constructor() {
            super();
            this._notificationIsAutoRegistered = false;
          }
          initialize(capabilities) {
            super.initialize(capabilities);
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
              this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
              this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
                this._onDidChangeWorkspaceFolders.fire(params.event);
              });
            }
          }
          fillServerCapabilities(capabilities) {
            super.fillServerCapabilities(capabilities);
            const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
          }
          getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
          }
          get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
              throw new Error("Client doesn't support sending workspace folder change events.");
            }
            if (!this._notificationIsAutoRegistered && !this._unregistration) {
              this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
          }
        };
      };
      exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/callHierarchy.js
  var require_callHierarchy = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CallHierarchyFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var CallHierarchyFeature = (Base) => {
        return class extends Base {
          get callHierarchy() {
            return {
              onPrepare: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
                });
              },
              onIncomingCalls: (handler) => {
                const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onOutgoingCalls: (handler) => {
                const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.CallHierarchyFeature = CallHierarchyFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/showDocument.js
  var require_showDocument = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ShowDocumentFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var ShowDocumentFeature = (Base) => {
        return class extends Base {
          showDocument(params) {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
          }
        };
      };
      exports2.ShowDocumentFeature = ShowDocumentFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/fileOperations.js
  var require_fileOperations = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FileOperationsFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var FileOperationsFeature = (Base) => {
        return class extends Base {
          onDidCreateFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onDidRenameFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onDidDeleteFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onWillCreateFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
          onWillRenameFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
          onWillDeleteFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
        };
      };
      exports2.FileOperationsFeature = FileOperationsFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
  var require_linkedEditingRange = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LinkedEditingRangeFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var LinkedEditingRangeFeature = (Base) => {
        return class extends Base {
          onLinkedEditingRange(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
            });
          }
        };
      };
      exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/typeHierarchy.js
  var require_typeHierarchy = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeHierarchyFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var TypeHierarchyFeature = (Base) => {
        return class extends Base {
          get typeHierarchy() {
            return {
              onPrepare: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
                });
              },
              onSupertypes: (handler) => {
                const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onSubtypes: (handler) => {
                const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.TypeHierarchyFeature = TypeHierarchyFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/inlineValue.js
  var require_inlineValue = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineValueFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var InlineValueFeature = (Base) => {
        return class extends Base {
          get inlineValue() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params));
                });
              }
            };
          }
        };
      };
      exports2.InlineValueFeature = InlineValueFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/foldingRange.js
  var require_foldingRange = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/foldingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FoldingRangeFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var FoldingRangeFeature = (Base) => {
        return class extends Base {
          get foldingRange() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
              },
              on: (handler) => {
                const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.FoldingRangeFeature = FoldingRangeFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/inlayHint.js
  var require_inlayHint = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlayHintFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var InlayHintFeature = (Base) => {
        return class extends Base {
          get inlayHint() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params));
                });
              },
              resolve: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                  return handler(params, cancel);
                });
              }
            };
          }
        };
      };
      exports2.InlayHintFeature = InlayHintFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/diagnostic.js
  var require_diagnostic = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DiagnosticFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var DiagnosticFeature = (Base) => {
        return class extends Base {
          get diagnostics() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
                });
              },
              onWorkspace: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
                });
              }
            };
          }
        };
      };
      exports2.DiagnosticFeature = DiagnosticFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/moniker.js
  var require_moniker = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MonikerFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var MonikerFeature = (Base) => {
        return class extends Base {
          get moniker() {
            return {
              on: (handler) => {
                const type = vscode_languageserver_protocol_1.MonikerRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.MonikerFeature = MonikerFeature;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/server.js
  var require_server = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
      var vscode_languageserver_protocol_1 = require_main2();
      var Is3 = require_is3();
      var UUID = require_uuid();
      var progress_1 = require_progress();
      var configuration_1 = require_configuration();
      var workspaceFolder_1 = require_workspaceFolder();
      var callHierarchy_1 = require_callHierarchy();
      var semanticTokens_1 = require_semanticTokens();
      var showDocument_1 = require_showDocument();
      var fileOperations_1 = require_fileOperations();
      var linkedEditingRange_1 = require_linkedEditingRange();
      var typeHierarchy_1 = require_typeHierarchy();
      var inlineValue_1 = require_inlineValue();
      var foldingRange_1 = require_foldingRange();
      var inlayHint_1 = require_inlayHint();
      var diagnostic_1 = require_diagnostic();
      var notebook_1 = require_notebook();
      var moniker_1 = require_moniker();
      function null2Undefined(value) {
        if (value === null) {
          return void 0;
        }
        return value;
      }
      var ErrorMessageTracker = class {
        constructor() {
          this._messages = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Add a message to the tracker.
         *
         * @param message The message to add.
         */
        add(message) {
          let count = this._messages[message];
          if (!count) {
            count = 0;
          }
          count++;
          this._messages[message] = count;
        }
        /**
         * Send all tracked messages to the connection's window.
         *
         * @param connection The connection established between client and server.
         */
        sendErrors(connection2) {
          Object.keys(this._messages).forEach((message) => {
            connection2.window.showErrorMessage(message);
          });
        }
      };
      exports2.ErrorMessageTracker = ErrorMessageTracker;
      var RemoteConsoleImpl = class {
        constructor() {
        }
        rawAttach(connection2) {
          this._rawConnection = connection2;
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        fillServerCapabilities(_capabilities) {
        }
        initialize(_capabilities) {
        }
        error(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
        }
        warn(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
        }
        info(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
        }
        log(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
        }
        debug(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
        }
        send(type, message) {
          if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
              (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
            });
          }
        }
      };
      var _RemoteWindowImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        showErrorMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
        showWarningMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
        showInformationMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
      };
      var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
      var BulkRegistration;
      (function(BulkRegistration2) {
        function create() {
          return new BulkRegistrationImpl();
        }
        BulkRegistration2.create = create;
      })(BulkRegistration || (exports2.BulkRegistration = BulkRegistration = {}));
      var BulkRegistrationImpl = class {
        constructor() {
          this._registrations = [];
          this._registered = /* @__PURE__ */ new Set();
        }
        add(type, registerOptions) {
          const method = Is3.string(type) ? type : type.method;
          if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
          }
          const id = UUID.generateUuid();
          this._registrations.push({
            id,
            method,
            registerOptions: registerOptions || {}
          });
          this._registered.add(method);
        }
        asRegistrationParams() {
          return {
            registrations: this._registrations
          };
        }
      };
      var BulkUnregistration;
      (function(BulkUnregistration2) {
        function create() {
          return new BulkUnregistrationImpl(void 0, []);
        }
        BulkUnregistration2.create = create;
      })(BulkUnregistration || (exports2.BulkUnregistration = BulkUnregistration = {}));
      var BulkUnregistrationImpl = class {
        constructor(_connection, unregistrations) {
          this._connection = _connection;
          this._unregistrations = /* @__PURE__ */ new Map();
          unregistrations.forEach((unregistration) => {
            this._unregistrations.set(unregistration.method, unregistration);
          });
        }
        get isAttached() {
          return !!this._connection;
        }
        attach(connection2) {
          this._connection = connection2;
        }
        add(unregistration) {
          this._unregistrations.set(unregistration.method, unregistration);
        }
        dispose() {
          let unregistrations = [];
          for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
          }
          let params = {
            unregisterations: unregistrations
          };
          this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this._connection.console.info(`Bulk unregistration failed.`);
          });
        }
        disposeSingle(arg) {
          const method = Is3.string(arg) ? arg : arg.method;
          const unregistration = this._unregistrations.get(method);
          if (!unregistration) {
            return false;
          }
          let params = {
            unregisterations: [unregistration]
          };
          this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
          }, (_error) => {
            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
          });
          return true;
        }
      };
      var RemoteClientImpl = class {
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
          if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
          } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
          } else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
          }
        }
        registerSingle1(unregistration, type, registerOptions) {
          const method = Is3.string(type) ? type : type.method;
          const id = UUID.generateUuid();
          let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
          };
          if (!unregistration.isAttached) {
            unregistration.attach(this.connection);
          }
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id, method });
            return unregistration;
          }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
          });
        }
        registerSingle2(type, registerOptions) {
          const method = Is3.string(type) ? type : type.method;
          const id = UUID.generateUuid();
          let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
              this.unregisterSingle(id, method).catch(() => {
                this.connection.console.info(`Un-registering capability with id ${id} failed.`);
              });
            });
          }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
          });
        }
        unregisterSingle(id, method) {
          let params = {
            unregisterations: [{ id, method }]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this.connection.console.info(`Un-registering request handler for ${id} failed.`);
          });
        }
        registerMany(registrations) {
          let params = registrations.asRegistrationParams();
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
              return { id: registration.id, method: registration.method };
            }));
          }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
          });
        }
      };
      var _RemoteWorkspaceImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        applyEdit(paramOrEdit) {
          function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
          }
          let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
        }
      };
      var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
      var TracerImpl = class {
        constructor() {
          this._trace = vscode_languageserver_protocol_1.Trace.Off;
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        set trace(value) {
          this._trace = value;
        }
        log(message, verbose) {
          if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
          }
          this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
          }).catch(() => {
          });
        }
      };
      var TelemetryImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        logEvent(data) {
          this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
            this.connection.console.log(`Sending TelemetryEventNotification failed`);
          });
        }
      };
      var _LanguagesImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        attachWorkDoneProgress(params) {
          return (0, progress_1.attachWorkDone)(this.connection, params);
        }
        attachPartialResultProgress(_type, params) {
          return (0, progress_1.attachPartialResult)(this.connection, params);
        }
      };
      exports2._LanguagesImpl = _LanguagesImpl;
      var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
      var _NotebooksImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        attachWorkDoneProgress(params) {
          return (0, progress_1.attachWorkDone)(this.connection, params);
        }
        attachPartialResultProgress(_type, params) {
          return (0, progress_1.attachPartialResult)(this.connection, params);
        }
      };
      exports2._NotebooksImpl = _NotebooksImpl;
      var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
      function combineConsoleFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineConsoleFeatures = combineConsoleFeatures;
      function combineTelemetryFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineTelemetryFeatures = combineTelemetryFeatures;
      function combineTracerFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineTracerFeatures = combineTracerFeatures;
      function combineClientFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineClientFeatures = combineClientFeatures;
      function combineWindowFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineWindowFeatures = combineWindowFeatures;
      function combineWorkspaceFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
      function combineLanguagesFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineLanguagesFeatures = combineLanguagesFeatures;
      function combineNotebooksFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineNotebooksFeatures = combineNotebooksFeatures;
      function combineFeatures(one, two) {
        function combine(one2, two2, func) {
          if (one2 && two2) {
            return func(one2, two2);
          } else if (one2) {
            return one2;
          } else {
            return two2;
          }
        }
        let result = {
          __brand: "features",
          console: combine(one.console, two.console, combineConsoleFeatures),
          tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
          telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
          client: combine(one.client, two.client, combineClientFeatures),
          window: combine(one.window, two.window, combineWindowFeatures),
          workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
          languages: combine(one.languages, two.languages, combineLanguagesFeatures),
          notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
        };
        return result;
      }
      exports2.combineFeatures = combineFeatures;
      function createConnection2(connectionFactory, watchDog, factories) {
        const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
        const connection2 = connectionFactory(logger);
        logger.rawAttach(connection2);
        const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
        const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
        const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
        const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
        const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
        const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
        const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
        const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
        function asPromise(value) {
          if (value instanceof Promise) {
            return value;
          } else if (Is3.thenable(value)) {
            return new Promise((resolve, reject2) => {
              value.then((resolved) => resolve(resolved), (error) => reject2(error));
            });
          } else {
            return Promise.resolve(value);
          }
        }
        let shutdownHandler = void 0;
        let initializeHandler = void 0;
        let exitHandler = void 0;
        let protocolConnection = {
          listen: () => connection2.listen(),
          sendRequest: (type, ...params) => connection2.sendRequest(Is3.string(type) ? type : type.method, ...params),
          onRequest: (type, handler) => connection2.onRequest(type, handler),
          sendNotification: (type, param) => {
            const method = Is3.string(type) ? type : type.method;
            return connection2.sendNotification(method, param);
          },
          onNotification: (type, handler) => connection2.onNotification(type, handler),
          onProgress: connection2.onProgress,
          sendProgress: connection2.sendProgress,
          onInitialize: (handler) => {
            initializeHandler = handler;
            return {
              dispose: () => {
                initializeHandler = void 0;
              }
            };
          },
          onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
          onShutdown: (handler) => {
            shutdownHandler = handler;
            return {
              dispose: () => {
                shutdownHandler = void 0;
              }
            };
          },
          onExit: (handler) => {
            exitHandler = handler;
            return {
              dispose: () => {
                exitHandler = void 0;
              }
            };
          },
          get console() {
            return logger;
          },
          get telemetry() {
            return telemetry;
          },
          get tracer() {
            return tracer;
          },
          get client() {
            return client;
          },
          get window() {
            return remoteWindow;
          },
          get workspace() {
            return workspace;
          },
          get languages() {
            return languages;
          },
          get notebooks() {
            return notebooks;
          },
          onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
          onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
          __textDocumentSync: void 0,
          onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
          onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
          onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
          onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
          onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
          onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
          sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
          onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
          onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
          onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          dispose: () => connection2.dispose()
        };
        for (let remote of allRemotes) {
          remote.attach(protocolConnection);
        }
        connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
          watchDog.initialize(params);
          if (Is3.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
          }
          for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
          }
          if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
            return asPromise(result).then((value) => {
              if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                return value;
              }
              let result2 = value;
              if (!result2) {
                result2 = { capabilities: {} };
              }
              let capabilities = result2.capabilities;
              if (!capabilities) {
                capabilities = {};
                result2.capabilities = capabilities;
              }
              if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
                capabilities.textDocumentSync = Is3.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
              } else if (!Is3.number(capabilities.textDocumentSync) && !Is3.number(capabilities.textDocumentSync.change)) {
                capabilities.textDocumentSync.change = Is3.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
              }
              for (let remote of allRemotes) {
                remote.fillServerCapabilities(capabilities);
              }
              return result2;
            });
          } else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(result.capabilities);
            }
            return result;
          }
        });
        connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
          watchDog.shutdownReceived = true;
          if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
          } else {
            return void 0;
          }
        });
        connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
          try {
            if (exitHandler) {
              exitHandler();
            }
          } finally {
            if (watchDog.shutdownReceived) {
              watchDog.exit(0);
            } else {
              watchDog.exit(1);
            }
          }
        });
        connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
        });
        return protocolConnection;
      }
      exports2.createConnection = createConnection2;
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/common/api.js
  var require_api3 = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
      var semanticTokens_1 = require_semanticTokens();
      Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
        return semanticTokens_1.SemanticTokensBuilder;
      } });
      var ic = require_inlineCompletion_proposed();
      __exportStar(require_main2(), exports2);
      var textDocuments_1 = require_textDocuments();
      Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
        return textDocuments_1.TextDocuments;
      } });
      var notebook_1 = require_notebook();
      Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
        return notebook_1.NotebookDocuments;
      } });
      __exportStar(require_server(), exports2);
      var ProposedFeatures;
      (function(ProposedFeatures2) {
        ProposedFeatures2.all = {
          __brand: "features",
          languages: ic.InlineCompletionFeature
        };
      })(ProposedFeatures || (exports2.ProposedFeatures = ProposedFeatures = {}));
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver-protocol/browser.js
  var require_browser2 = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver-protocol/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = require_main2();
    }
  });

  // ../node_modules/langium/node_modules/vscode-languageserver/lib/browser/main.js
  var require_main3 = __commonJS({
    "../node_modules/langium/node_modules/vscode-languageserver/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createConnection = void 0;
      var api_1 = require_api3();
      __exportStar(require_browser2(), exports2);
      __exportStar(require_api3(), exports2);
      var _shutdownReceived = false;
      var watchDog = {
        initialize: (_params) => {
        },
        get shutdownReceived() {
          return _shutdownReceived;
        },
        set shutdownReceived(value) {
          _shutdownReceived = value;
        },
        exit: (_code) => {
        }
      };
      function createConnection2(arg1, arg2, arg3, arg4) {
        let factories;
        let reader;
        let writer;
        let options;
        if (arg1 !== void 0 && arg1.__brand === "features") {
          factories = arg1;
          arg1 = arg2;
          arg2 = arg3;
          arg3 = arg4;
        }
        if (api_1.ConnectionStrategy.is(arg1) || api_1.ConnectionOptions.is(arg1)) {
          options = arg1;
        } else {
          reader = arg1;
          writer = arg2;
          options = arg3;
        }
        const connectionFactory = (logger) => {
          return (0, api_1.createProtocolConnection)(reader, writer, logger, options);
        };
        return (0, api_1.createConnection)(connectionFactory, watchDog, factories);
      }
      exports2.createConnection = createConnection2;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/is.js
  var require_is4 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messages.js
  var require_messages3 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
      var is = require_is4();
      var ErrorCodes;
      (function(ErrorCodes2) {
        ErrorCodes2.ParseError = -32700;
        ErrorCodes2.InvalidRequest = -32600;
        ErrorCodes2.MethodNotFound = -32601;
        ErrorCodes2.InvalidParams = -32602;
        ErrorCodes2.InternalError = -32603;
        ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
        ErrorCodes2.serverErrorStart = -32099;
        ErrorCodes2.MessageWriteError = -32099;
        ErrorCodes2.MessageReadError = -32098;
        ErrorCodes2.PendingResponseRejected = -32097;
        ErrorCodes2.ConnectionInactive = -32096;
        ErrorCodes2.ServerNotInitialized = -32002;
        ErrorCodes2.UnknownErrorCode = -32001;
        ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
        ErrorCodes2.serverErrorEnd = -32e3;
      })(ErrorCodes || (exports2.ErrorCodes = ErrorCodes = {}));
      var ResponseError2 = class _ResponseError extends Error {
        constructor(code, message, data) {
          super(message);
          this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
          this.data = data;
          Object.setPrototypeOf(this, _ResponseError.prototype);
        }
        toJson() {
          const result = {
            code: this.code,
            message: this.message
          };
          if (this.data !== void 0) {
            result.data = this.data;
          }
          return result;
        }
      };
      exports2.ResponseError = ResponseError2;
      var ParameterStructures = class _ParameterStructures {
        constructor(kind) {
          this.kind = kind;
        }
        static is(value) {
          return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
        }
        toString() {
          return this.kind;
        }
      };
      exports2.ParameterStructures = ParameterStructures;
      ParameterStructures.auto = new ParameterStructures("auto");
      ParameterStructures.byPosition = new ParameterStructures("byPosition");
      ParameterStructures.byName = new ParameterStructures("byName");
      var AbstractMessageSignature = class {
        constructor(method, numberOfParams) {
          this.method = method;
          this.numberOfParams = numberOfParams;
        }
        get parameterStructures() {
          return ParameterStructures.auto;
        }
      };
      exports2.AbstractMessageSignature = AbstractMessageSignature;
      var RequestType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports2.RequestType0 = RequestType0;
      var RequestType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.RequestType = RequestType;
      var RequestType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.RequestType1 = RequestType1;
      var RequestType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports2.RequestType2 = RequestType2;
      var RequestType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports2.RequestType3 = RequestType3;
      var RequestType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports2.RequestType4 = RequestType4;
      var RequestType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports2.RequestType5 = RequestType5;
      var RequestType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports2.RequestType6 = RequestType6;
      var RequestType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports2.RequestType7 = RequestType7;
      var RequestType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports2.RequestType8 = RequestType8;
      var RequestType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports2.RequestType9 = RequestType9;
      var NotificationType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.NotificationType = NotificationType;
      var NotificationType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports2.NotificationType0 = NotificationType0;
      var NotificationType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.NotificationType1 = NotificationType1;
      var NotificationType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports2.NotificationType2 = NotificationType2;
      var NotificationType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports2.NotificationType3 = NotificationType3;
      var NotificationType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports2.NotificationType4 = NotificationType4;
      var NotificationType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports2.NotificationType5 = NotificationType5;
      var NotificationType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports2.NotificationType6 = NotificationType6;
      var NotificationType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports2.NotificationType7 = NotificationType7;
      var NotificationType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports2.NotificationType8 = NotificationType8;
      var NotificationType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports2.NotificationType9 = NotificationType9;
      var Message;
      (function(Message2) {
        function isRequest(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
        }
        Message2.isRequest = isRequest;
        function isNotification(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && message.id === void 0;
        }
        Message2.isNotification = isNotification;
        function isResponse(message) {
          const candidate = message;
          return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
        }
        Message2.isResponse = isResponse;
      })(Message || (exports2.Message = Message = {}));
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/linkedMap.js
  var require_linkedMap2 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
      "use strict";
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
      var Touch;
      (function(Touch2) {
        Touch2.None = 0;
        Touch2.First = 1;
        Touch2.AsOld = Touch2.First;
        Touch2.Last = 2;
        Touch2.AsNew = Touch2.Last;
      })(Touch || (exports2.Touch = Touch = {}));
      var LinkedMap = class {
        constructor() {
          this[_a] = "LinkedMap";
          this._map = /* @__PURE__ */ new Map();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state = 0;
        }
        clear() {
          this._map.clear();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          return this._head?.value;
        }
        get last() {
          return this._tail?.value;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key, touch = Touch.None) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
          return item.value;
        }
        set(key, value, touch = Touch.None) {
          let item = this._map.get(key);
          if (item) {
            item.value = value;
            if (touch !== Touch.None) {
              this.touch(item, touch);
            }
          } else {
            item = { key, value, next: void 0, previous: void 0 };
            switch (touch) {
              case Touch.None:
                this.addItemLast(item);
                break;
              case Touch.First:
                this.addItemFirst(item);
                break;
              case Touch.Last:
                this.addItemLast(item);
                break;
              default:
                this.addItemLast(item);
                break;
            }
            this._map.set(key, item);
            this._size++;
          }
          return this;
        }
        delete(key) {
          return !!this.remove(key);
        }
        remove(key) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          this._map.delete(key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        shift() {
          if (!this._head && !this._tail) {
            return void 0;
          }
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          const item = this._head;
          this._map.delete(item.key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        forEach(callbackfn, thisArg) {
          const state = this._state;
          let current = this._head;
          while (current) {
            if (thisArg) {
              callbackfn.bind(thisArg)(current.value, current.key, this);
            } else {
              callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
          }
        }
        keys() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.key, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        values() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.value, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        entries() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: [current.key, current.value], done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        [(_a = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(newSize) {
          if (newSize >= this.size) {
            return;
          }
          if (newSize === 0) {
            this.clear();
            return;
          }
          let current = this._head;
          let currentSize = this.size;
          while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          if (current) {
            current.previous = void 0;
          }
          this._state++;
        }
        addItemFirst(item) {
          if (!this._head && !this._tail) {
            this._tail = item;
          } else if (!this._head) {
            throw new Error("Invalid list");
          } else {
            item.next = this._head;
            this._head.previous = item;
          }
          this._head = item;
          this._state++;
        }
        addItemLast(item) {
          if (!this._head && !this._tail) {
            this._head = item;
          } else if (!this._tail) {
            throw new Error("Invalid list");
          } else {
            item.previous = this._tail;
            this._tail.next = item;
          }
          this._tail = item;
          this._state++;
        }
        removeItem(item) {
          if (item === this._head && item === this._tail) {
            this._head = void 0;
            this._tail = void 0;
          } else if (item === this._head) {
            if (!item.next) {
              throw new Error("Invalid list");
            }
            item.next.previous = void 0;
            this._head = item.next;
          } else if (item === this._tail) {
            if (!item.previous) {
              throw new Error("Invalid list");
            }
            item.previous.next = void 0;
            this._tail = item.previous;
          } else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
              throw new Error("Invalid list");
            }
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = void 0;
          this._state++;
        }
        touch(item, touch) {
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          if (touch !== Touch.First && touch !== Touch.Last) {
            return;
          }
          if (touch === Touch.First) {
            if (item === this._head) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._tail) {
              previous.next = void 0;
              this._tail = previous;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.previous = void 0;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
          } else if (touch === Touch.Last) {
            if (item === this._tail) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._head) {
              next.previous = void 0;
              this._head = next;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.next = void 0;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
          }
        }
        toJSON() {
          const data = [];
          this.forEach((value, key) => {
            data.push([key, value]);
          });
          return data;
        }
        fromJSON(data) {
          this.clear();
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      };
      exports2.LinkedMap = LinkedMap;
      var LRUCache = class extends LinkedMap {
        constructor(limit, ratio = 1) {
          super();
          this._limit = limit;
          this._ratio = Math.min(Math.max(0, ratio), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(limit) {
          this._limit = limit;
          this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(ratio) {
          this._ratio = Math.min(Math.max(0, ratio), 1);
          this.checkTrim();
        }
        get(key, touch = Touch.AsNew) {
          return super.get(key, touch);
        }
        peek(key) {
          return super.get(key, Touch.None);
        }
        set(key, value) {
          super.set(key, value, Touch.Last);
          this.checkTrim();
          return this;
        }
        checkTrim() {
          if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
          }
        }
      };
      exports2.LRUCache = LRUCache;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/disposable.js
  var require_disposable2 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Disposable = void 0;
      var Disposable2;
      (function(Disposable3) {
        function create(func) {
          return {
            dispose: func
          };
        }
        Disposable3.create = create;
      })(Disposable2 || (exports2.Disposable = Disposable2 = {}));
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/ral.js
  var require_ral2 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var _ral;
      function RAL() {
        if (_ral === void 0) {
          throw new Error(`No runtime abstraction layer installed`);
        }
        return _ral;
      }
      (function(RAL2) {
        function install(ral) {
          if (ral === void 0) {
            throw new Error(`No runtime abstraction layer provided`);
          }
          _ral = ral;
        }
        RAL2.install = install;
      })(RAL || (RAL = {}));
      exports2.default = RAL;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/events.js
  var require_events2 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Emitter = exports2.Event = void 0;
      var ral_1 = require_ral2();
      var Event;
      (function(Event2) {
        const _disposable = { dispose() {
        } };
        Event2.None = function() {
          return _disposable;
        };
      })(Event || (exports2.Event = Event = {}));
      var CallbackList = class {
        add(callback, context = null, bucket) {
          if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
          }
          this._callbacks.push(callback);
          this._contexts.push(context);
          if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
          }
        }
        remove(callback, context = null) {
          if (!this._callbacks) {
            return;
          }
          let foundCallbackWithDifferentContext = false;
          for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
              if (this._contexts[i] === context) {
                this._callbacks.splice(i, 1);
                this._contexts.splice(i, 1);
                return;
              } else {
                foundCallbackWithDifferentContext = true;
              }
            }
          }
          if (foundCallbackWithDifferentContext) {
            throw new Error("When adding a listener with a context, you should remove it with the same context");
          }
        }
        invoke(...args) {
          if (!this._callbacks) {
            return [];
          }
          const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
          for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
              ret.push(callbacks[i].apply(contexts[i], args));
            } catch (e) {
              (0, ral_1.default)().console.error(e);
            }
          }
          return ret;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          this._callbacks = void 0;
          this._contexts = void 0;
        }
      };
      var Emitter3 = class _Emitter {
        constructor(_options) {
          this._options = _options;
        }
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get event() {
          if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
              if (!this._callbacks) {
                this._callbacks = new CallbackList();
              }
              if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                this._options.onFirstListenerAdd(this);
              }
              this._callbacks.add(listener, thisArgs);
              const result = {
                dispose: () => {
                  if (!this._callbacks) {
                    return;
                  }
                  this._callbacks.remove(listener, thisArgs);
                  result.dispose = _Emitter._noop;
                  if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                    this._options.onLastListenerRemove(this);
                  }
                }
              };
              if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event) {
          if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
          }
        }
        dispose() {
          if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = void 0;
          }
        }
      };
      exports2.Emitter = Emitter3;
      Emitter3._noop = function() {
      };
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/cancellation.js
  var require_cancellation2 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
      var ral_1 = require_ral2();
      var Is3 = require_is4();
      var events_1 = require_events2();
      var CancellationToken18;
      (function(CancellationToken19) {
        CancellationToken19.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: events_1.Event.None
        });
        CancellationToken19.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: events_1.Event.None
        });
        function is(value) {
          const candidate = value;
          return candidate && (candidate === CancellationToken19.None || candidate === CancellationToken19.Cancelled || Is3.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
        }
        CancellationToken19.is = is;
      })(CancellationToken18 || (exports2.CancellationToken = CancellationToken18 = {}));
      var shortcutEvent = Object.freeze(function(callback, context) {
        const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
        return { dispose() {
          handle.dispose();
        } };
      });
      var MutableToken = class {
        constructor() {
          this._isCancelled = false;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new events_1.Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = void 0;
          }
        }
      };
      var CancellationTokenSource3 = class {
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken18.Cancelled;
          } else {
            this._token.cancel();
          }
        }
        dispose() {
          if (!this._token) {
            this._token = CancellationToken18.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
      exports2.CancellationTokenSource = CancellationTokenSource3;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
  var require_sharedArrayCancellation2 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
      var cancellation_1 = require_cancellation2();
      var CancellationState;
      (function(CancellationState2) {
        CancellationState2.Continue = 0;
        CancellationState2.Cancelled = 1;
      })(CancellationState || (CancellationState = {}));
      var SharedArraySenderStrategy = class {
        constructor() {
          this.buffers = /* @__PURE__ */ new Map();
        }
        enableCancellation(request) {
          if (request.id === null) {
            return;
          }
          const buffer = new SharedArrayBuffer(4);
          const data = new Int32Array(buffer, 0, 1);
          data[0] = CancellationState.Continue;
          this.buffers.set(request.id, buffer);
          request.$cancellationData = buffer;
        }
        async sendCancellation(_conn, id) {
          const buffer = this.buffers.get(id);
          if (buffer === void 0) {
            return;
          }
          const data = new Int32Array(buffer, 0, 1);
          Atomics.store(data, 0, CancellationState.Cancelled);
        }
        cleanup(id) {
          this.buffers.delete(id);
        }
        dispose() {
          this.buffers.clear();
        }
      };
      exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
      var SharedArrayBufferCancellationToken = class {
        constructor(buffer) {
          this.data = new Int32Array(buffer, 0, 1);
        }
        get isCancellationRequested() {
          return Atomics.load(this.data, 0) === CancellationState.Cancelled;
        }
        get onCancellationRequested() {
          throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
        }
      };
      var SharedArrayBufferCancellationTokenSource = class {
        constructor(buffer) {
          this.token = new SharedArrayBufferCancellationToken(buffer);
        }
        cancel() {
        }
        dispose() {
        }
      };
      var SharedArrayReceiverStrategy = class {
        constructor() {
          this.kind = "request";
        }
        createCancellationTokenSource(request) {
          const buffer = request.$cancellationData;
          if (buffer === void 0) {
            return new cancellation_1.CancellationTokenSource();
          }
          return new SharedArrayBufferCancellationTokenSource(buffer);
        }
      };
      exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/semaphore.js
  var require_semaphore2 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Semaphore = void 0;
      var ral_1 = require_ral2();
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve, reject2) => {
            this._waiting.push({ thunk, resolve, reject: reject2 });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports2.Semaphore = Semaphore;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageReader.js
  var require_messageReader2 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
      var ral_1 = require_ral2();
      var Is3 = require_is4();
      var events_1 = require_events2();
      var semaphore_1 = require_semaphore2();
      var MessageReader;
      (function(MessageReader2) {
        function is(value) {
          let candidate = value;
          return candidate && Is3.func(candidate.listen) && Is3.func(candidate.dispose) && Is3.func(candidate.onError) && Is3.func(candidate.onClose) && Is3.func(candidate.onPartialMessage);
        }
        MessageReader2.is = is;
      })(MessageReader || (exports2.MessageReader = MessageReader = {}));
      var AbstractMessageReader = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
          this.partialMessageEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error) {
          this.errorEmitter.fire(this.asError(error));
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        get onPartialMessage() {
          return this.partialMessageEmitter.event;
        }
        firePartialMessage(info) {
          this.partialMessageEmitter.fire(info);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Reader received error. Reason: ${Is3.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports2.AbstractMessageReader = AbstractMessageReader;
      var ResolvedMessageReaderOptions;
      (function(ResolvedMessageReaderOptions2) {
        function fromOptions(options) {
          let charset;
          let result;
          let contentDecoder;
          const contentDecoders = /* @__PURE__ */ new Map();
          let contentTypeDecoder;
          const contentTypeDecoders = /* @__PURE__ */ new Map();
          if (options === void 0 || typeof options === "string") {
            charset = options ?? "utf-8";
          } else {
            charset = options.charset ?? "utf-8";
            if (options.contentDecoder !== void 0) {
              contentDecoder = options.contentDecoder;
              contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== void 0) {
              for (const decoder of options.contentDecoders) {
                contentDecoders.set(decoder.name, decoder);
              }
            }
            if (options.contentTypeDecoder !== void 0) {
              contentTypeDecoder = options.contentTypeDecoder;
              contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== void 0) {
              for (const decoder of options.contentTypeDecoders) {
                contentTypeDecoders.set(decoder.name, decoder);
              }
            }
          }
          if (contentTypeDecoder === void 0) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
        }
        ResolvedMessageReaderOptions2.fromOptions = fromOptions;
      })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
      var ReadableStreamMessageReader = class extends AbstractMessageReader {
        constructor(readable, options) {
          super();
          this.readable = readable;
          this.options = ResolvedMessageReaderOptions.fromOptions(options);
          this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
          this._partialMessageTimeout = 1e4;
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.readSemaphore = new semaphore_1.Semaphore(1);
        }
        set partialMessageTimeout(timeout) {
          this._partialMessageTimeout = timeout;
        }
        get partialMessageTimeout() {
          return this._partialMessageTimeout;
        }
        listen(callback) {
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.partialMessageTimer = void 0;
          this.callback = callback;
          const result = this.readable.onData((data) => {
            this.onData(data);
          });
          this.readable.onError((error) => this.fireError(error));
          this.readable.onClose(() => this.fireClose());
          return result;
        }
        onData(data) {
          try {
            this.buffer.append(data);
            while (true) {
              if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders(true);
                if (!headers) {
                  return;
                }
                const contentLength = headers.get("content-length");
                if (!contentLength) {
                  this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                  return;
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                  this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                  return;
                }
                this.nextMessageLength = length;
              }
              const body = this.buffer.tryReadBody(this.nextMessageLength);
              if (body === void 0) {
                this.setPartialMessageTimer();
                return;
              }
              this.clearPartialMessageTimer();
              this.nextMessageLength = -1;
              this.readSemaphore.lock(async () => {
                const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                this.callback(message);
              }).catch((error) => {
                this.fireError(error);
              });
            }
          } catch (error) {
            this.fireError(error);
          }
        }
        clearPartialMessageTimer() {
          if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = void 0;
          }
        }
        setPartialMessageTimer() {
          this.clearPartialMessageTimer();
          if (this._partialMessageTimeout <= 0) {
            return;
          }
          this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = void 0;
            if (token === this.messageToken) {
              this.firePartialMessage({ messageToken: token, waitingTime: timeout });
              this.setPartialMessageTimer();
            }
          }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
        }
      };
      exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageWriter.js
  var require_messageWriter2 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
      var ral_1 = require_ral2();
      var Is3 = require_is4();
      var semaphore_1 = require_semaphore2();
      var events_1 = require_events2();
      var ContentLength = "Content-Length: ";
      var CRLF = "\r\n";
      var MessageWriter;
      (function(MessageWriter2) {
        function is(value) {
          let candidate = value;
          return candidate && Is3.func(candidate.dispose) && Is3.func(candidate.onClose) && Is3.func(candidate.onError) && Is3.func(candidate.write);
        }
        MessageWriter2.is = is;
      })(MessageWriter || (exports2.MessageWriter = MessageWriter = {}));
      var AbstractMessageWriter = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error, message, count) {
          this.errorEmitter.fire([this.asError(error), message, count]);
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Writer received error. Reason: ${Is3.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports2.AbstractMessageWriter = AbstractMessageWriter;
      var ResolvedMessageWriterOptions;
      (function(ResolvedMessageWriterOptions2) {
        function fromOptions(options) {
          if (options === void 0 || typeof options === "string") {
            return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
          } else {
            return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
          }
        }
        ResolvedMessageWriterOptions2.fromOptions = fromOptions;
      })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
      var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
        constructor(writable, options) {
          super();
          this.writable = writable;
          this.options = ResolvedMessageWriterOptions.fromOptions(options);
          this.errorCount = 0;
          this.writeSemaphore = new semaphore_1.Semaphore(1);
          this.writable.onError((error) => this.fireError(error));
          this.writable.onClose(() => this.fireClose());
        }
        async write(msg) {
          return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
              if (this.options.contentEncoder !== void 0) {
                return this.options.contentEncoder.encode(buffer);
              } else {
                return buffer;
              }
            });
            return payload.then((buffer) => {
              const headers = [];
              headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
              headers.push(CRLF);
              return this.doWrite(msg, headers, buffer);
            }, (error) => {
              this.fireError(error);
              throw error;
            });
          });
        }
        async doWrite(msg, headers, data) {
          try {
            await this.writable.write(headers.join(""), "ascii");
            return this.writable.write(data);
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
          this.writable.end();
        }
      };
      exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
  var require_messageBuffer2 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AbstractMessageBuffer = void 0;
      var CR = 13;
      var LF = 10;
      var CRLF = "\r\n";
      var AbstractMessageBuffer = class {
        constructor(encoding = "utf-8") {
          this._encoding = encoding;
          this._chunks = [];
          this._totalLength = 0;
        }
        get encoding() {
          return this._encoding;
        }
        append(chunk) {
          const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
          this._chunks.push(toAppend);
          this._totalLength += toAppend.byteLength;
        }
        tryReadHeaders(lowerCaseKeys = false) {
          if (this._chunks.length === 0) {
            return void 0;
          }
          let state = 0;
          let chunkIndex = 0;
          let offset = 0;
          let chunkBytesRead = 0;
          row:
            while (chunkIndex < this._chunks.length) {
              const chunk = this._chunks[chunkIndex];
              offset = 0;
              column:
                while (offset < chunk.length) {
                  const value = chunk[offset];
                  switch (value) {
                    case CR:
                      switch (state) {
                        case 0:
                          state = 1;
                          break;
                        case 2:
                          state = 3;
                          break;
                        default:
                          state = 0;
                      }
                      break;
                    case LF:
                      switch (state) {
                        case 1:
                          state = 2;
                          break;
                        case 3:
                          state = 4;
                          offset++;
                          break row;
                        default:
                          state = 0;
                      }
                      break;
                    default:
                      state = 0;
                  }
                  offset++;
                }
              chunkBytesRead += chunk.byteLength;
              chunkIndex++;
            }
          if (state !== 4) {
            return void 0;
          }
          const buffer = this._read(chunkBytesRead + offset);
          const result = /* @__PURE__ */ new Map();
          const headers = this.toString(buffer, "ascii").split(CRLF);
          if (headers.length < 2) {
            return result;
          }
          for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(":");
            if (index === -1) {
              throw new Error(`Message header must separate key and value using ':'
${header}`);
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
          }
          return result;
        }
        tryReadBody(length) {
          if (this._totalLength < length) {
            return void 0;
          }
          return this._read(length);
        }
        get numberOfBytes() {
          return this._totalLength;
        }
        _read(byteCount) {
          if (byteCount === 0) {
            return this.emptyBuffer();
          }
          if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
          }
          if (this._chunks[0].byteLength === byteCount) {
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
          }
          if (this._chunks[0].byteLength > byteCount) {
            const chunk = this._chunks[0];
            const result2 = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result2;
          }
          const result = this.allocNative(byteCount);
          let resultOffset = 0;
          let chunkIndex = 0;
          while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
              const chunkPart = chunk.slice(0, byteCount);
              result.set(chunkPart, resultOffset);
              resultOffset += byteCount;
              this._chunks[chunkIndex] = chunk.slice(byteCount);
              this._totalLength -= byteCount;
              byteCount -= byteCount;
            } else {
              result.set(chunk, resultOffset);
              resultOffset += chunk.byteLength;
              this._chunks.shift();
              this._totalLength -= chunk.byteLength;
              byteCount -= chunk.byteLength;
            }
          }
          return result;
        }
      };
      exports2.AbstractMessageBuffer = AbstractMessageBuffer;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/connection.js
  var require_connection3 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
      var ral_1 = require_ral2();
      var Is3 = require_is4();
      var messages_1 = require_messages3();
      var linkedMap_1 = require_linkedMap2();
      var events_1 = require_events2();
      var cancellation_1 = require_cancellation2();
      var CancelNotification;
      (function(CancelNotification2) {
        CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
      })(CancelNotification || (CancelNotification = {}));
      var ProgressToken;
      (function(ProgressToken2) {
        function is(value) {
          return typeof value === "string" || typeof value === "number";
        }
        ProgressToken2.is = is;
      })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
      var ProgressNotification;
      (function(ProgressNotification2) {
        ProgressNotification2.type = new messages_1.NotificationType("$/progress");
      })(ProgressNotification || (ProgressNotification = {}));
      var ProgressType = class {
        constructor() {
        }
      };
      exports2.ProgressType = ProgressType;
      var StarRequestHandler;
      (function(StarRequestHandler2) {
        function is(value) {
          return Is3.func(value);
        }
        StarRequestHandler2.is = is;
      })(StarRequestHandler || (StarRequestHandler = {}));
      exports2.NullLogger = Object.freeze({
        error: () => {
        },
        warn: () => {
        },
        info: () => {
        },
        log: () => {
        }
      });
      var Trace;
      (function(Trace2) {
        Trace2[Trace2["Off"] = 0] = "Off";
        Trace2[Trace2["Messages"] = 1] = "Messages";
        Trace2[Trace2["Compact"] = 2] = "Compact";
        Trace2[Trace2["Verbose"] = 3] = "Verbose";
      })(Trace || (exports2.Trace = Trace = {}));
      var TraceValues;
      (function(TraceValues2) {
        TraceValues2.Off = "off";
        TraceValues2.Messages = "messages";
        TraceValues2.Compact = "compact";
        TraceValues2.Verbose = "verbose";
      })(TraceValues || (exports2.TraceValues = TraceValues = {}));
      (function(Trace2) {
        function fromString(value) {
          if (!Is3.string(value)) {
            return Trace2.Off;
          }
          value = value.toLowerCase();
          switch (value) {
            case "off":
              return Trace2.Off;
            case "messages":
              return Trace2.Messages;
            case "compact":
              return Trace2.Compact;
            case "verbose":
              return Trace2.Verbose;
            default:
              return Trace2.Off;
          }
        }
        Trace2.fromString = fromString;
        function toString4(value) {
          switch (value) {
            case Trace2.Off:
              return "off";
            case Trace2.Messages:
              return "messages";
            case Trace2.Compact:
              return "compact";
            case Trace2.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        Trace2.toString = toString4;
      })(Trace || (exports2.Trace = Trace = {}));
      var TraceFormat;
      (function(TraceFormat2) {
        TraceFormat2["Text"] = "text";
        TraceFormat2["JSON"] = "json";
      })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
      (function(TraceFormat2) {
        function fromString(value) {
          if (!Is3.string(value)) {
            return TraceFormat2.Text;
          }
          value = value.toLowerCase();
          if (value === "json") {
            return TraceFormat2.JSON;
          } else {
            return TraceFormat2.Text;
          }
        }
        TraceFormat2.fromString = fromString;
      })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
      var SetTraceNotification;
      (function(SetTraceNotification2) {
        SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
      })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
      var LogTraceNotification;
      (function(LogTraceNotification2) {
        LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
      })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
      var ConnectionErrors;
      (function(ConnectionErrors2) {
        ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
        ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
        ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
      })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
      var ConnectionError = class _ConnectionError extends Error {
        constructor(code, message) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, _ConnectionError.prototype);
        }
      };
      exports2.ConnectionError = ConnectionError;
      var ConnectionStrategy;
      (function(ConnectionStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is3.func(candidate.cancelUndispatched);
        }
        ConnectionStrategy2.is = is;
      })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
      var IdCancellationReceiverStrategy;
      (function(IdCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is3.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is3.func(candidate.dispose));
        }
        IdCancellationReceiverStrategy2.is = is;
      })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
      var RequestCancellationReceiverStrategy;
      (function(RequestCancellationReceiverStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && candidate.kind === "request" && Is3.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is3.func(candidate.dispose));
        }
        RequestCancellationReceiverStrategy2.is = is;
      })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
      var CancellationReceiverStrategy;
      (function(CancellationReceiverStrategy2) {
        CancellationReceiverStrategy2.Message = Object.freeze({
          createCancellationTokenSource(_5) {
            return new cancellation_1.CancellationTokenSource();
          }
        });
        function is(value) {
          return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
        }
        CancellationReceiverStrategy2.is = is;
      })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
      var CancellationSenderStrategy;
      (function(CancellationSenderStrategy2) {
        CancellationSenderStrategy2.Message = Object.freeze({
          sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
          },
          cleanup(_5) {
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is3.func(candidate.sendCancellation) && Is3.func(candidate.cleanup);
        }
        CancellationSenderStrategy2.is = is;
      })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
      var CancellationStrategy;
      (function(CancellationStrategy2) {
        CancellationStrategy2.Message = Object.freeze({
          receiver: CancellationReceiverStrategy.Message,
          sender: CancellationSenderStrategy.Message
        });
        function is(value) {
          const candidate = value;
          return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
        }
        CancellationStrategy2.is = is;
      })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
      var MessageStrategy;
      (function(MessageStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is3.func(candidate.handleMessage);
        }
        MessageStrategy2.is = is;
      })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
      var ConnectionOptions;
      (function(ConnectionOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
        }
        ConnectionOptions2.is = is;
      })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["New"] = 1] = "New";
        ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
        ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
        ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
      })(ConnectionState || (ConnectionState = {}));
      function createMessageConnection(messageReader2, messageWriter2, _logger, options) {
        const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
        let sequenceNumber = 0;
        let notificationSequenceNumber = 0;
        let unknownResponseSequenceNumber = 0;
        const version = "2.0";
        let starRequestHandler = void 0;
        const requestHandlers = /* @__PURE__ */ new Map();
        let starNotificationHandler = void 0;
        const notificationHandlers = /* @__PURE__ */ new Map();
        const progressHandlers = /* @__PURE__ */ new Map();
        let timer2;
        let messageQueue = new linkedMap_1.LinkedMap();
        let responsePromises = /* @__PURE__ */ new Map();
        let knownCanceledRequests = /* @__PURE__ */ new Set();
        let requestTokens = /* @__PURE__ */ new Map();
        let trace = Trace.Off;
        let traceFormat = TraceFormat.Text;
        let tracer;
        let state = ConnectionState.New;
        const errorEmitter = new events_1.Emitter();
        const closeEmitter = new events_1.Emitter();
        const unhandledNotificationEmitter = new events_1.Emitter();
        const unhandledProgressEmitter = new events_1.Emitter();
        const disposeEmitter = new events_1.Emitter();
        const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
        function createRequestQueueKey(id) {
          if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
          }
          return "req-" + id.toString();
        }
        function createResponseQueueKey(id) {
          if (id === null) {
            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
          } else {
            return "res-" + id.toString();
          }
        }
        function createNotificationQueueKey() {
          return "not-" + (++notificationSequenceNumber).toString();
        }
        function addMessageToQueue(queue, message) {
          if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
          } else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
          } else {
            queue.set(createNotificationQueueKey(), message);
          }
        }
        function cancelUndispatched(_message) {
          return void 0;
        }
        function isListening() {
          return state === ConnectionState.Listening;
        }
        function isClosed() {
          return state === ConnectionState.Closed;
        }
        function isDisposed() {
          return state === ConnectionState.Disposed;
        }
        function closeHandler() {
          if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(void 0);
          }
        }
        function readErrorHandler(error) {
          errorEmitter.fire([error, void 0, void 0]);
        }
        function writeErrorHandler(data) {
          errorEmitter.fire(data);
        }
        messageReader2.onClose(closeHandler);
        messageReader2.onError(readErrorHandler);
        messageWriter2.onClose(closeHandler);
        messageWriter2.onError(writeErrorHandler);
        function triggerMessageQueue() {
          if (timer2 || messageQueue.size === 0) {
            return;
          }
          timer2 = (0, ral_1.default)().timer.setImmediate(() => {
            timer2 = void 0;
            processMessageQueue();
          });
        }
        function handleMessage(message) {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        }
        function processMessageQueue() {
          if (messageQueue.size === 0) {
            return;
          }
          const message = messageQueue.shift();
          try {
            const messageStrategy = options?.messageStrategy;
            if (MessageStrategy.is(messageStrategy)) {
              messageStrategy.handleMessage(message, handleMessage);
            } else {
              handleMessage(message);
            }
          } finally {
            triggerMessageQueue();
          }
        }
        const callback = (message) => {
          try {
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
              const cancelId = message.params.id;
              const key = createRequestQueueKey(cancelId);
              const toCancel = messageQueue.get(key);
              if (messages_1.Message.isRequest(toCancel)) {
                const strategy = options?.connectionStrategy;
                const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                if (response && (response.error !== void 0 || response.result !== void 0)) {
                  messageQueue.delete(key);
                  requestTokens.delete(cancelId);
                  response.id = toCancel.id;
                  traceSendingResponse(response, message.method, Date.now());
                  messageWriter2.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                  return;
                }
              }
              const cancellationToken = requestTokens.get(cancelId);
              if (cancellationToken !== void 0) {
                cancellationToken.cancel();
                traceReceivedNotification(message);
                return;
              } else {
                knownCanceledRequests.add(cancelId);
              }
            }
            addMessageToQueue(messageQueue, message);
          } finally {
            triggerMessageQueue();
          }
        };
        function handleRequest(requestMessage) {
          if (isDisposed()) {
            return;
          }
          function reply(resultOrError, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
              message.error = resultOrError.toJson();
            } else {
              message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replyError(error, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              error: error.toJson()
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replySuccess(result, method, startTime2) {
            if (result === void 0) {
              result = null;
            }
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              result
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          traceReceivedRequest(requestMessage);
          const element = requestHandlers.get(requestMessage.method);
          let type;
          let requestHandler;
          if (element) {
            type = element.type;
            requestHandler = element.handler;
          }
          const startTime = Date.now();
          if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now());
            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
              cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
              requestTokens.set(tokenKey, cancellationSource);
            }
            try {
              let handlerResult;
              if (requestHandler) {
                if (requestMessage.params === void 0) {
                  if (type !== void 0 && type.numberOfParams !== 0) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(cancellationSource.token);
                } else if (Array.isArray(requestMessage.params)) {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                }
              } else if (starRequestHandler) {
                handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
              }
              const promise = handlerResult;
              if (!handlerResult) {
                requestTokens.delete(tokenKey);
                replySuccess(handlerResult, requestMessage.method, startTime);
              } else if (promise.then) {
                promise.then((resultOrError) => {
                  requestTokens.delete(tokenKey);
                  reply(resultOrError, requestMessage.method, startTime);
                }, (error) => {
                  requestTokens.delete(tokenKey);
                  if (error instanceof messages_1.ResponseError) {
                    replyError(error, requestMessage.method, startTime);
                  } else if (error && Is3.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                  } else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                  }
                });
              } else {
                requestTokens.delete(tokenKey);
                reply(handlerResult, requestMessage.method, startTime);
              }
            } catch (error) {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                reply(error, requestMessage.method, startTime);
              } else if (error && Is3.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            }
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
          }
        }
        function handleResponse(responseMessage) {
          if (isDisposed()) {
            return;
          }
          if (responseMessage.id === null) {
            if (responseMessage.error) {
              logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
            } else {
              logger.error(`Received response message without id. No further error information provided.`);
            }
          } else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== void 0) {
              responsePromises.delete(key);
              try {
                if (responseMessage.error) {
                  const error = responseMessage.error;
                  responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                } else if (responseMessage.result !== void 0) {
                  responsePromise.resolve(responseMessage.result);
                } else {
                  throw new Error("Should never happen.");
                }
              } catch (error) {
                if (error.message) {
                  logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                } else {
                  logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                }
              }
            }
          }
        }
        function handleNotification(message) {
          if (isDisposed()) {
            return;
          }
          let type = void 0;
          let notificationHandler;
          if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
          } else {
            const element = notificationHandlers.get(message.method);
            if (element) {
              notificationHandler = element.handler;
              type = element.type;
            }
          }
          if (notificationHandler || starNotificationHandler) {
            try {
              traceReceivedNotification(message);
              if (notificationHandler) {
                if (message.params === void 0) {
                  if (type !== void 0) {
                    if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                    }
                  }
                  notificationHandler();
                } else if (Array.isArray(message.params)) {
                  const params = message.params;
                  if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                    notificationHandler({ token: params[0], value: params[1] });
                  } else {
                    if (type !== void 0) {
                      if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                        logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                      }
                      if (type.numberOfParams !== message.params.length) {
                        logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                      }
                    }
                    notificationHandler(...params);
                  }
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                  }
                  notificationHandler(message.params);
                }
              } else if (starNotificationHandler) {
                starNotificationHandler(message.method, message.params);
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
              }
            }
          } else {
            unhandledNotificationEmitter.fire(message);
          }
        }
        function handleInvalidMessage(message) {
          if (!message) {
            logger.error("Received empty message.");
            return;
          }
          logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
          const responseMessage = message;
          if (Is3.string(responseMessage.id) || Is3.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
              responseHandler.reject(new Error("The received response has neither a result nor an error property."));
            }
          }
        }
        function stringifyTrace(params) {
          if (params === void 0 || params === null) {
            return void 0;
          }
          switch (trace) {
            case Trace.Verbose:
              return JSON.stringify(params, null, 4);
            case Trace.Compact:
              return JSON.stringify(params);
            default:
              return void 0;
          }
        }
        function traceSendingRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("send-request", message);
          }
        }
        function traceSendingNotification(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
          } else {
            logLSPMessage("send-notification", message);
          }
        }
        function traceSendingResponse(message, method, startTime) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
          } else {
            logLSPMessage("send-response", message);
          }
        }
        function traceReceivedRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("receive-request", message);
          }
        }
        function traceReceivedNotification(message) {
          if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
          } else {
            logLSPMessage("receive-notification", message);
          }
        }
        function traceReceivedResponse(message, responsePromise) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            if (responsePromise) {
              const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
              tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            } else {
              tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
          } else {
            logLSPMessage("receive-response", message);
          }
        }
        function logLSPMessage(type, message) {
          if (!tracer || trace === Trace.Off) {
            return;
          }
          const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
          };
          tracer.log(lspMessage);
        }
        function throwIfClosedOrDisposed() {
          if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
          }
          if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
          }
        }
        function throwIfListening() {
          if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
          }
        }
        function throwIfNotListening() {
          if (!isListening()) {
            throw new Error("Call listen() first.");
          }
        }
        function undefinedToNull(param) {
          if (param === void 0) {
            return null;
          } else {
            return param;
          }
        }
        function nullToUndefined(param) {
          if (param === null) {
            return void 0;
          } else {
            return param;
          }
        }
        function isNamedParam(param) {
          return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
        }
        function computeSingleParam(parameterStructures, param) {
          switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
              if (isNamedParam(param)) {
                return nullToUndefined(param);
              } else {
                return [undefinedToNull(param)];
              }
            case messages_1.ParameterStructures.byName:
              if (!isNamedParam(param)) {
                throw new Error(`Received parameters by name but param is not an object literal.`);
              }
              return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
              return [undefinedToNull(param)];
            default:
              throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
          }
        }
        function computeMessageParams(type, params) {
          let result;
          const numberOfParams = type.numberOfParams;
          switch (numberOfParams) {
            case 0:
              result = void 0;
              break;
            case 1:
              result = computeSingleParam(type.parameterStructures, params[0]);
              break;
            default:
              result = [];
              for (let i = 0; i < params.length && i < numberOfParams; i++) {
                result.push(undefinedToNull(params[i]));
              }
              if (params.length < numberOfParams) {
                for (let i = params.length; i < numberOfParams; i++) {
                  result.push(null);
                }
              }
              break;
          }
          return result;
        }
        const connection2 = {
          sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is3.string(type)) {
              method = type;
              const first2 = args[0];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first2)) {
                paramStart = 1;
                parameterStructures = first2;
              }
              let paramEnd = args.length;
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
              jsonrpc: version,
              method,
              params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter2.write(notificationMessage).catch((error) => {
              logger.error(`Sending notification failed.`);
              throw error;
            });
          },
          onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is3.func(type)) {
              starNotificationHandler = type;
            } else if (handler) {
              if (Is3.string(type)) {
                method = type;
                notificationHandlers.set(type, { type: void 0, handler });
              } else {
                method = type.method;
                notificationHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method !== void 0) {
                  notificationHandlers.delete(method);
                } else {
                  starNotificationHandler = void 0;
                }
              }
            };
          },
          onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
              throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
              dispose: () => {
                progressHandlers.delete(token);
              }
            };
          },
          sendProgress: (_type, token, value) => {
            return connection2.sendNotification(ProgressNotification.type, { token, value });
          },
          onUnhandledProgress: unhandledProgressEmitter.event,
          sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = void 0;
            if (Is3.string(type)) {
              method = type;
              const first2 = args[0];
              const last2 = args[args.length - 1];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first2)) {
                paramStart = 1;
                parameterStructures = first2;
              }
              let paramEnd = args.length;
              if (cancellation_1.CancellationToken.is(last2)) {
                paramEnd = paramEnd - 1;
                token = last2;
              }
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
              const numberOfParams = type.numberOfParams;
              token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
              disposable = token.onCancellationRequested(() => {
                const p = cancellationStrategy.sender.sendCancellation(connection2, id);
                if (p === void 0) {
                  logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                  return Promise.resolve();
                } else {
                  return p.catch(() => {
                    logger.log(`Sending cancellation messages for id ${id} failed`);
                  });
                }
              });
            }
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            traceSendingRequest(requestMessage);
            if (typeof cancellationStrategy.sender.enableCancellation === "function") {
              cancellationStrategy.sender.enableCancellation(requestMessage);
            }
            return new Promise(async (resolve, reject2) => {
              const resolveWithCleanup = (r) => {
                resolve(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const rejectWithCleanup = (r) => {
                reject2(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
              try {
                await messageWriter2.write(requestMessage);
                responsePromises.set(id, responsePromise);
              } catch (error) {
                logger.error(`Sending request failed.`);
                responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
                throw error;
              }
            });
          },
          onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
              method = void 0;
              starRequestHandler = type;
            } else if (Is3.string(type)) {
              method = null;
              if (handler !== void 0) {
                method = type;
                requestHandlers.set(type, { handler, type: void 0 });
              }
            } else {
              if (handler !== void 0) {
                method = type.method;
                requestHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method === null) {
                  return;
                }
                if (method !== void 0) {
                  requestHandlers.delete(method);
                } else {
                  starRequestHandler = void 0;
                }
              }
            };
          },
          hasPendingResponse: () => {
            return responsePromises.size > 0;
          },
          trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
              if (Is3.boolean(sendNotificationOrTraceOptions)) {
                _sendNotification = sendNotificationOrTraceOptions;
              } else {
                _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
              }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
              tracer = void 0;
            } else {
              tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
              await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
          },
          onError: errorEmitter.event,
          onClose: closeEmitter.event,
          onUnhandledNotification: unhandledNotificationEmitter.event,
          onDispose: disposeEmitter.event,
          end: () => {
            messageWriter2.end();
          },
          dispose: () => {
            if (isDisposed()) {
              return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(void 0);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
            for (const promise of responsePromises.values()) {
              promise.reject(error);
            }
            responsePromises = /* @__PURE__ */ new Map();
            requestTokens = /* @__PURE__ */ new Map();
            knownCanceledRequests = /* @__PURE__ */ new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            if (Is3.func(messageWriter2.dispose)) {
              messageWriter2.dispose();
            }
            if (Is3.func(messageReader2.dispose)) {
              messageReader2.dispose();
            }
          },
          listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader2.listen(callback);
          },
          inspect: () => {
            (0, ral_1.default)().console.log("inspect");
          }
        };
        connection2.onNotification(LogTraceNotification.type, (params) => {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          const verbose = trace === Trace.Verbose || trace === Trace.Compact;
          tracer.log(params.message, verbose ? params.verbose : void 0);
        });
        connection2.onNotification(ProgressNotification.type, (params) => {
          const handler = progressHandlers.get(params.token);
          if (handler) {
            handler(params.value);
          } else {
            unhandledProgressEmitter.fire(params);
          }
        });
        return connection2;
      }
      exports2.createMessageConnection = createMessageConnection;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/api.js
  var require_api4 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
      exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
      var messages_1 = require_messages3();
      Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
        return messages_1.Message;
      } });
      Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
        return messages_1.RequestType;
      } });
      Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
        return messages_1.RequestType0;
      } });
      Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
        return messages_1.RequestType1;
      } });
      Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
        return messages_1.RequestType2;
      } });
      Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
        return messages_1.RequestType3;
      } });
      Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
        return messages_1.RequestType4;
      } });
      Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
        return messages_1.RequestType5;
      } });
      Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
        return messages_1.RequestType6;
      } });
      Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
        return messages_1.RequestType7;
      } });
      Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
        return messages_1.RequestType8;
      } });
      Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
        return messages_1.RequestType9;
      } });
      Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
        return messages_1.ResponseError;
      } });
      Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
        return messages_1.ErrorCodes;
      } });
      Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
        return messages_1.NotificationType;
      } });
      Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
        return messages_1.NotificationType0;
      } });
      Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
        return messages_1.NotificationType1;
      } });
      Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
        return messages_1.NotificationType2;
      } });
      Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
        return messages_1.NotificationType3;
      } });
      Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
        return messages_1.NotificationType4;
      } });
      Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
        return messages_1.NotificationType5;
      } });
      Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
        return messages_1.NotificationType6;
      } });
      Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
        return messages_1.NotificationType7;
      } });
      Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
        return messages_1.NotificationType8;
      } });
      Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
        return messages_1.NotificationType9;
      } });
      Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
        return messages_1.ParameterStructures;
      } });
      var linkedMap_1 = require_linkedMap2();
      Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
        return linkedMap_1.LinkedMap;
      } });
      Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
        return linkedMap_1.LRUCache;
      } });
      Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
        return linkedMap_1.Touch;
      } });
      var disposable_1 = require_disposable2();
      Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
        return disposable_1.Disposable;
      } });
      var events_1 = require_events2();
      Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
        return events_1.Event;
      } });
      Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
        return events_1.Emitter;
      } });
      var cancellation_1 = require_cancellation2();
      Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
        return cancellation_1.CancellationTokenSource;
      } });
      Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
        return cancellation_1.CancellationToken;
      } });
      var sharedArrayCancellation_1 = require_sharedArrayCancellation2();
      Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArraySenderStrategy;
      } });
      Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
      } });
      var messageReader_1 = require_messageReader2();
      Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
        return messageReader_1.MessageReader;
      } });
      Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
        return messageReader_1.AbstractMessageReader;
      } });
      Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return messageReader_1.ReadableStreamMessageReader;
      } });
      var messageWriter_1 = require_messageWriter2();
      Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.MessageWriter;
      } });
      Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.AbstractMessageWriter;
      } });
      Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.WriteableStreamMessageWriter;
      } });
      var messageBuffer_1 = require_messageBuffer2();
      Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
        return messageBuffer_1.AbstractMessageBuffer;
      } });
      var connection_1 = require_connection3();
      Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
        return connection_1.ConnectionStrategy;
      } });
      Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
        return connection_1.ConnectionOptions;
      } });
      Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
        return connection_1.NullLogger;
      } });
      Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
        return connection_1.createMessageConnection;
      } });
      Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
        return connection_1.ProgressToken;
      } });
      Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
        return connection_1.ProgressType;
      } });
      Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
        return connection_1.Trace;
      } });
      Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
        return connection_1.TraceValues;
      } });
      Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
        return connection_1.TraceFormat;
      } });
      Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
        return connection_1.SetTraceNotification;
      } });
      Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
        return connection_1.LogTraceNotification;
      } });
      Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
        return connection_1.ConnectionErrors;
      } });
      Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
        return connection_1.ConnectionError;
      } });
      Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationReceiverStrategy;
      } });
      Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationSenderStrategy;
      } });
      Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationStrategy;
      } });
      Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
        return connection_1.MessageStrategy;
      } });
      var ral_1 = require_ral2();
      exports2.RAL = ral_1.default;
    }
  });

  // node_modules/vscode-jsonrpc/lib/browser/ril.js
  var require_ril2 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var api_1 = require_api4();
      var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
        constructor(encoding = "utf-8") {
          super(encoding);
          this.asciiDecoder = new TextDecoder("ascii");
        }
        emptyBuffer() {
          return _MessageBuffer.emptyBuffer;
        }
        fromString(value, _encoding) {
          return new TextEncoder().encode(value);
        }
        toString(value, encoding) {
          if (encoding === "ascii") {
            return this.asciiDecoder.decode(value);
          } else {
            return new TextDecoder(encoding).decode(value);
          }
        }
        asNative(buffer, length) {
          if (length === void 0) {
            return buffer;
          } else {
            return buffer.slice(0, length);
          }
        }
        allocNative(length) {
          return new Uint8Array(length);
        }
      };
      MessageBuffer.emptyBuffer = new Uint8Array(0);
      var ReadableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
              this._onData.fire(new Uint8Array(buffer));
            }, () => {
              (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
            });
          };
          this.socket.addEventListener("message", this._messageListener);
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        onData(listener) {
          return this._onData.event(listener);
        }
      };
      var WritableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        write(data, encoding) {
          if (typeof data === "string") {
            if (encoding !== void 0 && encoding !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
          } else {
            this.socket.send(data);
          }
          return Promise.resolve();
        }
        end() {
          this.socket.close();
        }
      };
      var _textEncoder = new TextEncoder();
      var _ril = Object.freeze({
        messageBuffer: Object.freeze({
          create: (encoding) => new MessageBuffer(encoding)
        }),
        applicationJson: Object.freeze({
          encoder: Object.freeze({
            name: "application/json",
            encode: (msg, options) => {
              if (options.charset !== "utf-8") {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
              }
              return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
            }
          }),
          decoder: Object.freeze({
            name: "application/json",
            decode: (buffer, options) => {
              if (!(buffer instanceof Uint8Array)) {
                throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
              }
              return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
          })
        }),
        stream: Object.freeze({
          asReadableStream: (socket) => new ReadableStreamWrapper(socket),
          asWritableStream: (socket) => new WritableStreamWrapper(socket)
        }),
        console,
        timer: Object.freeze({
          setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
          }
        })
      });
      function RIL() {
        return _ril;
      }
      (function(RIL2) {
        function install() {
          api_1.RAL.install(_ril);
        }
        RIL2.install = install;
      })(RIL || (RIL = {}));
      exports2.default = RIL;
    }
  });

  // node_modules/vscode-jsonrpc/lib/browser/main.js
  var require_main4 = __commonJS({
    "node_modules/vscode-jsonrpc/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createMessageConnection = exports2.BrowserMessageWriter = exports2.BrowserMessageReader = void 0;
      var ril_1 = require_ril2();
      ril_1.default.install();
      var api_1 = require_api4();
      __exportStar(require_api4(), exports2);
      var BrowserMessageReader2 = class extends api_1.AbstractMessageReader {
        constructor(port) {
          super();
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            this._onData.fire(event.data);
          };
          port.addEventListener("error", (event) => this.fireError(event));
          port.onmessage = this._messageListener;
        }
        listen(callback) {
          return this._onData.event(callback);
        }
      };
      exports2.BrowserMessageReader = BrowserMessageReader2;
      var BrowserMessageWriter2 = class extends api_1.AbstractMessageWriter {
        constructor(port) {
          super();
          this.port = port;
          this.errorCount = 0;
          port.addEventListener("error", (event) => this.fireError(event));
        }
        write(msg) {
          try {
            this.port.postMessage(msg);
            return Promise.resolve();
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
        }
      };
      exports2.BrowserMessageWriter = BrowserMessageWriter2;
      function createMessageConnection(reader, writer, logger, options) {
        if (logger === void 0) {
          logger = api_1.NullLogger;
        }
        if (api_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, api_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports2.createMessageConnection = createMessageConnection;
    }
  });

  // node_modules/vscode-jsonrpc/browser.js
  var require_browser3 = __commonJS({
    "node_modules/vscode-jsonrpc/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = require_main4();
    }
  });

  // node_modules/vscode-languageserver-types/lib/esm/main.js
  var main_exports2 = {};
  __export(main_exports2, {
    AnnotatedTextEdit: () => AnnotatedTextEdit2,
    ChangeAnnotation: () => ChangeAnnotation2,
    ChangeAnnotationIdentifier: () => ChangeAnnotationIdentifier2,
    CodeAction: () => CodeAction2,
    CodeActionContext: () => CodeActionContext2,
    CodeActionKind: () => CodeActionKind2,
    CodeActionTriggerKind: () => CodeActionTriggerKind2,
    CodeDescription: () => CodeDescription2,
    CodeLens: () => CodeLens2,
    Color: () => Color2,
    ColorInformation: () => ColorInformation2,
    ColorPresentation: () => ColorPresentation2,
    Command: () => Command2,
    CompletionItem: () => CompletionItem2,
    CompletionItemKind: () => CompletionItemKind4,
    CompletionItemLabelDetails: () => CompletionItemLabelDetails2,
    CompletionItemTag: () => CompletionItemTag2,
    CompletionList: () => CompletionList3,
    CreateFile: () => CreateFile2,
    DeleteFile: () => DeleteFile2,
    Diagnostic: () => Diagnostic2,
    DiagnosticRelatedInformation: () => DiagnosticRelatedInformation2,
    DiagnosticSeverity: () => DiagnosticSeverity2,
    DiagnosticTag: () => DiagnosticTag2,
    DocumentHighlight: () => DocumentHighlight3,
    DocumentHighlightKind: () => DocumentHighlightKind2,
    DocumentLink: () => DocumentLink2,
    DocumentSymbol: () => DocumentSymbol2,
    DocumentUri: () => DocumentUri2,
    EOL: () => EOL2,
    FoldingRange: () => FoldingRange3,
    FoldingRangeKind: () => FoldingRangeKind3,
    FormattingOptions: () => FormattingOptions2,
    Hover: () => Hover2,
    InlayHint: () => InlayHint2,
    InlayHintKind: () => InlayHintKind2,
    InlayHintLabelPart: () => InlayHintLabelPart2,
    InlineCompletionContext: () => InlineCompletionContext2,
    InlineCompletionItem: () => InlineCompletionItem2,
    InlineCompletionList: () => InlineCompletionList2,
    InlineCompletionTriggerKind: () => InlineCompletionTriggerKind2,
    InlineValueContext: () => InlineValueContext2,
    InlineValueEvaluatableExpression: () => InlineValueEvaluatableExpression2,
    InlineValueText: () => InlineValueText2,
    InlineValueVariableLookup: () => InlineValueVariableLookup2,
    InsertReplaceEdit: () => InsertReplaceEdit2,
    InsertTextFormat: () => InsertTextFormat2,
    InsertTextMode: () => InsertTextMode2,
    Location: () => Location3,
    LocationLink: () => LocationLink3,
    MarkedString: () => MarkedString2,
    MarkupContent: () => MarkupContent2,
    MarkupKind: () => MarkupKind2,
    OptionalVersionedTextDocumentIdentifier: () => OptionalVersionedTextDocumentIdentifier2,
    ParameterInformation: () => ParameterInformation2,
    Position: () => Position3,
    Range: () => Range2,
    RenameFile: () => RenameFile2,
    SelectedCompletionInfo: () => SelectedCompletionInfo2,
    SelectionRange: () => SelectionRange2,
    SemanticTokenModifiers: () => SemanticTokenModifiers3,
    SemanticTokenTypes: () => SemanticTokenTypes3,
    SemanticTokens: () => SemanticTokens2,
    SignatureInformation: () => SignatureInformation2,
    StringValue: () => StringValue2,
    SymbolInformation: () => SymbolInformation2,
    SymbolKind: () => SymbolKind5,
    SymbolTag: () => SymbolTag2,
    TextDocument: () => TextDocument3,
    TextDocumentEdit: () => TextDocumentEdit2,
    TextDocumentIdentifier: () => TextDocumentIdentifier2,
    TextDocumentItem: () => TextDocumentItem2,
    TextEdit: () => TextEdit2,
    URI: () => URI3,
    VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier2,
    WorkspaceChange: () => WorkspaceChange2,
    WorkspaceEdit: () => WorkspaceEdit2,
    WorkspaceFolder: () => WorkspaceFolder2,
    WorkspaceSymbol: () => WorkspaceSymbol2,
    integer: () => integer2,
    uinteger: () => uinteger2
  });
  var DocumentUri2, URI3, integer2, uinteger2, Position3, Range2, Location3, LocationLink3, Color2, ColorInformation2, ColorPresentation2, FoldingRangeKind3, FoldingRange3, DiagnosticRelatedInformation2, DiagnosticSeverity2, DiagnosticTag2, CodeDescription2, Diagnostic2, Command2, TextEdit2, ChangeAnnotation2, ChangeAnnotationIdentifier2, AnnotatedTextEdit2, TextDocumentEdit2, CreateFile2, RenameFile2, DeleteFile2, WorkspaceEdit2, TextEditChangeImpl2, ChangeAnnotations2, WorkspaceChange2, TextDocumentIdentifier2, VersionedTextDocumentIdentifier2, OptionalVersionedTextDocumentIdentifier2, TextDocumentItem2, MarkupKind2, MarkupContent2, CompletionItemKind4, InsertTextFormat2, CompletionItemTag2, InsertReplaceEdit2, InsertTextMode2, CompletionItemLabelDetails2, CompletionItem2, CompletionList3, MarkedString2, Hover2, ParameterInformation2, SignatureInformation2, DocumentHighlightKind2, DocumentHighlight3, SymbolKind5, SymbolTag2, SymbolInformation2, WorkspaceSymbol2, DocumentSymbol2, CodeActionKind2, CodeActionTriggerKind2, CodeActionContext2, CodeAction2, CodeLens2, FormattingOptions2, DocumentLink2, SelectionRange2, SemanticTokenTypes3, SemanticTokenModifiers3, SemanticTokens2, InlineValueText2, InlineValueVariableLookup2, InlineValueEvaluatableExpression2, InlineValueContext2, InlayHintKind2, InlayHintLabelPart2, InlayHint2, StringValue2, InlineCompletionItem2, InlineCompletionList2, InlineCompletionTriggerKind2, SelectedCompletionInfo2, InlineCompletionContext2, WorkspaceFolder2, EOL2, TextDocument3, FullTextDocument3, Is2;
  var init_main2 = __esm({
    "node_modules/vscode-languageserver-types/lib/esm/main.js"() {
      "use strict";
      (function(DocumentUri3) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri3.is = is;
      })(DocumentUri2 || (DocumentUri2 = {}));
      (function(URI4) {
        function is(value) {
          return typeof value === "string";
        }
        URI4.is = is;
      })(URI3 || (URI3 = {}));
      (function(integer3) {
        integer3.MIN_VALUE = -2147483648;
        integer3.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer3.MIN_VALUE <= value && value <= integer3.MAX_VALUE;
        }
        integer3.is = is;
      })(integer2 || (integer2 = {}));
      (function(uinteger3) {
        uinteger3.MIN_VALUE = 0;
        uinteger3.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger3.MIN_VALUE <= value && value <= uinteger3.MAX_VALUE;
        }
        uinteger3.is = is;
      })(uinteger2 || (uinteger2 = {}));
      (function(Position4) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger2.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger2.MAX_VALUE;
          }
          return { line, character };
        }
        Position4.create = create;
        function is(value) {
          let candidate = value;
          return Is2.objectLiteral(candidate) && Is2.uinteger(candidate.line) && Is2.uinteger(candidate.character);
        }
        Position4.is = is;
      })(Position3 || (Position3 = {}));
      (function(Range3) {
        function create(one, two, three, four) {
          if (Is2.uinteger(one) && Is2.uinteger(two) && Is2.uinteger(three) && Is2.uinteger(four)) {
            return { start: Position3.create(one, two), end: Position3.create(three, four) };
          } else if (Position3.is(one) && Position3.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
          }
        }
        Range3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.objectLiteral(candidate) && Position3.is(candidate.start) && Position3.is(candidate.end);
        }
        Range3.is = is;
      })(Range2 || (Range2 = {}));
      (function(Location4) {
        function create(uri, range) {
          return { uri, range };
        }
        Location4.create = create;
        function is(value) {
          let candidate = value;
          return Is2.objectLiteral(candidate) && Range2.is(candidate.range) && (Is2.string(candidate.uri) || Is2.undefined(candidate.uri));
        }
        Location4.is = is;
      })(Location3 || (Location3 = {}));
      (function(LocationLink4) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink4.create = create;
        function is(value) {
          let candidate = value;
          return Is2.objectLiteral(candidate) && Range2.is(candidate.targetRange) && Is2.string(candidate.targetUri) && Range2.is(candidate.targetSelectionRange) && (Range2.is(candidate.originSelectionRange) || Is2.undefined(candidate.originSelectionRange));
        }
        LocationLink4.is = is;
      })(LocationLink3 || (LocationLink3 = {}));
      (function(Color3) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color3.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && Is2.numberRange(candidate.red, 0, 1) && Is2.numberRange(candidate.green, 0, 1) && Is2.numberRange(candidate.blue, 0, 1) && Is2.numberRange(candidate.alpha, 0, 1);
        }
        Color3.is = is;
      })(Color2 || (Color2 = {}));
      (function(ColorInformation3) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation3.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && Range2.is(candidate.range) && Color2.is(candidate.color);
        }
        ColorInformation3.is = is;
      })(ColorInformation2 || (ColorInformation2 = {}));
      (function(ColorPresentation3) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation3.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.label) && (Is2.undefined(candidate.textEdit) || TextEdit2.is(candidate)) && (Is2.undefined(candidate.additionalTextEdits) || Is2.typedArray(candidate.additionalTextEdits, TextEdit2.is));
        }
        ColorPresentation3.is = is;
      })(ColorPresentation2 || (ColorPresentation2 = {}));
      (function(FoldingRangeKind4) {
        FoldingRangeKind4.Comment = "comment";
        FoldingRangeKind4.Imports = "imports";
        FoldingRangeKind4.Region = "region";
      })(FoldingRangeKind3 || (FoldingRangeKind3 = {}));
      (function(FoldingRange4) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          const result = {
            startLine,
            endLine
          };
          if (Is2.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is2.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is2.defined(kind)) {
            result.kind = kind;
          }
          if (Is2.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange4.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && Is2.uinteger(candidate.startLine) && Is2.uinteger(candidate.startLine) && (Is2.undefined(candidate.startCharacter) || Is2.uinteger(candidate.startCharacter)) && (Is2.undefined(candidate.endCharacter) || Is2.uinteger(candidate.endCharacter)) && (Is2.undefined(candidate.kind) || Is2.string(candidate.kind));
        }
        FoldingRange4.is = is;
      })(FoldingRange3 || (FoldingRange3 = {}));
      (function(DiagnosticRelatedInformation3) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && Location3.is(candidate.location) && Is2.string(candidate.message);
        }
        DiagnosticRelatedInformation3.is = is;
      })(DiagnosticRelatedInformation2 || (DiagnosticRelatedInformation2 = {}));
      (function(DiagnosticSeverity3) {
        DiagnosticSeverity3.Error = 1;
        DiagnosticSeverity3.Warning = 2;
        DiagnosticSeverity3.Information = 3;
        DiagnosticSeverity3.Hint = 4;
      })(DiagnosticSeverity2 || (DiagnosticSeverity2 = {}));
      (function(DiagnosticTag3) {
        DiagnosticTag3.Unnecessary = 1;
        DiagnosticTag3.Deprecated = 2;
      })(DiagnosticTag2 || (DiagnosticTag2 = {}));
      (function(CodeDescription3) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.href);
        }
        CodeDescription3.is = is;
      })(CodeDescription2 || (CodeDescription2 = {}));
      (function(Diagnostic3) {
        function create(range, message, severity, code, source, relatedInformation) {
          let result = { range, message };
          if (Is2.defined(severity)) {
            result.severity = severity;
          }
          if (Is2.defined(code)) {
            result.code = code;
          }
          if (Is2.defined(source)) {
            result.source = source;
          }
          if (Is2.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic3.create = create;
        function is(value) {
          var _a;
          let candidate = value;
          return Is2.defined(candidate) && Range2.is(candidate.range) && Is2.string(candidate.message) && (Is2.number(candidate.severity) || Is2.undefined(candidate.severity)) && (Is2.integer(candidate.code) || Is2.string(candidate.code) || Is2.undefined(candidate.code)) && (Is2.undefined(candidate.codeDescription) || Is2.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is2.string(candidate.source) || Is2.undefined(candidate.source)) && (Is2.undefined(candidate.relatedInformation) || Is2.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation2.is));
        }
        Diagnostic3.is = is;
      })(Diagnostic2 || (Diagnostic2 = {}));
      (function(Command3) {
        function create(title, command, ...args) {
          let result = { title, command };
          if (Is2.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.title) && Is2.string(candidate.command);
        }
        Command3.is = is;
      })(Command2 || (Command2 = {}));
      (function(TextEdit3) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit3.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit3.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit3.del = del;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.newText) && Range2.is(candidate.range);
        }
        TextEdit3.is = is;
      })(TextEdit2 || (TextEdit2 = {}));
      (function(ChangeAnnotation3) {
        function create(label, needsConfirmation, description) {
          const result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation3.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.label) && (Is2.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is2.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation3.is = is;
      })(ChangeAnnotation2 || (ChangeAnnotation2 = {}));
      (function(ChangeAnnotationIdentifier3) {
        function is(value) {
          const candidate = value;
          return Is2.string(candidate);
        }
        ChangeAnnotationIdentifier3.is = is;
      })(ChangeAnnotationIdentifier2 || (ChangeAnnotationIdentifier2 = {}));
      (function(AnnotatedTextEdit3) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit3.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit3.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit3.del = del;
        function is(value) {
          const candidate = value;
          return TextEdit2.is(candidate) && (ChangeAnnotation2.is(candidate.annotationId) || ChangeAnnotationIdentifier2.is(candidate.annotationId));
        }
        AnnotatedTextEdit3.is = is;
      })(AnnotatedTextEdit2 || (AnnotatedTextEdit2 = {}));
      (function(TextDocumentEdit3) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && OptionalVersionedTextDocumentIdentifier2.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit3.is = is;
      })(TextDocumentEdit2 || (TextDocumentEdit2 = {}));
      (function(CreateFile3) {
        function create(uri, options, annotation) {
          let result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile3.create = create;
        function is(value) {
          let candidate = value;
          return candidate && candidate.kind === "create" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
        }
        CreateFile3.is = is;
      })(CreateFile2 || (CreateFile2 = {}));
      (function(RenameFile3) {
        function create(oldUri, newUri, options, annotation) {
          let result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile3.create = create;
        function is(value) {
          let candidate = value;
          return candidate && candidate.kind === "rename" && Is2.string(candidate.oldUri) && Is2.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
        }
        RenameFile3.is = is;
      })(RenameFile2 || (RenameFile2 = {}));
      (function(DeleteFile3) {
        function create(uri, options, annotation) {
          let result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile3.create = create;
        function is(value) {
          let candidate = value;
          return candidate && candidate.kind === "delete" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is2.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is2.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
        }
        DeleteFile3.is = is;
      })(DeleteFile2 || (DeleteFile2 = {}));
      (function(WorkspaceEdit3) {
        function is(value) {
          let candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {
            if (Is2.string(change.kind)) {
              return CreateFile2.is(change) || RenameFile2.is(change) || DeleteFile2.is(change);
            } else {
              return TextDocumentEdit2.is(change);
            }
          }));
        }
        WorkspaceEdit3.is = is;
      })(WorkspaceEdit2 || (WorkspaceEdit2 = {}));
      TextEditChangeImpl2 = class {
        constructor(edits, changeAnnotations) {
          this.edits = edits;
          this.changeAnnotations = changeAnnotations;
        }
        insert(position, newText, annotation) {
          let edit;
          let id;
          if (annotation === void 0) {
            edit = TextEdit2.insert(position, newText);
          } else if (ChangeAnnotationIdentifier2.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit2.insert(position, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit2.insert(position, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        }
        replace(range, newText, annotation) {
          let edit;
          let id;
          if (annotation === void 0) {
            edit = TextEdit2.replace(range, newText);
          } else if (ChangeAnnotationIdentifier2.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit2.replace(range, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit2.replace(range, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        }
        delete(range, annotation) {
          let edit;
          let id;
          if (annotation === void 0) {
            edit = TextEdit2.del(range);
          } else if (ChangeAnnotationIdentifier2.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit2.del(range, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit2.del(range, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        }
        add(edit) {
          this.edits.push(edit);
        }
        all() {
          return this.edits;
        }
        clear() {
          this.edits.splice(0, this.edits.length);
        }
        assertChangeAnnotations(value) {
          if (value === void 0) {
            throw new Error(`Text edit change is not configured to manage change annotations.`);
          }
        }
      };
      ChangeAnnotations2 = class {
        constructor(annotations) {
          this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
          this._counter = 0;
          this._size = 0;
        }
        all() {
          return this._annotations;
        }
        get size() {
          return this._size;
        }
        manage(idOrAnnotation, annotation) {
          let id;
          if (ChangeAnnotationIdentifier2.is(idOrAnnotation)) {
            id = idOrAnnotation;
          } else {
            id = this.nextId();
            annotation = idOrAnnotation;
          }
          if (this._annotations[id] !== void 0) {
            throw new Error(`Id ${id} is already in use.`);
          }
          if (annotation === void 0) {
            throw new Error(`No annotation provided for id ${id}`);
          }
          this._annotations[id] = annotation;
          this._size++;
          return id;
        }
        nextId() {
          this._counter++;
          return this._counter.toString();
        }
      };
      WorkspaceChange2 = class {
        constructor(workspaceEdit) {
          this._textEditChanges = /* @__PURE__ */ Object.create(null);
          if (workspaceEdit !== void 0) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
              this._changeAnnotations = new ChangeAnnotations2(workspaceEdit.changeAnnotations);
              workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              workspaceEdit.documentChanges.forEach((change) => {
                if (TextDocumentEdit2.is(change)) {
                  const textEditChange = new TextEditChangeImpl2(change.edits, this._changeAnnotations);
                  this._textEditChanges[change.textDocument.uri] = textEditChange;
                }
              });
            } else if (workspaceEdit.changes) {
              Object.keys(workspaceEdit.changes).forEach((key) => {
                const textEditChange = new TextEditChangeImpl2(workspaceEdit.changes[key]);
                this._textEditChanges[key] = textEditChange;
              });
            }
          } else {
            this._workspaceEdit = {};
          }
        }
        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */
        get edit() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== void 0) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = void 0;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        }
        getTextEditChange(key) {
          if (OptionalVersionedTextDocumentIdentifier2.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            const textDocument = { uri: key.uri, version: key.version };
            let result = this._textEditChanges[textDocument.uri];
            if (!result) {
              const edits = [];
              const textDocumentEdit = {
                textDocument,
                edits
              };
              this._workspaceEdit.documentChanges.push(textDocumentEdit);
              result = new TextEditChangeImpl2(edits, this._changeAnnotations);
              this._textEditChanges[textDocument.uri] = result;
            }
            return result;
          } else {
            this.initChanges();
            if (this._workspaceEdit.changes === void 0) {
              throw new Error("Workspace edit is not configured for normal text edit changes.");
            }
            let result = this._textEditChanges[key];
            if (!result) {
              let edits = [];
              this._workspaceEdit.changes[key] = edits;
              result = new TextEditChangeImpl2(edits);
              this._textEditChanges[key] = result;
            }
            return result;
          }
        }
        initDocumentChanges() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._changeAnnotations = new ChangeAnnotations2();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        }
        initChanges() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
          }
        }
        createFile(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          let annotation;
          if (ChangeAnnotation2.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          let operation;
          let id;
          if (annotation === void 0) {
            operation = CreateFile2.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile2.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        }
        renameFile(oldUri, newUri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          let annotation;
          if (ChangeAnnotation2.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          let operation;
          let id;
          if (annotation === void 0) {
            operation = RenameFile2.create(oldUri, newUri, options);
          } else {
            id = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile2.create(oldUri, newUri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        }
        deleteFile(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          let annotation;
          if (ChangeAnnotation2.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          let operation;
          let id;
          if (annotation === void 0) {
            operation = DeleteFile2.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile2.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        }
      };
      (function(TextDocumentIdentifier3) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri);
        }
        TextDocumentIdentifier3.is = is;
      })(TextDocumentIdentifier2 || (TextDocumentIdentifier2 = {}));
      (function(VersionedTextDocumentIdentifier3) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier3.is = is;
      })(VersionedTextDocumentIdentifier2 || (VersionedTextDocumentIdentifier2 = {}));
      (function(OptionalVersionedTextDocumentIdentifier3) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && (candidate.version === null || Is2.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier3.is = is;
      })(OptionalVersionedTextDocumentIdentifier2 || (OptionalVersionedTextDocumentIdentifier2 = {}));
      (function(TextDocumentItem3) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.string(candidate.languageId) && Is2.integer(candidate.version) && Is2.string(candidate.text);
        }
        TextDocumentItem3.is = is;
      })(TextDocumentItem2 || (TextDocumentItem2 = {}));
      (function(MarkupKind3) {
        MarkupKind3.PlainText = "plaintext";
        MarkupKind3.Markdown = "markdown";
        function is(value) {
          const candidate = value;
          return candidate === MarkupKind3.PlainText || candidate === MarkupKind3.Markdown;
        }
        MarkupKind3.is = is;
      })(MarkupKind2 || (MarkupKind2 = {}));
      (function(MarkupContent3) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(value) && MarkupKind2.is(candidate.kind) && Is2.string(candidate.value);
        }
        MarkupContent3.is = is;
      })(MarkupContent2 || (MarkupContent2 = {}));
      (function(CompletionItemKind6) {
        CompletionItemKind6.Text = 1;
        CompletionItemKind6.Method = 2;
        CompletionItemKind6.Function = 3;
        CompletionItemKind6.Constructor = 4;
        CompletionItemKind6.Field = 5;
        CompletionItemKind6.Variable = 6;
        CompletionItemKind6.Class = 7;
        CompletionItemKind6.Interface = 8;
        CompletionItemKind6.Module = 9;
        CompletionItemKind6.Property = 10;
        CompletionItemKind6.Unit = 11;
        CompletionItemKind6.Value = 12;
        CompletionItemKind6.Enum = 13;
        CompletionItemKind6.Keyword = 14;
        CompletionItemKind6.Snippet = 15;
        CompletionItemKind6.Color = 16;
        CompletionItemKind6.File = 17;
        CompletionItemKind6.Reference = 18;
        CompletionItemKind6.Folder = 19;
        CompletionItemKind6.EnumMember = 20;
        CompletionItemKind6.Constant = 21;
        CompletionItemKind6.Struct = 22;
        CompletionItemKind6.Event = 23;
        CompletionItemKind6.Operator = 24;
        CompletionItemKind6.TypeParameter = 25;
      })(CompletionItemKind4 || (CompletionItemKind4 = {}));
      (function(InsertTextFormat3) {
        InsertTextFormat3.PlainText = 1;
        InsertTextFormat3.Snippet = 2;
      })(InsertTextFormat2 || (InsertTextFormat2 = {}));
      (function(CompletionItemTag3) {
        CompletionItemTag3.Deprecated = 1;
      })(CompletionItemTag2 || (CompletionItemTag2 = {}));
      (function(InsertReplaceEdit3) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit3.create = create;
        function is(value) {
          const candidate = value;
          return candidate && Is2.string(candidate.newText) && Range2.is(candidate.insert) && Range2.is(candidate.replace);
        }
        InsertReplaceEdit3.is = is;
      })(InsertReplaceEdit2 || (InsertReplaceEdit2 = {}));
      (function(InsertTextMode3) {
        InsertTextMode3.asIs = 1;
        InsertTextMode3.adjustIndentation = 2;
      })(InsertTextMode2 || (InsertTextMode2 = {}));
      (function(CompletionItemLabelDetails3) {
        function is(value) {
          const candidate = value;
          return candidate && (Is2.string(candidate.detail) || candidate.detail === void 0) && (Is2.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails3.is = is;
      })(CompletionItemLabelDetails2 || (CompletionItemLabelDetails2 = {}));
      (function(CompletionItem3) {
        function create(label) {
          return { label };
        }
        CompletionItem3.create = create;
      })(CompletionItem2 || (CompletionItem2 = {}));
      (function(CompletionList4) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList4.create = create;
      })(CompletionList3 || (CompletionList3 = {}));
      (function(MarkedString3) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString3.fromPlainText = fromPlainText;
        function is(value) {
          const candidate = value;
          return Is2.string(candidate) || Is2.objectLiteral(candidate) && Is2.string(candidate.language) && Is2.string(candidate.value);
        }
        MarkedString3.is = is;
      })(MarkedString2 || (MarkedString2 = {}));
      (function(Hover3) {
        function is(value) {
          let candidate = value;
          return !!candidate && Is2.objectLiteral(candidate) && (MarkupContent2.is(candidate.contents) || MarkedString2.is(candidate.contents) || Is2.typedArray(candidate.contents, MarkedString2.is)) && (value.range === void 0 || Range2.is(value.range));
        }
        Hover3.is = is;
      })(Hover2 || (Hover2 = {}));
      (function(ParameterInformation3) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation3.create = create;
      })(ParameterInformation2 || (ParameterInformation2 = {}));
      (function(SignatureInformation3) {
        function create(label, documentation, ...parameters) {
          let result = { label };
          if (Is2.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is2.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation3.create = create;
      })(SignatureInformation2 || (SignatureInformation2 = {}));
      (function(DocumentHighlightKind3) {
        DocumentHighlightKind3.Text = 1;
        DocumentHighlightKind3.Read = 2;
        DocumentHighlightKind3.Write = 3;
      })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
      (function(DocumentHighlight4) {
        function create(range, kind) {
          let result = { range };
          if (Is2.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight4.create = create;
      })(DocumentHighlight3 || (DocumentHighlight3 = {}));
      (function(SymbolKind6) {
        SymbolKind6.File = 1;
        SymbolKind6.Module = 2;
        SymbolKind6.Namespace = 3;
        SymbolKind6.Package = 4;
        SymbolKind6.Class = 5;
        SymbolKind6.Method = 6;
        SymbolKind6.Property = 7;
        SymbolKind6.Field = 8;
        SymbolKind6.Constructor = 9;
        SymbolKind6.Enum = 10;
        SymbolKind6.Interface = 11;
        SymbolKind6.Function = 12;
        SymbolKind6.Variable = 13;
        SymbolKind6.Constant = 14;
        SymbolKind6.String = 15;
        SymbolKind6.Number = 16;
        SymbolKind6.Boolean = 17;
        SymbolKind6.Array = 18;
        SymbolKind6.Object = 19;
        SymbolKind6.Key = 20;
        SymbolKind6.Null = 21;
        SymbolKind6.EnumMember = 22;
        SymbolKind6.Struct = 23;
        SymbolKind6.Event = 24;
        SymbolKind6.Operator = 25;
        SymbolKind6.TypeParameter = 26;
      })(SymbolKind5 || (SymbolKind5 = {}));
      (function(SymbolTag3) {
        SymbolTag3.Deprecated = 1;
      })(SymbolTag2 || (SymbolTag2 = {}));
      (function(SymbolInformation3) {
        function create(name, kind, range, uri, containerName) {
          let result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation3.create = create;
      })(SymbolInformation2 || (SymbolInformation2 = {}));
      (function(WorkspaceSymbol3) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol3.create = create;
      })(WorkspaceSymbol2 || (WorkspaceSymbol2 = {}));
      (function(DocumentSymbol3) {
        function create(name, detail, kind, range, selectionRange, children) {
          let result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol3.create = create;
        function is(value) {
          let candidate = value;
          return candidate && Is2.string(candidate.name) && Is2.number(candidate.kind) && Range2.is(candidate.range) && Range2.is(candidate.selectionRange) && (candidate.detail === void 0 || Is2.string(candidate.detail)) && (candidate.deprecated === void 0 || Is2.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol3.is = is;
      })(DocumentSymbol2 || (DocumentSymbol2 = {}));
      (function(CodeActionKind3) {
        CodeActionKind3.Empty = "";
        CodeActionKind3.QuickFix = "quickfix";
        CodeActionKind3.Refactor = "refactor";
        CodeActionKind3.RefactorExtract = "refactor.extract";
        CodeActionKind3.RefactorInline = "refactor.inline";
        CodeActionKind3.RefactorRewrite = "refactor.rewrite";
        CodeActionKind3.Source = "source";
        CodeActionKind3.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind3.SourceFixAll = "source.fixAll";
      })(CodeActionKind2 || (CodeActionKind2 = {}));
      (function(CodeActionTriggerKind3) {
        CodeActionTriggerKind3.Invoked = 1;
        CodeActionTriggerKind3.Automatic = 2;
      })(CodeActionTriggerKind2 || (CodeActionTriggerKind2 = {}));
      (function(CodeActionContext3) {
        function create(diagnostics, only, triggerKind) {
          let result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && Is2.typedArray(candidate.diagnostics, Diagnostic2.is) && (candidate.only === void 0 || Is2.typedArray(candidate.only, Is2.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind2.Invoked || candidate.triggerKind === CodeActionTriggerKind2.Automatic);
        }
        CodeActionContext3.is = is;
      })(CodeActionContext2 || (CodeActionContext2 = {}));
      (function(CodeAction3) {
        function create(title, kindOrCommandOrEdit, kind) {
          let result = { title };
          let checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command2.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction3.create = create;
        function is(value) {
          let candidate = value;
          return candidate && Is2.string(candidate.title) && (candidate.diagnostics === void 0 || Is2.typedArray(candidate.diagnostics, Diagnostic2.is)) && (candidate.kind === void 0 || Is2.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is2.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit2.is(candidate.edit));
        }
        CodeAction3.is = is;
      })(CodeAction2 || (CodeAction2 = {}));
      (function(CodeLens3) {
        function create(range, data) {
          let result = { range };
          if (Is2.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && Range2.is(candidate.range) && (Is2.undefined(candidate.command) || Command2.is(candidate.command));
        }
        CodeLens3.is = is;
      })(CodeLens2 || (CodeLens2 = {}));
      (function(FormattingOptions3) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && Is2.uinteger(candidate.tabSize) && Is2.boolean(candidate.insertSpaces);
        }
        FormattingOptions3.is = is;
      })(FormattingOptions2 || (FormattingOptions2 = {}));
      (function(DocumentLink3) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && Range2.is(candidate.range) && (Is2.undefined(candidate.target) || Is2.string(candidate.target));
        }
        DocumentLink3.is = is;
      })(DocumentLink2 || (DocumentLink2 = {}));
      (function(SelectionRange3) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange3.create = create;
        function is(value) {
          let candidate = value;
          return Is2.objectLiteral(candidate) && Range2.is(candidate.range) && (candidate.parent === void 0 || SelectionRange3.is(candidate.parent));
        }
        SelectionRange3.is = is;
      })(SelectionRange2 || (SelectionRange2 = {}));
      (function(SemanticTokenTypes5) {
        SemanticTokenTypes5["namespace"] = "namespace";
        SemanticTokenTypes5["type"] = "type";
        SemanticTokenTypes5["class"] = "class";
        SemanticTokenTypes5["enum"] = "enum";
        SemanticTokenTypes5["interface"] = "interface";
        SemanticTokenTypes5["struct"] = "struct";
        SemanticTokenTypes5["typeParameter"] = "typeParameter";
        SemanticTokenTypes5["parameter"] = "parameter";
        SemanticTokenTypes5["variable"] = "variable";
        SemanticTokenTypes5["property"] = "property";
        SemanticTokenTypes5["enumMember"] = "enumMember";
        SemanticTokenTypes5["event"] = "event";
        SemanticTokenTypes5["function"] = "function";
        SemanticTokenTypes5["method"] = "method";
        SemanticTokenTypes5["macro"] = "macro";
        SemanticTokenTypes5["keyword"] = "keyword";
        SemanticTokenTypes5["modifier"] = "modifier";
        SemanticTokenTypes5["comment"] = "comment";
        SemanticTokenTypes5["string"] = "string";
        SemanticTokenTypes5["number"] = "number";
        SemanticTokenTypes5["regexp"] = "regexp";
        SemanticTokenTypes5["operator"] = "operator";
        SemanticTokenTypes5["decorator"] = "decorator";
      })(SemanticTokenTypes3 || (SemanticTokenTypes3 = {}));
      (function(SemanticTokenModifiers4) {
        SemanticTokenModifiers4["declaration"] = "declaration";
        SemanticTokenModifiers4["definition"] = "definition";
        SemanticTokenModifiers4["readonly"] = "readonly";
        SemanticTokenModifiers4["static"] = "static";
        SemanticTokenModifiers4["deprecated"] = "deprecated";
        SemanticTokenModifiers4["abstract"] = "abstract";
        SemanticTokenModifiers4["async"] = "async";
        SemanticTokenModifiers4["modification"] = "modification";
        SemanticTokenModifiers4["documentation"] = "documentation";
        SemanticTokenModifiers4["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers3 || (SemanticTokenModifiers3 = {}));
      (function(SemanticTokens3) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens3.is = is;
      })(SemanticTokens2 || (SemanticTokens2 = {}));
      (function(InlineValueText3) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText3.create = create;
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is2.string(candidate.text);
        }
        InlineValueText3.is = is;
      })(InlineValueText2 || (InlineValueText2 = {}));
      (function(InlineValueVariableLookup3) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup3.create = create;
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is2.boolean(candidate.caseSensitiveLookup) && (Is2.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup3.is = is;
      })(InlineValueVariableLookup2 || (InlineValueVariableLookup2 = {}));
      (function(InlineValueEvaluatableExpression3) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression3.create = create;
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && (Is2.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression3.is = is;
      })(InlineValueEvaluatableExpression2 || (InlineValueEvaluatableExpression2 = {}));
      (function(InlineValueContext3) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext3.create = create;
        function is(value) {
          const candidate = value;
          return Is2.defined(candidate) && Range2.is(value.stoppedLocation);
        }
        InlineValueContext3.is = is;
      })(InlineValueContext2 || (InlineValueContext2 = {}));
      (function(InlayHintKind3) {
        InlayHintKind3.Type = 1;
        InlayHintKind3.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind3.is = is;
      })(InlayHintKind2 || (InlayHintKind2 = {}));
      (function(InlayHintLabelPart3) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart3.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is2.string(candidate.tooltip) || MarkupContent2.is(candidate.tooltip)) && (candidate.location === void 0 || Location3.is(candidate.location)) && (candidate.command === void 0 || Command2.is(candidate.command));
        }
        InlayHintLabelPart3.is = is;
      })(InlayHintLabelPart2 || (InlayHintLabelPart2 = {}));
      (function(InlayHint3) {
        function create(position, label, kind) {
          const result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint3.create = create;
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && Position3.is(candidate.position) && (Is2.string(candidate.label) || Is2.typedArray(candidate.label, InlayHintLabelPart2.is)) && (candidate.kind === void 0 || InlayHintKind2.is(candidate.kind)) && candidate.textEdits === void 0 || Is2.typedArray(candidate.textEdits, TextEdit2.is) && (candidate.tooltip === void 0 || Is2.string(candidate.tooltip) || MarkupContent2.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is2.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is2.boolean(candidate.paddingRight));
        }
        InlayHint3.is = is;
      })(InlayHint2 || (InlayHint2 = {}));
      (function(StringValue3) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue3.createSnippet = createSnippet;
      })(StringValue2 || (StringValue2 = {}));
      (function(InlineCompletionItem3) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem3.create = create;
      })(InlineCompletionItem2 || (InlineCompletionItem2 = {}));
      (function(InlineCompletionList3) {
        function create(items) {
          return { items };
        }
        InlineCompletionList3.create = create;
      })(InlineCompletionList2 || (InlineCompletionList2 = {}));
      (function(InlineCompletionTriggerKind3) {
        InlineCompletionTriggerKind3.Invoked = 0;
        InlineCompletionTriggerKind3.Automatic = 1;
      })(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
      (function(SelectedCompletionInfo3) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo3.create = create;
      })(SelectedCompletionInfo2 || (SelectedCompletionInfo2 = {}));
      (function(InlineCompletionContext3) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext3.create = create;
      })(InlineCompletionContext2 || (InlineCompletionContext2 = {}));
      (function(WorkspaceFolder3) {
        function is(value) {
          const candidate = value;
          return Is2.objectLiteral(candidate) && URI3.is(candidate.uri) && Is2.string(candidate.name);
        }
        WorkspaceFolder3.is = is;
      })(WorkspaceFolder2 || (WorkspaceFolder2 = {}));
      EOL2 = ["\n", "\r\n", "\r"];
      (function(TextDocument4) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument3(uri, languageId, version, content);
        }
        TextDocument4.create = create;
        function is(value) {
          let candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && (Is2.undefined(candidate.languageId) || Is2.string(candidate.languageId)) && Is2.uinteger(candidate.lineCount) && Is2.func(candidate.getText) && Is2.func(candidate.positionAt) && Is2.func(candidate.offsetAt) ? true : false;
        }
        TextDocument4.is = is;
        function applyEdits(document, edits) {
          let text = document.getText();
          let sortedEdits = mergeSort2(edits, (a2, b) => {
            let diff = a2.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a2.range.start.character - b.range.start.character;
            }
            return diff;
          });
          let lastModifiedOffset = text.length;
          for (let i = sortedEdits.length - 1; i >= 0; i--) {
            let e = sortedEdits[i];
            let startOffset = document.offsetAt(e.range.start);
            let endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument4.applyEdits = applyEdits;
        function mergeSort2(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          const p = data.length / 2 | 0;
          const left = data.slice(0, p);
          const right = data.slice(p);
          mergeSort2(left, compare);
          mergeSort2(right, compare);
          let leftIdx = 0;
          let rightIdx = 0;
          let i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            let ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument3 || (TextDocument3 = {}));
      FullTextDocument3 = class {
        constructor(uri, languageId, version, content) {
          this._uri = uri;
          this._languageId = languageId;
          this._version = version;
          this._content = content;
          this._lineOffsets = void 0;
        }
        get uri() {
          return this._uri;
        }
        get languageId() {
          return this._languageId;
        }
        get version() {
          return this._version;
        }
        getText(range) {
          if (range) {
            let start = this.offsetAt(range.start);
            let end = this.offsetAt(range.end);
            return this._content.substring(start, end);
          }
          return this._content;
        }
        update(event, version) {
          this._content = event.text;
          this._version = version;
          this._lineOffsets = void 0;
        }
        getLineOffsets() {
          if (this._lineOffsets === void 0) {
            let lineOffsets = [];
            let text = this._content;
            let isLineStart = true;
            for (let i = 0; i < text.length; i++) {
              if (isLineStart) {
                lineOffsets.push(i);
                isLineStart = false;
              }
              let ch = text.charAt(i);
              isLineStart = ch === "\r" || ch === "\n";
              if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                i++;
              }
            }
            if (isLineStart && text.length > 0) {
              lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
          }
          return this._lineOffsets;
        }
        positionAt(offset) {
          offset = Math.max(Math.min(offset, this._content.length), 0);
          let lineOffsets = this.getLineOffsets();
          let low = 0, high = lineOffsets.length;
          if (high === 0) {
            return Position3.create(0, offset);
          }
          while (low < high) {
            let mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
              high = mid;
            } else {
              low = mid + 1;
            }
          }
          let line = low - 1;
          return Position3.create(line, offset - lineOffsets[line]);
        }
        offsetAt(position) {
          let lineOffsets = this.getLineOffsets();
          if (position.line >= lineOffsets.length) {
            return this._content.length;
          } else if (position.line < 0) {
            return 0;
          }
          let lineOffset = lineOffsets[position.line];
          let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
          return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        }
        get lineCount() {
          return this.getLineOffsets().length;
        }
      };
      (function(Is3) {
        const toString4 = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is3.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is3.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is3.boolean = boolean;
        function string(value) {
          return toString4.call(value) === "[object String]";
        }
        Is3.string = string;
        function number(value) {
          return toString4.call(value) === "[object Number]";
        }
        Is3.number = number;
        function numberRange(value, min2, max) {
          return toString4.call(value) === "[object Number]" && min2 <= value && value <= max;
        }
        Is3.numberRange = numberRange;
        function integer3(value) {
          return toString4.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is3.integer = integer3;
        function uinteger3(value) {
          return toString4.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is3.uinteger = uinteger3;
        function func(value) {
          return toString4.call(value) === "[object Function]";
        }
        Is3.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is3.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is3.typedArray = typedArray;
      })(Is2 || (Is2 = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/messages.js
  var require_messages4 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
      var vscode_jsonrpc_1 = require_main4();
      var MessageDirection;
      (function(MessageDirection2) {
        MessageDirection2["clientToServer"] = "clientToServer";
        MessageDirection2["serverToClient"] = "serverToClient";
        MessageDirection2["both"] = "both";
      })(MessageDirection || (exports2.MessageDirection = MessageDirection = {}));
      var RegistrationType = class {
        constructor(method) {
          this.method = method;
        }
      };
      exports2.RegistrationType = RegistrationType;
      var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
        constructor(method) {
          super(method);
        }
      };
      exports2.ProtocolRequestType0 = ProtocolRequestType0;
      var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports2.ProtocolRequestType = ProtocolRequestType;
      var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
        constructor(method) {
          super(method);
        }
      };
      exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
      var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports2.ProtocolNotificationType = ProtocolNotificationType;
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
  var require_is5 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports2.typedArray = typedArray;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      exports2.objectLiteral = objectLiteral;
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
  var require_protocol_implementation2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ImplementationRequest = void 0;
      var messages_1 = require_messages4();
      var ImplementationRequest;
      (function(ImplementationRequest2) {
        ImplementationRequest2.method = "textDocument/implementation";
        ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
      })(ImplementationRequest || (exports2.ImplementationRequest = ImplementationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
  var require_protocol_typeDefinition2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeDefinitionRequest = void 0;
      var messages_1 = require_messages4();
      var TypeDefinitionRequest;
      (function(TypeDefinitionRequest2) {
        TypeDefinitionRequest2.method = "textDocument/typeDefinition";
        TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
      })(TypeDefinitionRequest || (exports2.TypeDefinitionRequest = TypeDefinitionRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
  var require_protocol_workspaceFolder2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
      var messages_1 = require_messages4();
      var WorkspaceFoldersRequest;
      (function(WorkspaceFoldersRequest2) {
        WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
        WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
      })(WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
      var DidChangeWorkspaceFoldersNotification;
      (function(DidChangeWorkspaceFoldersNotification2) {
        DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
        DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
      })(DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
  var require_protocol_configuration2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConfigurationRequest = void 0;
      var messages_1 = require_messages4();
      var ConfigurationRequest;
      (function(ConfigurationRequest2) {
        ConfigurationRequest2.method = "workspace/configuration";
        ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
      })(ConfigurationRequest || (exports2.ConfigurationRequest = ConfigurationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
  var require_protocol_colorProvider2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
      var messages_1 = require_messages4();
      var DocumentColorRequest;
      (function(DocumentColorRequest2) {
        DocumentColorRequest2.method = "textDocument/documentColor";
        DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
      })(DocumentColorRequest || (exports2.DocumentColorRequest = DocumentColorRequest = {}));
      var ColorPresentationRequest;
      (function(ColorPresentationRequest2) {
        ColorPresentationRequest2.method = "textDocument/colorPresentation";
        ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
      })(ColorPresentationRequest || (exports2.ColorPresentationRequest = ColorPresentationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
  var require_protocol_foldingRange2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = void 0;
      var messages_1 = require_messages4();
      var FoldingRangeRequest;
      (function(FoldingRangeRequest2) {
        FoldingRangeRequest2.method = "textDocument/foldingRange";
        FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
      })(FoldingRangeRequest || (exports2.FoldingRangeRequest = FoldingRangeRequest = {}));
      var FoldingRangeRefreshRequest;
      (function(FoldingRangeRefreshRequest2) {
        FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
        FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
      })(FoldingRangeRefreshRequest || (exports2.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
  var require_protocol_declaration2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DeclarationRequest = void 0;
      var messages_1 = require_messages4();
      var DeclarationRequest;
      (function(DeclarationRequest2) {
        DeclarationRequest2.method = "textDocument/declaration";
        DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
      })(DeclarationRequest || (exports2.DeclarationRequest = DeclarationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
  var require_protocol_selectionRange2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SelectionRangeRequest = void 0;
      var messages_1 = require_messages4();
      var SelectionRangeRequest;
      (function(SelectionRangeRequest2) {
        SelectionRangeRequest2.method = "textDocument/selectionRange";
        SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
      })(SelectionRangeRequest || (exports2.SelectionRangeRequest = SelectionRangeRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
  var require_protocol_progress2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
      var vscode_jsonrpc_1 = require_main4();
      var messages_1 = require_messages4();
      var WorkDoneProgress;
      (function(WorkDoneProgress2) {
        WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
        function is(value) {
          return value === WorkDoneProgress2.type;
        }
        WorkDoneProgress2.is = is;
      })(WorkDoneProgress || (exports2.WorkDoneProgress = WorkDoneProgress = {}));
      var WorkDoneProgressCreateRequest;
      (function(WorkDoneProgressCreateRequest2) {
        WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
        WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
      })(WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
      var WorkDoneProgressCancelNotification;
      (function(WorkDoneProgressCancelNotification2) {
        WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
        WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
      })(WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
  var require_protocol_callHierarchy2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages4();
      var CallHierarchyPrepareRequest;
      (function(CallHierarchyPrepareRequest2) {
        CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
        CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
      })(CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
      var CallHierarchyIncomingCallsRequest;
      (function(CallHierarchyIncomingCallsRequest2) {
        CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
        CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
      })(CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
      var CallHierarchyOutgoingCallsRequest;
      (function(CallHierarchyOutgoingCallsRequest2) {
        CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
        CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
      })(CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
  var require_protocol_semanticTokens2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
      var messages_1 = require_messages4();
      var TokenFormat;
      (function(TokenFormat2) {
        TokenFormat2.Relative = "relative";
      })(TokenFormat || (exports2.TokenFormat = TokenFormat = {}));
      var SemanticTokensRegistrationType;
      (function(SemanticTokensRegistrationType2) {
        SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
        SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
      })(SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
      var SemanticTokensRequest;
      (function(SemanticTokensRequest2) {
        SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
        SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
        SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensRequest || (exports2.SemanticTokensRequest = SemanticTokensRequest = {}));
      var SemanticTokensDeltaRequest;
      (function(SemanticTokensDeltaRequest2) {
        SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
        SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
        SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
      var SemanticTokensRangeRequest;
      (function(SemanticTokensRangeRequest2) {
        SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
        SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
        SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
      var SemanticTokensRefreshRequest;
      (function(SemanticTokensRefreshRequest2) {
        SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
        SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
      })(SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
  var require_protocol_showDocument2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ShowDocumentRequest = void 0;
      var messages_1 = require_messages4();
      var ShowDocumentRequest;
      (function(ShowDocumentRequest2) {
        ShowDocumentRequest2.method = "window/showDocument";
        ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
      })(ShowDocumentRequest || (exports2.ShowDocumentRequest = ShowDocumentRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
  var require_protocol_linkedEditingRange2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LinkedEditingRangeRequest = void 0;
      var messages_1 = require_messages4();
      var LinkedEditingRangeRequest;
      (function(LinkedEditingRangeRequest2) {
        LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
        LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
      })(LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
  var require_protocol_fileOperations2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
      var messages_1 = require_messages4();
      var FileOperationPatternKind;
      (function(FileOperationPatternKind2) {
        FileOperationPatternKind2.file = "file";
        FileOperationPatternKind2.folder = "folder";
      })(FileOperationPatternKind || (exports2.FileOperationPatternKind = FileOperationPatternKind = {}));
      var WillCreateFilesRequest;
      (function(WillCreateFilesRequest2) {
        WillCreateFilesRequest2.method = "workspace/willCreateFiles";
        WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
      })(WillCreateFilesRequest || (exports2.WillCreateFilesRequest = WillCreateFilesRequest = {}));
      var DidCreateFilesNotification;
      (function(DidCreateFilesNotification2) {
        DidCreateFilesNotification2.method = "workspace/didCreateFiles";
        DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
      })(DidCreateFilesNotification || (exports2.DidCreateFilesNotification = DidCreateFilesNotification = {}));
      var WillRenameFilesRequest;
      (function(WillRenameFilesRequest2) {
        WillRenameFilesRequest2.method = "workspace/willRenameFiles";
        WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
      })(WillRenameFilesRequest || (exports2.WillRenameFilesRequest = WillRenameFilesRequest = {}));
      var DidRenameFilesNotification;
      (function(DidRenameFilesNotification2) {
        DidRenameFilesNotification2.method = "workspace/didRenameFiles";
        DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
      })(DidRenameFilesNotification || (exports2.DidRenameFilesNotification = DidRenameFilesNotification = {}));
      var DidDeleteFilesNotification;
      (function(DidDeleteFilesNotification2) {
        DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
        DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
      })(DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
      var WillDeleteFilesRequest;
      (function(WillDeleteFilesRequest2) {
        WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
        WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
      })(WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
  var require_protocol_moniker2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
      var messages_1 = require_messages4();
      var UniquenessLevel;
      (function(UniquenessLevel2) {
        UniquenessLevel2.document = "document";
        UniquenessLevel2.project = "project";
        UniquenessLevel2.group = "group";
        UniquenessLevel2.scheme = "scheme";
        UniquenessLevel2.global = "global";
      })(UniquenessLevel || (exports2.UniquenessLevel = UniquenessLevel = {}));
      var MonikerKind;
      (function(MonikerKind2) {
        MonikerKind2.$import = "import";
        MonikerKind2.$export = "export";
        MonikerKind2.local = "local";
      })(MonikerKind || (exports2.MonikerKind = MonikerKind = {}));
      var MonikerRequest;
      (function(MonikerRequest2) {
        MonikerRequest2.method = "textDocument/moniker";
        MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
      })(MonikerRequest || (exports2.MonikerRequest = MonikerRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
  var require_protocol_typeHierarchy2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages4();
      var TypeHierarchyPrepareRequest;
      (function(TypeHierarchyPrepareRequest2) {
        TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
        TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
      })(TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
      var TypeHierarchySupertypesRequest;
      (function(TypeHierarchySupertypesRequest2) {
        TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
        TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
      })(TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
      var TypeHierarchySubtypesRequest;
      (function(TypeHierarchySubtypesRequest2) {
        TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
        TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
      })(TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
  var require_protocol_inlineValue2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
      var messages_1 = require_messages4();
      var InlineValueRequest;
      (function(InlineValueRequest2) {
        InlineValueRequest2.method = "textDocument/inlineValue";
        InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
      })(InlineValueRequest || (exports2.InlineValueRequest = InlineValueRequest = {}));
      var InlineValueRefreshRequest;
      (function(InlineValueRefreshRequest2) {
        InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
        InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
      })(InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
  var require_protocol_inlayHint2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
      var messages_1 = require_messages4();
      var InlayHintRequest;
      (function(InlayHintRequest2) {
        InlayHintRequest2.method = "textDocument/inlayHint";
        InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
      })(InlayHintRequest || (exports2.InlayHintRequest = InlayHintRequest = {}));
      var InlayHintResolveRequest;
      (function(InlayHintResolveRequest2) {
        InlayHintResolveRequest2.method = "inlayHint/resolve";
        InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
      })(InlayHintResolveRequest || (exports2.InlayHintResolveRequest = InlayHintResolveRequest = {}));
      var InlayHintRefreshRequest;
      (function(InlayHintRefreshRequest2) {
        InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
        InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
      })(InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
  var require_protocol_diagnostic2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
      var vscode_jsonrpc_1 = require_main4();
      var Is3 = require_is5();
      var messages_1 = require_messages4();
      var DiagnosticServerCancellationData;
      (function(DiagnosticServerCancellationData2) {
        function is(value) {
          const candidate = value;
          return candidate && Is3.boolean(candidate.retriggerRequest);
        }
        DiagnosticServerCancellationData2.is = is;
      })(DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
      var DocumentDiagnosticReportKind;
      (function(DocumentDiagnosticReportKind2) {
        DocumentDiagnosticReportKind2.Full = "full";
        DocumentDiagnosticReportKind2.Unchanged = "unchanged";
      })(DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
      var DocumentDiagnosticRequest;
      (function(DocumentDiagnosticRequest2) {
        DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
        DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
        DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
      var WorkspaceDiagnosticRequest;
      (function(WorkspaceDiagnosticRequest2) {
        WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
        WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
        WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
      var DiagnosticRefreshRequest;
      (function(DiagnosticRefreshRequest2) {
        DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
        DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
      })(DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
  var require_protocol_notebook2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
      var vscode_languageserver_types_1 = (init_main2(), __toCommonJS(main_exports2));
      var Is3 = require_is5();
      var messages_1 = require_messages4();
      var NotebookCellKind;
      (function(NotebookCellKind2) {
        NotebookCellKind2.Markup = 1;
        NotebookCellKind2.Code = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        NotebookCellKind2.is = is;
      })(NotebookCellKind || (exports2.NotebookCellKind = NotebookCellKind = {}));
      var ExecutionSummary;
      (function(ExecutionSummary2) {
        function create(executionOrder, success) {
          const result = { executionOrder };
          if (success === true || success === false) {
            result.success = success;
          }
          return result;
        }
        ExecutionSummary2.create = create;
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is3.boolean(candidate.success));
        }
        ExecutionSummary2.is = is;
        function equals(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          return one.executionOrder === other.executionOrder && one.success === other.success;
        }
        ExecutionSummary2.equals = equals;
      })(ExecutionSummary || (exports2.ExecutionSummary = ExecutionSummary = {}));
      var NotebookCell;
      (function(NotebookCell2) {
        function create(kind, document) {
          return { kind, document };
        }
        NotebookCell2.create = create;
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is3.objectLiteral(candidate.metadata));
        }
        NotebookCell2.is = is;
        function diff(one, two) {
          const result = /* @__PURE__ */ new Set();
          if (one.document !== two.document) {
            result.add("document");
          }
          if (one.kind !== two.kind) {
            result.add("kind");
          }
          if (one.executionSummary !== two.executionSummary) {
            result.add("executionSummary");
          }
          if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add("metadata");
          }
          if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add("executionSummary");
          }
          return result;
        }
        NotebookCell2.diff = diff;
        function equalsMetadata(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          if (typeof one !== typeof other) {
            return false;
          }
          if (typeof one !== "object") {
            return false;
          }
          const oneArray = Array.isArray(one);
          const otherArray = Array.isArray(other);
          if (oneArray !== otherArray) {
            return false;
          }
          if (oneArray && otherArray) {
            if (one.length !== other.length) {
              return false;
            }
            for (let i = 0; i < one.length; i++) {
              if (!equalsMetadata(one[i], other[i])) {
                return false;
              }
            }
          }
          if (Is3.objectLiteral(one) && Is3.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
              return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
              return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
              const prop = oneKeys[i];
              if (!equalsMetadata(one[prop], other[prop])) {
                return false;
              }
            }
          }
          return true;
        }
      })(NotebookCell || (exports2.NotebookCell = NotebookCell = {}));
      var NotebookDocument;
      (function(NotebookDocument2) {
        function create(uri, notebookType, version, cells) {
          return { uri, notebookType, version, cells };
        }
        NotebookDocument2.create = create;
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && Is3.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is3.typedArray(candidate.cells, NotebookCell.is);
        }
        NotebookDocument2.is = is;
      })(NotebookDocument || (exports2.NotebookDocument = NotebookDocument = {}));
      var NotebookDocumentSyncRegistrationType;
      (function(NotebookDocumentSyncRegistrationType2) {
        NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
        NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
        NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
      })(NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
      var DidOpenNotebookDocumentNotification;
      (function(DidOpenNotebookDocumentNotification2) {
        DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
        DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
        DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
      var NotebookCellArrayChange;
      (function(NotebookCellArrayChange2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is3.typedArray(candidate.cells, NotebookCell.is));
        }
        NotebookCellArrayChange2.is = is;
        function create(start, deleteCount, cells) {
          const result = { start, deleteCount };
          if (cells !== void 0) {
            result.cells = cells;
          }
          return result;
        }
        NotebookCellArrayChange2.create = create;
      })(NotebookCellArrayChange || (exports2.NotebookCellArrayChange = NotebookCellArrayChange = {}));
      var DidChangeNotebookDocumentNotification;
      (function(DidChangeNotebookDocumentNotification2) {
        DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
        DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
        DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
      var DidSaveNotebookDocumentNotification;
      (function(DidSaveNotebookDocumentNotification2) {
        DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
        DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
        DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
      var DidCloseNotebookDocumentNotification;
      (function(DidCloseNotebookDocumentNotification2) {
        DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
        DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
        DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
  var require_protocol_inlineCompletion2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineCompletionRequest = void 0;
      var messages_1 = require_messages4();
      var InlineCompletionRequest;
      (function(InlineCompletionRequest2) {
        InlineCompletionRequest2.method = "textDocument/inlineCompletion";
        InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
      })(InlineCompletionRequest || (exports2.InlineCompletionRequest = InlineCompletionRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.js
  var require_protocol2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
      exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangesFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
      exports2.InlineCompletionRequest = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages4();
      var vscode_languageserver_types_1 = (init_main2(), __toCommonJS(main_exports2));
      var Is3 = require_is5();
      var protocol_implementation_1 = require_protocol_implementation2();
      Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
        return protocol_implementation_1.ImplementationRequest;
      } });
      var protocol_typeDefinition_1 = require_protocol_typeDefinition2();
      Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
        return protocol_typeDefinition_1.TypeDefinitionRequest;
      } });
      var protocol_workspaceFolder_1 = require_protocol_workspaceFolder2();
      Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
      } });
      Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
      } });
      var protocol_configuration_1 = require_protocol_configuration2();
      Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
        return protocol_configuration_1.ConfigurationRequest;
      } });
      var protocol_colorProvider_1 = require_protocol_colorProvider2();
      Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.DocumentColorRequest;
      } });
      Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.ColorPresentationRequest;
      } });
      var protocol_foldingRange_1 = require_protocol_foldingRange2();
      Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
        return protocol_foldingRange_1.FoldingRangeRequest;
      } });
      Object.defineProperty(exports2, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
        return protocol_foldingRange_1.FoldingRangeRefreshRequest;
      } });
      var protocol_declaration_1 = require_protocol_declaration2();
      Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
        return protocol_declaration_1.DeclarationRequest;
      } });
      var protocol_selectionRange_1 = require_protocol_selectionRange2();
      Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
        return protocol_selectionRange_1.SelectionRangeRequest;
      } });
      var protocol_progress_1 = require_protocol_progress2();
      Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgress;
      } });
      Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCreateRequest;
      } });
      Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCancelNotification;
      } });
      var protocol_callHierarchy_1 = require_protocol_callHierarchy2();
      Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
      } });
      Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
      } });
      Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
      } });
      var protocol_semanticTokens_1 = require_protocol_semanticTokens2();
      Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.TokenFormat;
      } });
      Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
      } });
      var protocol_showDocument_1 = require_protocol_showDocument2();
      Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
        return protocol_showDocument_1.ShowDocumentRequest;
      } });
      var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange2();
      Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
      } });
      var protocol_fileOperations_1 = require_protocol_fileOperations2();
      Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
        return protocol_fileOperations_1.FileOperationPatternKind;
      } });
      Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidCreateFilesNotification;
      } });
      Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillCreateFilesRequest;
      } });
      Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidRenameFilesNotification;
      } });
      Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillRenameFilesRequest;
      } });
      Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidDeleteFilesNotification;
      } });
      Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillDeleteFilesRequest;
      } });
      var protocol_moniker_1 = require_protocol_moniker2();
      Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
        return protocol_moniker_1.UniquenessLevel;
      } });
      Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerKind;
      } });
      Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerRequest;
      } });
      var protocol_typeHierarchy_1 = require_protocol_typeHierarchy2();
      Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
      } });
      Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
      } });
      Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
      } });
      var protocol_inlineValue_1 = require_protocol_inlineValue2();
      Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRequest;
      } });
      Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRefreshRequest;
      } });
      var protocol_inlayHint_1 = require_protocol_inlayHint2();
      Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRequest;
      } });
      Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintResolveRequest;
      } });
      Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRefreshRequest;
      } });
      var protocol_diagnostic_1 = require_protocol_diagnostic2();
      Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticServerCancellationData;
      } });
      Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
      } });
      Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticRequest;
      } });
      Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
      } });
      Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticRefreshRequest;
      } });
      var protocol_notebook_1 = require_protocol_notebook2();
      Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellKind;
      } });
      Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
        return protocol_notebook_1.ExecutionSummary;
      } });
      Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCell;
      } });
      Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocument;
      } });
      Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
      } });
      Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellArrayChange;
      } });
      Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
      } });
      var protocol_inlineCompletion_1 = require_protocol_inlineCompletion2();
      Object.defineProperty(exports2, "InlineCompletionRequest", { enumerable: true, get: function() {
        return protocol_inlineCompletion_1.InlineCompletionRequest;
      } });
      var TextDocumentFilter;
      (function(TextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is3.string(candidate) || (Is3.string(candidate.language) || Is3.string(candidate.scheme) || Is3.string(candidate.pattern));
        }
        TextDocumentFilter2.is = is;
      })(TextDocumentFilter || (exports2.TextDocumentFilter = TextDocumentFilter = {}));
      var NotebookDocumentFilter;
      (function(NotebookDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (Is3.string(candidate.notebookType) || Is3.string(candidate.scheme) || Is3.string(candidate.pattern));
        }
        NotebookDocumentFilter2.is = is;
      })(NotebookDocumentFilter || (exports2.NotebookDocumentFilter = NotebookDocumentFilter = {}));
      var NotebookCellTextDocumentFilter;
      (function(NotebookCellTextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (Is3.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is3.string(candidate.language));
        }
        NotebookCellTextDocumentFilter2.is = is;
      })(NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
      var DocumentSelector;
      (function(DocumentSelector2) {
        function is(value) {
          if (!Array.isArray(value)) {
            return false;
          }
          for (let elem of value) {
            if (!Is3.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
              return false;
            }
          }
          return true;
        }
        DocumentSelector2.is = is;
      })(DocumentSelector || (exports2.DocumentSelector = DocumentSelector = {}));
      var RegistrationRequest;
      (function(RegistrationRequest2) {
        RegistrationRequest2.method = "client/registerCapability";
        RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
      })(RegistrationRequest || (exports2.RegistrationRequest = RegistrationRequest = {}));
      var UnregistrationRequest;
      (function(UnregistrationRequest2) {
        UnregistrationRequest2.method = "client/unregisterCapability";
        UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
      })(UnregistrationRequest || (exports2.UnregistrationRequest = UnregistrationRequest = {}));
      var ResourceOperationKind;
      (function(ResourceOperationKind2) {
        ResourceOperationKind2.Create = "create";
        ResourceOperationKind2.Rename = "rename";
        ResourceOperationKind2.Delete = "delete";
      })(ResourceOperationKind || (exports2.ResourceOperationKind = ResourceOperationKind = {}));
      var FailureHandlingKind;
      (function(FailureHandlingKind2) {
        FailureHandlingKind2.Abort = "abort";
        FailureHandlingKind2.Transactional = "transactional";
        FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
        FailureHandlingKind2.Undo = "undo";
      })(FailureHandlingKind || (exports2.FailureHandlingKind = FailureHandlingKind = {}));
      var PositionEncodingKind;
      (function(PositionEncodingKind2) {
        PositionEncodingKind2.UTF8 = "utf-8";
        PositionEncodingKind2.UTF16 = "utf-16";
        PositionEncodingKind2.UTF32 = "utf-32";
      })(PositionEncodingKind || (exports2.PositionEncodingKind = PositionEncodingKind = {}));
      var StaticRegistrationOptions;
      (function(StaticRegistrationOptions2) {
        function hasId(value) {
          const candidate = value;
          return candidate && Is3.string(candidate.id) && candidate.id.length > 0;
        }
        StaticRegistrationOptions2.hasId = hasId;
      })(StaticRegistrationOptions || (exports2.StaticRegistrationOptions = StaticRegistrationOptions = {}));
      var TextDocumentRegistrationOptions;
      (function(TextDocumentRegistrationOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
        }
        TextDocumentRegistrationOptions2.is = is;
      })(TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
      var WorkDoneProgressOptions;
      (function(WorkDoneProgressOptions2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is3.boolean(candidate.workDoneProgress));
        }
        WorkDoneProgressOptions2.is = is;
        function hasWorkDoneProgress(value) {
          const candidate = value;
          return candidate && Is3.boolean(candidate.workDoneProgress);
        }
        WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
      })(WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
      var InitializeRequest;
      (function(InitializeRequest2) {
        InitializeRequest2.method = "initialize";
        InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
      })(InitializeRequest || (exports2.InitializeRequest = InitializeRequest = {}));
      var InitializeErrorCodes;
      (function(InitializeErrorCodes2) {
        InitializeErrorCodes2.unknownProtocolVersion = 1;
      })(InitializeErrorCodes || (exports2.InitializeErrorCodes = InitializeErrorCodes = {}));
      var InitializedNotification;
      (function(InitializedNotification2) {
        InitializedNotification2.method = "initialized";
        InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
      })(InitializedNotification || (exports2.InitializedNotification = InitializedNotification = {}));
      var ShutdownRequest;
      (function(ShutdownRequest2) {
        ShutdownRequest2.method = "shutdown";
        ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
      })(ShutdownRequest || (exports2.ShutdownRequest = ShutdownRequest = {}));
      var ExitNotification;
      (function(ExitNotification2) {
        ExitNotification2.method = "exit";
        ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
      })(ExitNotification || (exports2.ExitNotification = ExitNotification = {}));
      var DidChangeConfigurationNotification2;
      (function(DidChangeConfigurationNotification3) {
        DidChangeConfigurationNotification3.method = "workspace/didChangeConfiguration";
        DidChangeConfigurationNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeConfigurationNotification3.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification3.method);
      })(DidChangeConfigurationNotification2 || (exports2.DidChangeConfigurationNotification = DidChangeConfigurationNotification2 = {}));
      var MessageType;
      (function(MessageType2) {
        MessageType2.Error = 1;
        MessageType2.Warning = 2;
        MessageType2.Info = 3;
        MessageType2.Log = 4;
        MessageType2.Debug = 5;
      })(MessageType || (exports2.MessageType = MessageType = {}));
      var ShowMessageNotification;
      (function(ShowMessageNotification2) {
        ShowMessageNotification2.method = "window/showMessage";
        ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
      })(ShowMessageNotification || (exports2.ShowMessageNotification = ShowMessageNotification = {}));
      var ShowMessageRequest;
      (function(ShowMessageRequest2) {
        ShowMessageRequest2.method = "window/showMessageRequest";
        ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
      })(ShowMessageRequest || (exports2.ShowMessageRequest = ShowMessageRequest = {}));
      var LogMessageNotification;
      (function(LogMessageNotification2) {
        LogMessageNotification2.method = "window/logMessage";
        LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
      })(LogMessageNotification || (exports2.LogMessageNotification = LogMessageNotification = {}));
      var TelemetryEventNotification;
      (function(TelemetryEventNotification2) {
        TelemetryEventNotification2.method = "telemetry/event";
        TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
      })(TelemetryEventNotification || (exports2.TelemetryEventNotification = TelemetryEventNotification = {}));
      var TextDocumentSyncKind2;
      (function(TextDocumentSyncKind3) {
        TextDocumentSyncKind3.None = 0;
        TextDocumentSyncKind3.Full = 1;
        TextDocumentSyncKind3.Incremental = 2;
      })(TextDocumentSyncKind2 || (exports2.TextDocumentSyncKind = TextDocumentSyncKind2 = {}));
      var DidOpenTextDocumentNotification;
      (function(DidOpenTextDocumentNotification2) {
        DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
        DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
      })(DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
      var TextDocumentContentChangeEvent;
      (function(TextDocumentContentChangeEvent2) {
        function isIncremental(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
        }
        TextDocumentContentChangeEvent2.isIncremental = isIncremental;
        function isFull(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
        }
        TextDocumentContentChangeEvent2.isFull = isFull;
      })(TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
      var DidChangeTextDocumentNotification;
      (function(DidChangeTextDocumentNotification2) {
        DidChangeTextDocumentNotification2.method = "textDocument/didChange";
        DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
      })(DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
      var DidCloseTextDocumentNotification;
      (function(DidCloseTextDocumentNotification2) {
        DidCloseTextDocumentNotification2.method = "textDocument/didClose";
        DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
      })(DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
      var DidSaveTextDocumentNotification;
      (function(DidSaveTextDocumentNotification2) {
        DidSaveTextDocumentNotification2.method = "textDocument/didSave";
        DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
      })(DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
      var TextDocumentSaveReason;
      (function(TextDocumentSaveReason2) {
        TextDocumentSaveReason2.Manual = 1;
        TextDocumentSaveReason2.AfterDelay = 2;
        TextDocumentSaveReason2.FocusOut = 3;
      })(TextDocumentSaveReason || (exports2.TextDocumentSaveReason = TextDocumentSaveReason = {}));
      var WillSaveTextDocumentNotification;
      (function(WillSaveTextDocumentNotification2) {
        WillSaveTextDocumentNotification2.method = "textDocument/willSave";
        WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
      })(WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
      var WillSaveTextDocumentWaitUntilRequest;
      (function(WillSaveTextDocumentWaitUntilRequest2) {
        WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
        WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
      })(WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
      var DidChangeWatchedFilesNotification2;
      (function(DidChangeWatchedFilesNotification3) {
        DidChangeWatchedFilesNotification3.method = "workspace/didChangeWatchedFiles";
        DidChangeWatchedFilesNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeWatchedFilesNotification3.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification3.method);
      })(DidChangeWatchedFilesNotification2 || (exports2.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification2 = {}));
      var FileChangeType2;
      (function(FileChangeType3) {
        FileChangeType3.Created = 1;
        FileChangeType3.Changed = 2;
        FileChangeType3.Deleted = 3;
      })(FileChangeType2 || (exports2.FileChangeType = FileChangeType2 = {}));
      var RelativePattern;
      (function(RelativePattern2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is3.string(candidate.pattern);
        }
        RelativePattern2.is = is;
      })(RelativePattern || (exports2.RelativePattern = RelativePattern = {}));
      var WatchKind;
      (function(WatchKind2) {
        WatchKind2.Create = 1;
        WatchKind2.Change = 2;
        WatchKind2.Delete = 4;
      })(WatchKind || (exports2.WatchKind = WatchKind = {}));
      var PublishDiagnosticsNotification;
      (function(PublishDiagnosticsNotification2) {
        PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
        PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
      })(PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
      var CompletionTriggerKind;
      (function(CompletionTriggerKind2) {
        CompletionTriggerKind2.Invoked = 1;
        CompletionTriggerKind2.TriggerCharacter = 2;
        CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
      })(CompletionTriggerKind || (exports2.CompletionTriggerKind = CompletionTriggerKind = {}));
      var CompletionRequest;
      (function(CompletionRequest2) {
        CompletionRequest2.method = "textDocument/completion";
        CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
      })(CompletionRequest || (exports2.CompletionRequest = CompletionRequest = {}));
      var CompletionResolveRequest;
      (function(CompletionResolveRequest2) {
        CompletionResolveRequest2.method = "completionItem/resolve";
        CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
      })(CompletionResolveRequest || (exports2.CompletionResolveRequest = CompletionResolveRequest = {}));
      var HoverRequest;
      (function(HoverRequest2) {
        HoverRequest2.method = "textDocument/hover";
        HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
      })(HoverRequest || (exports2.HoverRequest = HoverRequest = {}));
      var SignatureHelpTriggerKind;
      (function(SignatureHelpTriggerKind2) {
        SignatureHelpTriggerKind2.Invoked = 1;
        SignatureHelpTriggerKind2.TriggerCharacter = 2;
        SignatureHelpTriggerKind2.ContentChange = 3;
      })(SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
      var SignatureHelpRequest;
      (function(SignatureHelpRequest2) {
        SignatureHelpRequest2.method = "textDocument/signatureHelp";
        SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
      })(SignatureHelpRequest || (exports2.SignatureHelpRequest = SignatureHelpRequest = {}));
      var DefinitionRequest;
      (function(DefinitionRequest2) {
        DefinitionRequest2.method = "textDocument/definition";
        DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
      })(DefinitionRequest || (exports2.DefinitionRequest = DefinitionRequest = {}));
      var ReferencesRequest;
      (function(ReferencesRequest2) {
        ReferencesRequest2.method = "textDocument/references";
        ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
      })(ReferencesRequest || (exports2.ReferencesRequest = ReferencesRequest = {}));
      var DocumentHighlightRequest;
      (function(DocumentHighlightRequest2) {
        DocumentHighlightRequest2.method = "textDocument/documentHighlight";
        DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
      })(DocumentHighlightRequest || (exports2.DocumentHighlightRequest = DocumentHighlightRequest = {}));
      var DocumentSymbolRequest;
      (function(DocumentSymbolRequest2) {
        DocumentSymbolRequest2.method = "textDocument/documentSymbol";
        DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
      })(DocumentSymbolRequest || (exports2.DocumentSymbolRequest = DocumentSymbolRequest = {}));
      var CodeActionRequest;
      (function(CodeActionRequest2) {
        CodeActionRequest2.method = "textDocument/codeAction";
        CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
      })(CodeActionRequest || (exports2.CodeActionRequest = CodeActionRequest = {}));
      var CodeActionResolveRequest;
      (function(CodeActionResolveRequest2) {
        CodeActionResolveRequest2.method = "codeAction/resolve";
        CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
      })(CodeActionResolveRequest || (exports2.CodeActionResolveRequest = CodeActionResolveRequest = {}));
      var WorkspaceSymbolRequest;
      (function(WorkspaceSymbolRequest2) {
        WorkspaceSymbolRequest2.method = "workspace/symbol";
        WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
      })(WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
      var WorkspaceSymbolResolveRequest;
      (function(WorkspaceSymbolResolveRequest2) {
        WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
        WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
      })(WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
      var CodeLensRequest;
      (function(CodeLensRequest2) {
        CodeLensRequest2.method = "textDocument/codeLens";
        CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
      })(CodeLensRequest || (exports2.CodeLensRequest = CodeLensRequest = {}));
      var CodeLensResolveRequest;
      (function(CodeLensResolveRequest2) {
        CodeLensResolveRequest2.method = "codeLens/resolve";
        CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
      })(CodeLensResolveRequest || (exports2.CodeLensResolveRequest = CodeLensResolveRequest = {}));
      var CodeLensRefreshRequest;
      (function(CodeLensRefreshRequest2) {
        CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
        CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
      })(CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
      var DocumentLinkRequest;
      (function(DocumentLinkRequest2) {
        DocumentLinkRequest2.method = "textDocument/documentLink";
        DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
      })(DocumentLinkRequest || (exports2.DocumentLinkRequest = DocumentLinkRequest = {}));
      var DocumentLinkResolveRequest;
      (function(DocumentLinkResolveRequest2) {
        DocumentLinkResolveRequest2.method = "documentLink/resolve";
        DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
      })(DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
      var DocumentFormattingRequest;
      (function(DocumentFormattingRequest2) {
        DocumentFormattingRequest2.method = "textDocument/formatting";
        DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
      })(DocumentFormattingRequest || (exports2.DocumentFormattingRequest = DocumentFormattingRequest = {}));
      var DocumentRangeFormattingRequest;
      (function(DocumentRangeFormattingRequest2) {
        DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
        DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
      })(DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
      var DocumentRangesFormattingRequest;
      (function(DocumentRangesFormattingRequest2) {
        DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
        DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
      })(DocumentRangesFormattingRequest || (exports2.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
      var DocumentOnTypeFormattingRequest;
      (function(DocumentOnTypeFormattingRequest2) {
        DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
        DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
      })(DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
      var PrepareSupportDefaultBehavior;
      (function(PrepareSupportDefaultBehavior2) {
        PrepareSupportDefaultBehavior2.Identifier = 1;
      })(PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
      var RenameRequest;
      (function(RenameRequest2) {
        RenameRequest2.method = "textDocument/rename";
        RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
      })(RenameRequest || (exports2.RenameRequest = RenameRequest = {}));
      var PrepareRenameRequest;
      (function(PrepareRenameRequest2) {
        PrepareRenameRequest2.method = "textDocument/prepareRename";
        PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
      })(PrepareRenameRequest || (exports2.PrepareRenameRequest = PrepareRenameRequest = {}));
      var ExecuteCommandRequest;
      (function(ExecuteCommandRequest2) {
        ExecuteCommandRequest2.method = "workspace/executeCommand";
        ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
      })(ExecuteCommandRequest || (exports2.ExecuteCommandRequest = ExecuteCommandRequest = {}));
      var ApplyWorkspaceEditRequest;
      (function(ApplyWorkspaceEditRequest2) {
        ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
        ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
      })(ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/connection.js
  var require_connection4 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createProtocolConnection = void 0;
      var vscode_jsonrpc_1 = require_main4();
      function createProtocolConnection(input, output, logger, options) {
        if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
      }
      exports2.createProtocolConnection = createProtocolConnection;
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/api.js
  var require_api5 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
      __exportStar(require_main4(), exports2);
      __exportStar((init_main2(), __toCommonJS(main_exports2)), exports2);
      __exportStar(require_messages4(), exports2);
      __exportStar(require_protocol2(), exports2);
      var connection_1 = require_connection4();
      Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
        return connection_1.createProtocolConnection;
      } });
      var LSPErrorCodes2;
      (function(LSPErrorCodes3) {
        LSPErrorCodes3.lspReservedErrorRangeStart = -32899;
        LSPErrorCodes3.RequestFailed = -32803;
        LSPErrorCodes3.ServerCancelled = -32802;
        LSPErrorCodes3.ContentModified = -32801;
        LSPErrorCodes3.RequestCancelled = -32800;
        LSPErrorCodes3.lspReservedErrorRangeEnd = -32800;
      })(LSPErrorCodes2 || (exports2.LSPErrorCodes = LSPErrorCodes2 = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/browser/main.js
  var require_main5 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createProtocolConnection = void 0;
      var browser_1 = require_browser3();
      __exportStar(require_browser3(), exports2);
      __exportStar(require_api5(), exports2);
      function createProtocolConnection(reader, writer, logger, options) {
        return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports2.createProtocolConnection = createProtocolConnection;
    }
  });

  // node_modules/vscode-languageserver/lib/common/semanticTokens.js
  var require_semanticTokens2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var SemanticTokensFeature = (Base) => {
        return class extends Base {
          get semanticTokens() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
              },
              on: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onDelta: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onRange: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.SemanticTokensFeature = SemanticTokensFeature;
      var SemanticTokensDiff = class {
        constructor(originalSequence, modifiedSequence) {
          this.originalSequence = originalSequence;
          this.modifiedSequence = modifiedSequence;
        }
        computeDiff() {
          const originalLength = this.originalSequence.length;
          const modifiedLength = this.modifiedSequence.length;
          let startIndex = 0;
          while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
            startIndex++;
          }
          if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
              originalEndIndex--;
              modifiedEndIndex--;
            }
            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
              originalEndIndex++;
              modifiedEndIndex++;
            }
            const deleteCount = originalEndIndex - startIndex + 1;
            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
              return [
                { start: startIndex, deleteCount: deleteCount - 1 }
              ];
            } else {
              return [
                { start: startIndex, deleteCount, data: newData }
              ];
            }
          } else if (startIndex < modifiedLength) {
            return [
              { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
            ];
          } else if (startIndex < originalLength) {
            return [
              { start: startIndex, deleteCount: originalLength - startIndex }
            ];
          } else {
            return [];
          }
        }
      };
      exports2.SemanticTokensDiff = SemanticTokensDiff;
      var SemanticTokensBuilder2 = class {
        constructor() {
          this._prevData = void 0;
          this.initialize();
        }
        initialize() {
          this._id = Date.now();
          this._prevLine = 0;
          this._prevChar = 0;
          this._data = [];
          this._dataLen = 0;
        }
        push(line, char, length, tokenType, tokenModifiers) {
          let pushLine = line;
          let pushChar = char;
          if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
              pushChar -= this._prevChar;
            }
          }
          this._data[this._dataLen++] = pushLine;
          this._data[this._dataLen++] = pushChar;
          this._data[this._dataLen++] = length;
          this._data[this._dataLen++] = tokenType;
          this._data[this._dataLen++] = tokenModifiers;
          this._prevLine = line;
          this._prevChar = char;
        }
        get id() {
          return this._id.toString();
        }
        previousResult(id) {
          if (this.id === id) {
            this._prevData = this._data;
          }
          this.initialize();
        }
        build() {
          this._prevData = void 0;
          return {
            resultId: this.id,
            data: this._data
          };
        }
        canBuildEdits() {
          return this._prevData !== void 0;
        }
        buildEdits() {
          if (this._prevData !== void 0) {
            return {
              resultId: this.id,
              edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
            };
          } else {
            return this.build();
          }
        }
      };
      exports2.SemanticTokensBuilder = SemanticTokensBuilder2;
    }
  });

  // node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
  var require_inlineCompletion_proposed2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineCompletionFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var InlineCompletionFeature = (Base) => {
        return class extends Base {
          get inlineCompletion() {
            return {
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params));
                });
              }
            };
          }
        };
      };
      exports2.InlineCompletionFeature = InlineCompletionFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/textDocuments.js
  var require_textDocuments2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TextDocuments = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var TextDocuments2 = class {
        /**
         * Create a new text document manager.
         */
        constructor(configuration) {
          this._configuration = configuration;
          this._syncedDocuments = /* @__PURE__ */ new Map();
          this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
          this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
          this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
          this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
          this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been opened.
         */
        get onDidOpen() {
          return this._onDidOpen.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been opened or the content changes.
         */
        get onDidChangeContent() {
          return this._onDidChangeContent.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * will be saved.
         */
        get onWillSave() {
          return this._onWillSave.event;
        }
        /**
         * Sets a handler that will be called if a participant wants to provide
         * edits during a text document save.
         */
        onWillSaveWaitUntil(handler) {
          this._willSaveWaitUntil = handler;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been saved.
         */
        get onDidSave() {
          return this._onDidSave.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been closed.
         */
        get onDidClose() {
          return this._onDidClose.event;
        }
        /**
         * Returns the document for the given URI. Returns undefined if
         * the document is not managed by this instance.
         *
         * @param uri The text document's URI to retrieve.
         * @return the text document or `undefined`.
         */
        get(uri) {
          return this._syncedDocuments.get(uri);
        }
        /**
         * Returns all text documents managed by this instance.
         *
         * @return all text documents.
         */
        all() {
          return Array.from(this._syncedDocuments.values());
        }
        /**
         * Returns the URIs of all text documents managed by this instance.
         *
         * @return the URI's of all text documents.
         */
        keys() {
          return Array.from(this._syncedDocuments.keys());
        }
        /**
         * Listens for `low level` notification on the given connection to
         * update the text documents managed by this instance.
         *
         * Please note that the connection only provides handlers not an event model. Therefore
         * listening on a connection will overwrite the following handlers on a connection:
         * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
         * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
         *
         * Use the corresponding events on the TextDocuments instance instead.
         *
         * @param connection The connection to listen on.
         */
        listen(connection2) {
          connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
          const disposables = [];
          disposables.push(connection2.onDidOpenTextDocument((event) => {
            const td = event.textDocument;
            const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
            this._syncedDocuments.set(td.uri, document);
            const toFire = Object.freeze({ document });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
          }));
          disposables.push(connection2.onDidChangeTextDocument((event) => {
            const td = event.textDocument;
            const changes = event.contentChanges;
            if (changes.length === 0) {
              return;
            }
            const { version } = td;
            if (version === null || version === void 0) {
              throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
            }
            let syncedDocument = this._syncedDocuments.get(td.uri);
            if (syncedDocument !== void 0) {
              syncedDocument = this._configuration.update(syncedDocument, changes, version);
              this._syncedDocuments.set(td.uri, syncedDocument);
              this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          disposables.push(connection2.onDidCloseTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._syncedDocuments.delete(event.textDocument.uri);
              this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          disposables.push(connection2.onWillSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
            }
          }));
          disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
              return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
            } else {
              return [];
            }
          }));
          disposables.push(connection2.onDidSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            disposables.forEach((disposable) => disposable.dispose());
          });
        }
      };
      exports2.TextDocuments = TextDocuments2;
    }
  });

  // node_modules/vscode-languageserver/lib/common/notebook.js
  var require_notebook2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var textDocuments_1 = require_textDocuments2();
      var NotebookSyncFeature = (Base) => {
        return class extends Base {
          get synchronization() {
            return {
              onDidOpenNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidChangeNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidSaveNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidCloseNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              }
            };
          }
        };
      };
      exports2.NotebookSyncFeature = NotebookSyncFeature;
      var CellTextDocumentConnection = class _CellTextDocumentConnection {
        onDidOpenTextDocument(handler) {
          this.openHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.openHandler = void 0;
          });
        }
        openTextDocument(params) {
          this.openHandler && this.openHandler(params);
        }
        onDidChangeTextDocument(handler) {
          this.changeHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.changeHandler = handler;
          });
        }
        changeTextDocument(params) {
          this.changeHandler && this.changeHandler(params);
        }
        onDidCloseTextDocument(handler) {
          this.closeHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.closeHandler = void 0;
          });
        }
        closeTextDocument(params) {
          this.closeHandler && this.closeHandler(params);
        }
        onWillSaveTextDocument() {
          return _CellTextDocumentConnection.NULL_DISPOSE;
        }
        onWillSaveTextDocumentWaitUntil() {
          return _CellTextDocumentConnection.NULL_DISPOSE;
        }
        onDidSaveTextDocument() {
          return _CellTextDocumentConnection.NULL_DISPOSE;
        }
      };
      CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
      } });
      var NotebookDocuments = class {
        constructor(configurationOrTextDocuments) {
          if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
            this._cellTextDocuments = configurationOrTextDocuments;
          } else {
            this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
          }
          this.notebookDocuments = /* @__PURE__ */ new Map();
          this.notebookCellMap = /* @__PURE__ */ new Map();
          this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
          this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
          this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
          this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        }
        get cellTextDocuments() {
          return this._cellTextDocuments;
        }
        getCellTextDocument(cell) {
          return this._cellTextDocuments.get(cell.document);
        }
        getNotebookDocument(uri) {
          return this.notebookDocuments.get(uri);
        }
        getNotebookCell(uri) {
          const value = this.notebookCellMap.get(uri);
          return value && value[0];
        }
        findNotebookDocumentForCell(cell) {
          const key = typeof cell === "string" ? cell : cell.document;
          const value = this.notebookCellMap.get(key);
          return value && value[1];
        }
        get onDidOpen() {
          return this._onDidOpen.event;
        }
        get onDidSave() {
          return this._onDidSave.event;
        }
        get onDidChange() {
          return this._onDidChange.event;
        }
        get onDidClose() {
          return this._onDidClose.event;
        }
        /**
         * Listens for `low level` notification on the given connection to
         * update the notebook documents managed by this instance.
         *
         * Please note that the connection only provides handlers not an event model. Therefore
         * listening on a connection will overwrite the following handlers on a connection:
         * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
         *  and `onDidCloseNotebookDocument`.
         *
         * @param connection The connection to listen on.
         */
        listen(connection2) {
          const cellTextDocumentConnection = new CellTextDocumentConnection();
          const disposables = [];
          disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
          disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
            this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
              cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
            }
            this.updateCellMap(params.notebookDocument);
            this._onDidOpen.fire(params.notebookDocument);
          }));
          disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            notebookDocument.version = params.notebookDocument.version;
            const oldMetadata = notebookDocument.metadata;
            let metadataChanged = false;
            const change = params.change;
            if (change.metadata !== void 0) {
              metadataChanged = true;
              notebookDocument.metadata = change.metadata;
            }
            const opened = [];
            const closed = [];
            const data = [];
            const text = [];
            if (change.cells !== void 0) {
              const changedCells = change.cells;
              if (changedCells.structure !== void 0) {
                const array = changedCells.structure.array;
                notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
                if (changedCells.structure.didOpen !== void 0) {
                  for (const open of changedCells.structure.didOpen) {
                    cellTextDocumentConnection.openTextDocument({ textDocument: open });
                    opened.push(open.uri);
                  }
                }
                if (changedCells.structure.didClose) {
                  for (const close of changedCells.structure.didClose) {
                    cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                    closed.push(close.uri);
                  }
                }
              }
              if (changedCells.data !== void 0) {
                const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
                for (let i = 0; i <= notebookDocument.cells.length; i++) {
                  const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                  if (change2 !== void 0) {
                    const old = notebookDocument.cells.splice(i, 1, change2);
                    data.push({ old: old[0], new: change2 });
                    cellUpdates.delete(change2.document);
                    if (cellUpdates.size === 0) {
                      break;
                    }
                  }
                }
              }
              if (changedCells.textContent !== void 0) {
                for (const cellTextDocument of changedCells.textContent) {
                  cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                  text.push(cellTextDocument.document.uri);
                }
              }
            }
            this.updateCellMap(notebookDocument);
            const changeEvent = { notebookDocument };
            if (metadataChanged) {
              changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
            }
            const added = [];
            for (const open of opened) {
              added.push(this.getNotebookCell(open));
            }
            const removed = [];
            for (const close of closed) {
              removed.push(this.getNotebookCell(close));
            }
            const textContent = [];
            for (const change2 of text) {
              textContent.push(this.getNotebookCell(change2));
            }
            if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
              changeEvent.cells = { added, removed, changed: { data, textContent } };
            }
            if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
              this._onDidChange.fire(changeEvent);
            }
          }));
          disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            this._onDidSave.fire(notebookDocument);
          }));
          disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            this._onDidClose.fire(notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
              cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
            }
            this.notebookDocuments.delete(params.notebookDocument.uri);
            for (const cell of notebookDocument.cells) {
              this.notebookCellMap.delete(cell.document);
            }
          }));
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            disposables.forEach((disposable) => disposable.dispose());
          });
        }
        updateCellMap(notebookDocument) {
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
          }
        }
      };
      exports2.NotebookDocuments = NotebookDocuments;
    }
  });

  // node_modules/vscode-languageserver/lib/common/utils/is.js
  var require_is6 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports2.typedArray = typedArray;
      function thenable(value) {
        return value && func(value.then);
      }
      exports2.thenable = thenable;
    }
  });

  // node_modules/vscode-languageserver/lib/common/utils/uuid.js
  var require_uuid2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
      var ValueUUID = class {
        constructor(_value) {
          this._value = _value;
        }
        asHex() {
          return this._value;
        }
        equals(other) {
          return this.asHex() === other.asHex();
        }
      };
      var V4UUID = class _V4UUID extends ValueUUID {
        static _oneOf(array) {
          return array[Math.floor(array.length * Math.random())];
        }
        static _randomHex() {
          return _V4UUID._oneOf(_V4UUID._chars);
        }
        constructor() {
          super([
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            "4",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._oneOf(_V4UUID._timeHighBits),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex()
          ].join(""));
        }
      };
      V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      V4UUID._timeHighBits = ["8", "9", "a", "b"];
      exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
      function v4() {
        return new V4UUID();
      }
      exports2.v4 = v4;
      var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      function isUUID(value) {
        return _UUIDPattern.test(value);
      }
      exports2.isUUID = isUUID;
      function parse(value) {
        if (!isUUID(value)) {
          throw new Error("invalid uuid");
        }
        return new ValueUUID(value);
      }
      exports2.parse = parse;
      function generateUuid() {
        return v4().asHex();
      }
      exports2.generateUuid = generateUuid;
    }
  });

  // node_modules/vscode-languageserver/lib/common/progress.js
  var require_progress2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var uuid_1 = require_uuid2();
      var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
        constructor(_connection, _token) {
          this._connection = _connection;
          this._token = _token;
          _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
        }
        begin(title, percentage, message, cancellable) {
          let param = {
            kind: "begin",
            title,
            percentage,
            message,
            cancellable
          };
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
        }
        report(arg0, arg1) {
          let param = {
            kind: "report"
          };
          if (typeof arg0 === "number") {
            param.percentage = arg0;
            if (arg1 !== void 0) {
              param.message = arg1;
            }
          } else {
            param.message = arg0;
          }
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
        }
        done() {
          _WorkDoneProgressReporterImpl.Instances.delete(this._token);
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
        }
      };
      WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
      var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
        constructor(connection2, token) {
          super(connection2, token);
          this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        }
        get token() {
          return this._source.token;
        }
        done() {
          this._source.dispose();
          super.done();
        }
        cancel() {
          this._source.cancel();
        }
      };
      var NullProgressReporter = class {
        constructor() {
        }
        begin() {
        }
        report() {
        }
        done() {
        }
      };
      var NullProgressServerReporter = class extends NullProgressReporter {
        constructor() {
          super();
          this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        }
        get token() {
          return this._source.token;
        }
        done() {
          this._source.dispose();
        }
        cancel() {
          this._source.cancel();
        }
      };
      function attachWorkDone(connection2, params) {
        if (params === void 0 || params.workDoneToken === void 0) {
          return new NullProgressReporter();
        }
        const token = params.workDoneToken;
        delete params.workDoneToken;
        return new WorkDoneProgressReporterImpl(connection2, token);
      }
      exports2.attachWorkDone = attachWorkDone;
      var ProgressFeature = (Base) => {
        return class extends Base {
          constructor() {
            super();
            this._progressSupported = false;
          }
          initialize(capabilities) {
            super.initialize(capabilities);
            if (capabilities?.window?.workDoneProgress === true) {
              this._progressSupported = true;
              this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
                let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
                if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                  progress.cancel();
                }
              });
            }
          }
          attachWorkDoneProgress(token) {
            if (token === void 0) {
              return new NullProgressReporter();
            } else {
              return new WorkDoneProgressReporterImpl(this.connection, token);
            }
          }
          createWorkDoneProgress() {
            if (this._progressSupported) {
              const token = (0, uuid_1.generateUuid)();
              return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
                return result;
              });
            } else {
              return Promise.resolve(new NullProgressServerReporter());
            }
          }
        };
      };
      exports2.ProgressFeature = ProgressFeature;
      var ResultProgress;
      (function(ResultProgress2) {
        ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
      })(ResultProgress || (ResultProgress = {}));
      var ResultProgressReporterImpl = class {
        constructor(_connection, _token) {
          this._connection = _connection;
          this._token = _token;
        }
        report(data) {
          this._connection.sendProgress(ResultProgress.type, this._token, data);
        }
      };
      function attachPartialResult(connection2, params) {
        if (params === void 0 || params.partialResultToken === void 0) {
          return void 0;
        }
        const token = params.partialResultToken;
        delete params.partialResultToken;
        return new ResultProgressReporterImpl(connection2, token);
      }
      exports2.attachPartialResult = attachPartialResult;
    }
  });

  // node_modules/vscode-languageserver/lib/common/configuration.js
  var require_configuration2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConfigurationFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var Is3 = require_is6();
      var ConfigurationFeature = (Base) => {
        return class extends Base {
          getConfiguration(arg) {
            if (!arg) {
              return this._getConfiguration({});
            } else if (Is3.string(arg)) {
              return this._getConfiguration({ section: arg });
            } else {
              return this._getConfiguration(arg);
            }
          }
          _getConfiguration(arg) {
            let params = {
              items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
              if (Array.isArray(result)) {
                return Array.isArray(arg) ? result : result[0];
              } else {
                return Array.isArray(arg) ? [] : null;
              }
            });
          }
        };
      };
      exports2.ConfigurationFeature = ConfigurationFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/workspaceFolder.js
  var require_workspaceFolder2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkspaceFoldersFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var WorkspaceFoldersFeature = (Base) => {
        return class extends Base {
          constructor() {
            super();
            this._notificationIsAutoRegistered = false;
          }
          initialize(capabilities) {
            super.initialize(capabilities);
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
              this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
              this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
                this._onDidChangeWorkspaceFolders.fire(params.event);
              });
            }
          }
          fillServerCapabilities(capabilities) {
            super.fillServerCapabilities(capabilities);
            const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
          }
          getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
          }
          get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
              throw new Error("Client doesn't support sending workspace folder change events.");
            }
            if (!this._notificationIsAutoRegistered && !this._unregistration) {
              this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
          }
        };
      };
      exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/callHierarchy.js
  var require_callHierarchy2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CallHierarchyFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var CallHierarchyFeature = (Base) => {
        return class extends Base {
          get callHierarchy() {
            return {
              onPrepare: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
                });
              },
              onIncomingCalls: (handler) => {
                const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onOutgoingCalls: (handler) => {
                const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.CallHierarchyFeature = CallHierarchyFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/showDocument.js
  var require_showDocument2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ShowDocumentFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var ShowDocumentFeature = (Base) => {
        return class extends Base {
          showDocument(params) {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
          }
        };
      };
      exports2.ShowDocumentFeature = ShowDocumentFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/fileOperations.js
  var require_fileOperations2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FileOperationsFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var FileOperationsFeature = (Base) => {
        return class extends Base {
          onDidCreateFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onDidRenameFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onDidDeleteFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onWillCreateFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
          onWillRenameFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
          onWillDeleteFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
        };
      };
      exports2.FileOperationsFeature = FileOperationsFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
  var require_linkedEditingRange2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LinkedEditingRangeFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var LinkedEditingRangeFeature = (Base) => {
        return class extends Base {
          onLinkedEditingRange(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
            });
          }
        };
      };
      exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/typeHierarchy.js
  var require_typeHierarchy2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeHierarchyFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var TypeHierarchyFeature = (Base) => {
        return class extends Base {
          get typeHierarchy() {
            return {
              onPrepare: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
                });
              },
              onSupertypes: (handler) => {
                const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onSubtypes: (handler) => {
                const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.TypeHierarchyFeature = TypeHierarchyFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/inlineValue.js
  var require_inlineValue2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineValueFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var InlineValueFeature = (Base) => {
        return class extends Base {
          get inlineValue() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params));
                });
              }
            };
          }
        };
      };
      exports2.InlineValueFeature = InlineValueFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/foldingRange.js
  var require_foldingRange2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/foldingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FoldingRangeFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var FoldingRangeFeature = (Base) => {
        return class extends Base {
          get foldingRange() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
              },
              on: (handler) => {
                const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.FoldingRangeFeature = FoldingRangeFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/inlayHint.js
  var require_inlayHint2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlayHintFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var InlayHintFeature = (Base) => {
        return class extends Base {
          get inlayHint() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params));
                });
              },
              resolve: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                  return handler(params, cancel);
                });
              }
            };
          }
        };
      };
      exports2.InlayHintFeature = InlayHintFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/diagnostic.js
  var require_diagnostic2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DiagnosticFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var DiagnosticFeature = (Base) => {
        return class extends Base {
          get diagnostics() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
                });
              },
              onWorkspace: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
                });
              }
            };
          }
        };
      };
      exports2.DiagnosticFeature = DiagnosticFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/moniker.js
  var require_moniker2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MonikerFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var MonikerFeature = (Base) => {
        return class extends Base {
          get moniker() {
            return {
              on: (handler) => {
                const type = vscode_languageserver_protocol_1.MonikerRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.MonikerFeature = MonikerFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/server.js
  var require_server2 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
      var vscode_languageserver_protocol_1 = require_main5();
      var Is3 = require_is6();
      var UUID = require_uuid2();
      var progress_1 = require_progress2();
      var configuration_1 = require_configuration2();
      var workspaceFolder_1 = require_workspaceFolder2();
      var callHierarchy_1 = require_callHierarchy2();
      var semanticTokens_1 = require_semanticTokens2();
      var showDocument_1 = require_showDocument2();
      var fileOperations_1 = require_fileOperations2();
      var linkedEditingRange_1 = require_linkedEditingRange2();
      var typeHierarchy_1 = require_typeHierarchy2();
      var inlineValue_1 = require_inlineValue2();
      var foldingRange_1 = require_foldingRange2();
      var inlayHint_1 = require_inlayHint2();
      var diagnostic_1 = require_diagnostic2();
      var notebook_1 = require_notebook2();
      var moniker_1 = require_moniker2();
      function null2Undefined(value) {
        if (value === null) {
          return void 0;
        }
        return value;
      }
      var ErrorMessageTracker = class {
        constructor() {
          this._messages = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Add a message to the tracker.
         *
         * @param message The message to add.
         */
        add(message) {
          let count = this._messages[message];
          if (!count) {
            count = 0;
          }
          count++;
          this._messages[message] = count;
        }
        /**
         * Send all tracked messages to the connection's window.
         *
         * @param connection The connection established between client and server.
         */
        sendErrors(connection2) {
          Object.keys(this._messages).forEach((message) => {
            connection2.window.showErrorMessage(message);
          });
        }
      };
      exports2.ErrorMessageTracker = ErrorMessageTracker;
      var RemoteConsoleImpl = class {
        constructor() {
        }
        rawAttach(connection2) {
          this._rawConnection = connection2;
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        fillServerCapabilities(_capabilities) {
        }
        initialize(_capabilities) {
        }
        error(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
        }
        warn(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
        }
        info(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
        }
        log(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
        }
        debug(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
        }
        send(type, message) {
          if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
              (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
            });
          }
        }
      };
      var _RemoteWindowImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        showErrorMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
        showWarningMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
        showInformationMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
      };
      var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
      var BulkRegistration;
      (function(BulkRegistration2) {
        function create() {
          return new BulkRegistrationImpl();
        }
        BulkRegistration2.create = create;
      })(BulkRegistration || (exports2.BulkRegistration = BulkRegistration = {}));
      var BulkRegistrationImpl = class {
        constructor() {
          this._registrations = [];
          this._registered = /* @__PURE__ */ new Set();
        }
        add(type, registerOptions) {
          const method = Is3.string(type) ? type : type.method;
          if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
          }
          const id = UUID.generateUuid();
          this._registrations.push({
            id,
            method,
            registerOptions: registerOptions || {}
          });
          this._registered.add(method);
        }
        asRegistrationParams() {
          return {
            registrations: this._registrations
          };
        }
      };
      var BulkUnregistration;
      (function(BulkUnregistration2) {
        function create() {
          return new BulkUnregistrationImpl(void 0, []);
        }
        BulkUnregistration2.create = create;
      })(BulkUnregistration || (exports2.BulkUnregistration = BulkUnregistration = {}));
      var BulkUnregistrationImpl = class {
        constructor(_connection, unregistrations) {
          this._connection = _connection;
          this._unregistrations = /* @__PURE__ */ new Map();
          unregistrations.forEach((unregistration) => {
            this._unregistrations.set(unregistration.method, unregistration);
          });
        }
        get isAttached() {
          return !!this._connection;
        }
        attach(connection2) {
          this._connection = connection2;
        }
        add(unregistration) {
          this._unregistrations.set(unregistration.method, unregistration);
        }
        dispose() {
          let unregistrations = [];
          for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
          }
          let params = {
            unregisterations: unregistrations
          };
          this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this._connection.console.info(`Bulk unregistration failed.`);
          });
        }
        disposeSingle(arg) {
          const method = Is3.string(arg) ? arg : arg.method;
          const unregistration = this._unregistrations.get(method);
          if (!unregistration) {
            return false;
          }
          let params = {
            unregisterations: [unregistration]
          };
          this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
          }, (_error) => {
            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
          });
          return true;
        }
      };
      var RemoteClientImpl = class {
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
          if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
          } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
          } else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
          }
        }
        registerSingle1(unregistration, type, registerOptions) {
          const method = Is3.string(type) ? type : type.method;
          const id = UUID.generateUuid();
          let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
          };
          if (!unregistration.isAttached) {
            unregistration.attach(this.connection);
          }
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id, method });
            return unregistration;
          }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
          });
        }
        registerSingle2(type, registerOptions) {
          const method = Is3.string(type) ? type : type.method;
          const id = UUID.generateUuid();
          let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
              this.unregisterSingle(id, method).catch(() => {
                this.connection.console.info(`Un-registering capability with id ${id} failed.`);
              });
            });
          }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
          });
        }
        unregisterSingle(id, method) {
          let params = {
            unregisterations: [{ id, method }]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this.connection.console.info(`Un-registering request handler for ${id} failed.`);
          });
        }
        registerMany(registrations) {
          let params = registrations.asRegistrationParams();
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
              return { id: registration.id, method: registration.method };
            }));
          }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
          });
        }
      };
      var _RemoteWorkspaceImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        applyEdit(paramOrEdit) {
          function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
          }
          let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
        }
      };
      var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
      var TracerImpl = class {
        constructor() {
          this._trace = vscode_languageserver_protocol_1.Trace.Off;
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        set trace(value) {
          this._trace = value;
        }
        log(message, verbose) {
          if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
          }
          this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
          }).catch(() => {
          });
        }
      };
      var TelemetryImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        logEvent(data) {
          this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
            this.connection.console.log(`Sending TelemetryEventNotification failed`);
          });
        }
      };
      var _LanguagesImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        attachWorkDoneProgress(params) {
          return (0, progress_1.attachWorkDone)(this.connection, params);
        }
        attachPartialResultProgress(_type, params) {
          return (0, progress_1.attachPartialResult)(this.connection, params);
        }
      };
      exports2._LanguagesImpl = _LanguagesImpl;
      var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
      var _NotebooksImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        attachWorkDoneProgress(params) {
          return (0, progress_1.attachWorkDone)(this.connection, params);
        }
        attachPartialResultProgress(_type, params) {
          return (0, progress_1.attachPartialResult)(this.connection, params);
        }
      };
      exports2._NotebooksImpl = _NotebooksImpl;
      var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
      function combineConsoleFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineConsoleFeatures = combineConsoleFeatures;
      function combineTelemetryFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineTelemetryFeatures = combineTelemetryFeatures;
      function combineTracerFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineTracerFeatures = combineTracerFeatures;
      function combineClientFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineClientFeatures = combineClientFeatures;
      function combineWindowFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineWindowFeatures = combineWindowFeatures;
      function combineWorkspaceFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
      function combineLanguagesFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineLanguagesFeatures = combineLanguagesFeatures;
      function combineNotebooksFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineNotebooksFeatures = combineNotebooksFeatures;
      function combineFeatures(one, two) {
        function combine(one2, two2, func) {
          if (one2 && two2) {
            return func(one2, two2);
          } else if (one2) {
            return one2;
          } else {
            return two2;
          }
        }
        let result = {
          __brand: "features",
          console: combine(one.console, two.console, combineConsoleFeatures),
          tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
          telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
          client: combine(one.client, two.client, combineClientFeatures),
          window: combine(one.window, two.window, combineWindowFeatures),
          workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
          languages: combine(one.languages, two.languages, combineLanguagesFeatures),
          notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
        };
        return result;
      }
      exports2.combineFeatures = combineFeatures;
      function createConnection2(connectionFactory, watchDog, factories) {
        const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
        const connection2 = connectionFactory(logger);
        logger.rawAttach(connection2);
        const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
        const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
        const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
        const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
        const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
        const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
        const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
        const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
        function asPromise(value) {
          if (value instanceof Promise) {
            return value;
          } else if (Is3.thenable(value)) {
            return new Promise((resolve, reject2) => {
              value.then((resolved) => resolve(resolved), (error) => reject2(error));
            });
          } else {
            return Promise.resolve(value);
          }
        }
        let shutdownHandler = void 0;
        let initializeHandler = void 0;
        let exitHandler = void 0;
        let protocolConnection = {
          listen: () => connection2.listen(),
          sendRequest: (type, ...params) => connection2.sendRequest(Is3.string(type) ? type : type.method, ...params),
          onRequest: (type, handler) => connection2.onRequest(type, handler),
          sendNotification: (type, param) => {
            const method = Is3.string(type) ? type : type.method;
            return connection2.sendNotification(method, param);
          },
          onNotification: (type, handler) => connection2.onNotification(type, handler),
          onProgress: connection2.onProgress,
          sendProgress: connection2.sendProgress,
          onInitialize: (handler) => {
            initializeHandler = handler;
            return {
              dispose: () => {
                initializeHandler = void 0;
              }
            };
          },
          onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
          onShutdown: (handler) => {
            shutdownHandler = handler;
            return {
              dispose: () => {
                shutdownHandler = void 0;
              }
            };
          },
          onExit: (handler) => {
            exitHandler = handler;
            return {
              dispose: () => {
                exitHandler = void 0;
              }
            };
          },
          get console() {
            return logger;
          },
          get telemetry() {
            return telemetry;
          },
          get tracer() {
            return tracer;
          },
          get client() {
            return client;
          },
          get window() {
            return remoteWindow;
          },
          get workspace() {
            return workspace;
          },
          get languages() {
            return languages;
          },
          get notebooks() {
            return notebooks;
          },
          onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
          onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
          __textDocumentSync: void 0,
          onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
          onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
          onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
          onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
          onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
          onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
          sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
          onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
          onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
          onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          dispose: () => connection2.dispose()
        };
        for (let remote of allRemotes) {
          remote.attach(protocolConnection);
        }
        connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
          watchDog.initialize(params);
          if (Is3.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
          }
          for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
          }
          if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
            return asPromise(result).then((value) => {
              if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                return value;
              }
              let result2 = value;
              if (!result2) {
                result2 = { capabilities: {} };
              }
              let capabilities = result2.capabilities;
              if (!capabilities) {
                capabilities = {};
                result2.capabilities = capabilities;
              }
              if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
                capabilities.textDocumentSync = Is3.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
              } else if (!Is3.number(capabilities.textDocumentSync) && !Is3.number(capabilities.textDocumentSync.change)) {
                capabilities.textDocumentSync.change = Is3.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
              }
              for (let remote of allRemotes) {
                remote.fillServerCapabilities(capabilities);
              }
              return result2;
            });
          } else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(result.capabilities);
            }
            return result;
          }
        });
        connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
          watchDog.shutdownReceived = true;
          if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
          } else {
            return void 0;
          }
        });
        connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
          try {
            if (exitHandler) {
              exitHandler();
            }
          } finally {
            if (watchDog.shutdownReceived) {
              watchDog.exit(0);
            } else {
              watchDog.exit(1);
            }
          }
        });
        connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
        });
        return protocolConnection;
      }
      exports2.createConnection = createConnection2;
    }
  });

  // node_modules/vscode-languageserver/lib/common/api.js
  var require_api6 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
      var semanticTokens_1 = require_semanticTokens2();
      Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
        return semanticTokens_1.SemanticTokensBuilder;
      } });
      var ic = require_inlineCompletion_proposed2();
      __exportStar(require_main5(), exports2);
      var textDocuments_1 = require_textDocuments2();
      Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
        return textDocuments_1.TextDocuments;
      } });
      var notebook_1 = require_notebook2();
      Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
        return notebook_1.NotebookDocuments;
      } });
      __exportStar(require_server2(), exports2);
      var ProposedFeatures;
      (function(ProposedFeatures2) {
        ProposedFeatures2.all = {
          __brand: "features",
          languages: ic.InlineCompletionFeature
        };
      })(ProposedFeatures || (exports2.ProposedFeatures = ProposedFeatures = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/browser.js
  var require_browser4 = __commonJS({
    "node_modules/vscode-languageserver-protocol/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = require_main5();
    }
  });

  // node_modules/vscode-languageserver/lib/browser/main.js
  var require_main6 = __commonJS({
    "node_modules/vscode-languageserver/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createConnection = void 0;
      var api_1 = require_api6();
      __exportStar(require_browser4(), exports2);
      __exportStar(require_api6(), exports2);
      var _shutdownReceived = false;
      var watchDog = {
        initialize: (_params) => {
        },
        get shutdownReceived() {
          return _shutdownReceived;
        },
        set shutdownReceived(value) {
          _shutdownReceived = value;
        },
        exit: (_code) => {
        }
      };
      function createConnection2(arg1, arg2, arg3, arg4) {
        let factories;
        let reader;
        let writer;
        let options;
        if (arg1 !== void 0 && arg1.__brand === "features") {
          factories = arg1;
          arg1 = arg2;
          arg2 = arg3;
          arg3 = arg4;
        }
        if (api_1.ConnectionStrategy.is(arg1) || api_1.ConnectionOptions.is(arg1)) {
          options = arg1;
        } else {
          reader = arg1;
          writer = arg2;
          options = arg3;
        }
        const connectionFactory = (logger) => {
          return (0, api_1.createProtocolConnection)(reader, writer, logger, options);
        };
        return (0, api_1.createConnection)(connectionFactory, watchDog, factories);
      }
      exports2.createConnection = createConnection2;
    }
  });

  // node_modules/vscode-languageserver/browser.js
  var require_browser5 = __commonJS({
    "node_modules/vscode-languageserver/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = require_main6();
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/ral.js
  var require_ral3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var _ral;
      function RAL() {
        if (_ral === void 0) {
          throw new Error(`No runtime abstraction layer installed`);
        }
        return _ral;
      }
      (function(RAL2) {
        function install(ral) {
          if (ral === void 0) {
            throw new Error(`No runtime abstraction layer provided`);
          }
          _ral = ral;
        }
        RAL2.install = install;
      })(RAL || (RAL = {}));
      exports2.default = RAL;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/disposable.js
  var require_disposable3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Disposable = void 0;
      var Disposable2;
      (function(Disposable3) {
        function create(func) {
          return {
            dispose: func
          };
        }
        Disposable3.create = create;
      })(Disposable2 = exports2.Disposable || (exports2.Disposable = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/events.js
  var require_events3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Emitter = exports2.Event = void 0;
      var ral_1 = require_ral3();
      var Event;
      (function(Event2) {
        const _disposable = { dispose() {
        } };
        Event2.None = function() {
          return _disposable;
        };
      })(Event = exports2.Event || (exports2.Event = {}));
      var CallbackList = class {
        add(callback, context = null, bucket) {
          if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
          }
          this._callbacks.push(callback);
          this._contexts.push(context);
          if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
          }
        }
        remove(callback, context = null) {
          if (!this._callbacks) {
            return;
          }
          let foundCallbackWithDifferentContext = false;
          for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
              if (this._contexts[i] === context) {
                this._callbacks.splice(i, 1);
                this._contexts.splice(i, 1);
                return;
              } else {
                foundCallbackWithDifferentContext = true;
              }
            }
          }
          if (foundCallbackWithDifferentContext) {
            throw new Error("When adding a listener with a context, you should remove it with the same context");
          }
        }
        invoke(...args) {
          if (!this._callbacks) {
            return [];
          }
          const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
          for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
              ret.push(callbacks[i].apply(contexts[i], args));
            } catch (e) {
              (0, ral_1.default)().console.error(e);
            }
          }
          return ret;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          this._callbacks = void 0;
          this._contexts = void 0;
        }
      };
      var Emitter3 = class _Emitter {
        constructor(_options) {
          this._options = _options;
        }
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get event() {
          if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
              if (!this._callbacks) {
                this._callbacks = new CallbackList();
              }
              if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                this._options.onFirstListenerAdd(this);
              }
              this._callbacks.add(listener, thisArgs);
              const result = {
                dispose: () => {
                  if (!this._callbacks) {
                    return;
                  }
                  this._callbacks.remove(listener, thisArgs);
                  result.dispose = _Emitter._noop;
                  if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                    this._options.onLastListenerRemove(this);
                  }
                }
              };
              if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event) {
          if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
          }
        }
        dispose() {
          if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = void 0;
          }
        }
      };
      exports2.Emitter = Emitter3;
      Emitter3._noop = function() {
      };
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
  var require_messageBuffer3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AbstractMessageBuffer = void 0;
      var CR = 13;
      var LF = 10;
      var CRLF = "\r\n";
      var AbstractMessageBuffer = class {
        constructor(encoding = "utf-8") {
          this._encoding = encoding;
          this._chunks = [];
          this._totalLength = 0;
        }
        get encoding() {
          return this._encoding;
        }
        append(chunk) {
          const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
          this._chunks.push(toAppend);
          this._totalLength += toAppend.byteLength;
        }
        tryReadHeaders() {
          if (this._chunks.length === 0) {
            return void 0;
          }
          let state = 0;
          let chunkIndex = 0;
          let offset = 0;
          let chunkBytesRead = 0;
          row:
            while (chunkIndex < this._chunks.length) {
              const chunk = this._chunks[chunkIndex];
              offset = 0;
              column:
                while (offset < chunk.length) {
                  const value = chunk[offset];
                  switch (value) {
                    case CR:
                      switch (state) {
                        case 0:
                          state = 1;
                          break;
                        case 2:
                          state = 3;
                          break;
                        default:
                          state = 0;
                      }
                      break;
                    case LF:
                      switch (state) {
                        case 1:
                          state = 2;
                          break;
                        case 3:
                          state = 4;
                          offset++;
                          break row;
                        default:
                          state = 0;
                      }
                      break;
                    default:
                      state = 0;
                  }
                  offset++;
                }
              chunkBytesRead += chunk.byteLength;
              chunkIndex++;
            }
          if (state !== 4) {
            return void 0;
          }
          const buffer = this._read(chunkBytesRead + offset);
          const result = /* @__PURE__ */ new Map();
          const headers = this.toString(buffer, "ascii").split(CRLF);
          if (headers.length < 2) {
            return result;
          }
          for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(":");
            if (index === -1) {
              throw new Error("Message header must separate key and value using :");
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
          }
          return result;
        }
        tryReadBody(length) {
          if (this._totalLength < length) {
            return void 0;
          }
          return this._read(length);
        }
        get numberOfBytes() {
          return this._totalLength;
        }
        _read(byteCount) {
          if (byteCount === 0) {
            return this.emptyBuffer();
          }
          if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
          }
          if (this._chunks[0].byteLength === byteCount) {
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
          }
          if (this._chunks[0].byteLength > byteCount) {
            const chunk = this._chunks[0];
            const result2 = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result2;
          }
          const result = this.allocNative(byteCount);
          let resultOffset = 0;
          let chunkIndex = 0;
          while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
              const chunkPart = chunk.slice(0, byteCount);
              result.set(chunkPart, resultOffset);
              resultOffset += byteCount;
              this._chunks[chunkIndex] = chunk.slice(byteCount);
              this._totalLength -= byteCount;
              byteCount -= byteCount;
            } else {
              result.set(chunk, resultOffset);
              resultOffset += chunk.byteLength;
              this._chunks.shift();
              this._totalLength -= chunk.byteLength;
              byteCount -= chunk.byteLength;
            }
          }
          return result;
        }
      };
      exports2.AbstractMessageBuffer = AbstractMessageBuffer;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/browser/ril.js
  var require_ril3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var ral_1 = require_ral3();
      var disposable_1 = require_disposable3();
      var events_1 = require_events3();
      var messageBuffer_1 = require_messageBuffer3();
      var MessageBuffer = class _MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
        constructor(encoding = "utf-8") {
          super(encoding);
          this.asciiDecoder = new TextDecoder("ascii");
        }
        emptyBuffer() {
          return _MessageBuffer.emptyBuffer;
        }
        fromString(value, _encoding) {
          return new TextEncoder().encode(value);
        }
        toString(value, encoding) {
          if (encoding === "ascii") {
            return this.asciiDecoder.decode(value);
          } else {
            return new TextDecoder(encoding).decode(value);
          }
        }
        asNative(buffer, length) {
          if (length === void 0) {
            return buffer;
          } else {
            return buffer.slice(0, length);
          }
        }
        allocNative(length) {
          return new Uint8Array(length);
        }
      };
      MessageBuffer.emptyBuffer = new Uint8Array(0);
      var ReadableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
          this._onData = new events_1.Emitter();
          this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
              this._onData.fire(new Uint8Array(buffer));
            }, () => {
              (0, ral_1.default)().console.error(`Converting blob to array buffer failed.`);
            });
          };
          this.socket.addEventListener("message", this._messageListener);
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        onData(listener) {
          return this._onData.event(listener);
        }
      };
      var WritableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        write(data, encoding) {
          if (typeof data === "string") {
            if (encoding !== void 0 && encoding !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
          } else {
            this.socket.send(data);
          }
          return Promise.resolve();
        }
        end() {
          this.socket.close();
        }
      };
      var _textEncoder = new TextEncoder();
      var _ril = Object.freeze({
        messageBuffer: Object.freeze({
          create: (encoding) => new MessageBuffer(encoding)
        }),
        applicationJson: Object.freeze({
          encoder: Object.freeze({
            name: "application/json",
            encode: (msg, options) => {
              if (options.charset !== "utf-8") {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
              }
              return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
            }
          }),
          decoder: Object.freeze({
            name: "application/json",
            decode: (buffer, options) => {
              if (!(buffer instanceof Uint8Array)) {
                throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
              }
              return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
          })
        }),
        stream: Object.freeze({
          asReadableStream: (socket) => new ReadableStreamWrapper(socket),
          asWritableStream: (socket) => new WritableStreamWrapper(socket)
        }),
        console,
        timer: Object.freeze({
          setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
          }
        })
      });
      function RIL() {
        return _ril;
      }
      (function(RIL2) {
        function install() {
          ral_1.default.install(_ril);
        }
        RIL2.install = install;
      })(RIL || (RIL = {}));
      exports2.default = RIL;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/is.js
  var require_is7 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messages.js
  var require_messages5 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
      var is = require_is7();
      var ErrorCodes;
      (function(ErrorCodes2) {
        ErrorCodes2.ParseError = -32700;
        ErrorCodes2.InvalidRequest = -32600;
        ErrorCodes2.MethodNotFound = -32601;
        ErrorCodes2.InvalidParams = -32602;
        ErrorCodes2.InternalError = -32603;
        ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
        ErrorCodes2.serverErrorStart = -32099;
        ErrorCodes2.MessageWriteError = -32099;
        ErrorCodes2.MessageReadError = -32098;
        ErrorCodes2.PendingResponseRejected = -32097;
        ErrorCodes2.ConnectionInactive = -32096;
        ErrorCodes2.ServerNotInitialized = -32002;
        ErrorCodes2.UnknownErrorCode = -32001;
        ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
        ErrorCodes2.serverErrorEnd = -32e3;
      })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
      var ResponseError2 = class _ResponseError extends Error {
        constructor(code, message, data) {
          super(message);
          this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
          this.data = data;
          Object.setPrototypeOf(this, _ResponseError.prototype);
        }
        toJson() {
          const result = {
            code: this.code,
            message: this.message
          };
          if (this.data !== void 0) {
            result.data = this.data;
          }
          return result;
        }
      };
      exports2.ResponseError = ResponseError2;
      var ParameterStructures = class _ParameterStructures {
        constructor(kind) {
          this.kind = kind;
        }
        static is(value) {
          return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
        }
        toString() {
          return this.kind;
        }
      };
      exports2.ParameterStructures = ParameterStructures;
      ParameterStructures.auto = new ParameterStructures("auto");
      ParameterStructures.byPosition = new ParameterStructures("byPosition");
      ParameterStructures.byName = new ParameterStructures("byName");
      var AbstractMessageSignature = class {
        constructor(method, numberOfParams) {
          this.method = method;
          this.numberOfParams = numberOfParams;
        }
        get parameterStructures() {
          return ParameterStructures.auto;
        }
      };
      exports2.AbstractMessageSignature = AbstractMessageSignature;
      var RequestType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports2.RequestType0 = RequestType0;
      var RequestType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.RequestType = RequestType;
      var RequestType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.RequestType1 = RequestType1;
      var RequestType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports2.RequestType2 = RequestType2;
      var RequestType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports2.RequestType3 = RequestType3;
      var RequestType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports2.RequestType4 = RequestType4;
      var RequestType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports2.RequestType5 = RequestType5;
      var RequestType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports2.RequestType6 = RequestType6;
      var RequestType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports2.RequestType7 = RequestType7;
      var RequestType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports2.RequestType8 = RequestType8;
      var RequestType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports2.RequestType9 = RequestType9;
      var NotificationType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.NotificationType = NotificationType;
      var NotificationType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports2.NotificationType0 = NotificationType0;
      var NotificationType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.NotificationType1 = NotificationType1;
      var NotificationType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports2.NotificationType2 = NotificationType2;
      var NotificationType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports2.NotificationType3 = NotificationType3;
      var NotificationType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports2.NotificationType4 = NotificationType4;
      var NotificationType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports2.NotificationType5 = NotificationType5;
      var NotificationType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports2.NotificationType6 = NotificationType6;
      var NotificationType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports2.NotificationType7 = NotificationType7;
      var NotificationType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports2.NotificationType8 = NotificationType8;
      var NotificationType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports2.NotificationType9 = NotificationType9;
      var Message;
      (function(Message2) {
        function isRequest(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
        }
        Message2.isRequest = isRequest;
        function isNotification(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && message.id === void 0;
        }
        Message2.isNotification = isNotification;
        function isResponse(message) {
          const candidate = message;
          return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
        }
        Message2.isResponse = isResponse;
      })(Message = exports2.Message || (exports2.Message = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
  var require_linkedMap3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
      "use strict";
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
      var Touch;
      (function(Touch2) {
        Touch2.None = 0;
        Touch2.First = 1;
        Touch2.AsOld = Touch2.First;
        Touch2.Last = 2;
        Touch2.AsNew = Touch2.Last;
      })(Touch = exports2.Touch || (exports2.Touch = {}));
      var LinkedMap = class {
        constructor() {
          this[_a] = "LinkedMap";
          this._map = /* @__PURE__ */ new Map();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state = 0;
        }
        clear() {
          this._map.clear();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          return this._head?.value;
        }
        get last() {
          return this._tail?.value;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key, touch = Touch.None) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
          return item.value;
        }
        set(key, value, touch = Touch.None) {
          let item = this._map.get(key);
          if (item) {
            item.value = value;
            if (touch !== Touch.None) {
              this.touch(item, touch);
            }
          } else {
            item = { key, value, next: void 0, previous: void 0 };
            switch (touch) {
              case Touch.None:
                this.addItemLast(item);
                break;
              case Touch.First:
                this.addItemFirst(item);
                break;
              case Touch.Last:
                this.addItemLast(item);
                break;
              default:
                this.addItemLast(item);
                break;
            }
            this._map.set(key, item);
            this._size++;
          }
          return this;
        }
        delete(key) {
          return !!this.remove(key);
        }
        remove(key) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          this._map.delete(key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        shift() {
          if (!this._head && !this._tail) {
            return void 0;
          }
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          const item = this._head;
          this._map.delete(item.key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        forEach(callbackfn, thisArg) {
          const state = this._state;
          let current = this._head;
          while (current) {
            if (thisArg) {
              callbackfn.bind(thisArg)(current.value, current.key, this);
            } else {
              callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
          }
        }
        keys() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.key, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        values() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.value, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        entries() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: [current.key, current.value], done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        [(_a = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(newSize) {
          if (newSize >= this.size) {
            return;
          }
          if (newSize === 0) {
            this.clear();
            return;
          }
          let current = this._head;
          let currentSize = this.size;
          while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          if (current) {
            current.previous = void 0;
          }
          this._state++;
        }
        addItemFirst(item) {
          if (!this._head && !this._tail) {
            this._tail = item;
          } else if (!this._head) {
            throw new Error("Invalid list");
          } else {
            item.next = this._head;
            this._head.previous = item;
          }
          this._head = item;
          this._state++;
        }
        addItemLast(item) {
          if (!this._head && !this._tail) {
            this._head = item;
          } else if (!this._tail) {
            throw new Error("Invalid list");
          } else {
            item.previous = this._tail;
            this._tail.next = item;
          }
          this._tail = item;
          this._state++;
        }
        removeItem(item) {
          if (item === this._head && item === this._tail) {
            this._head = void 0;
            this._tail = void 0;
          } else if (item === this._head) {
            if (!item.next) {
              throw new Error("Invalid list");
            }
            item.next.previous = void 0;
            this._head = item.next;
          } else if (item === this._tail) {
            if (!item.previous) {
              throw new Error("Invalid list");
            }
            item.previous.next = void 0;
            this._tail = item.previous;
          } else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
              throw new Error("Invalid list");
            }
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = void 0;
          this._state++;
        }
        touch(item, touch) {
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          if (touch !== Touch.First && touch !== Touch.Last) {
            return;
          }
          if (touch === Touch.First) {
            if (item === this._head) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._tail) {
              previous.next = void 0;
              this._tail = previous;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.previous = void 0;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
          } else if (touch === Touch.Last) {
            if (item === this._tail) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._head) {
              next.previous = void 0;
              this._head = next;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.next = void 0;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
          }
        }
        toJSON() {
          const data = [];
          this.forEach((value, key) => {
            data.push([key, value]);
          });
          return data;
        }
        fromJSON(data) {
          this.clear();
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      };
      exports2.LinkedMap = LinkedMap;
      var LRUCache = class extends LinkedMap {
        constructor(limit, ratio = 1) {
          super();
          this._limit = limit;
          this._ratio = Math.min(Math.max(0, ratio), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(limit) {
          this._limit = limit;
          this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(ratio) {
          this._ratio = Math.min(Math.max(0, ratio), 1);
          this.checkTrim();
        }
        get(key, touch = Touch.AsNew) {
          return super.get(key, touch);
        }
        peek(key) {
          return super.get(key, Touch.None);
        }
        set(key, value) {
          super.set(key, value, Touch.Last);
          this.checkTrim();
          return this;
        }
        checkTrim() {
          if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
          }
        }
      };
      exports2.LRUCache = LRUCache;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/cancellation.js
  var require_cancellation3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
      var ral_1 = require_ral3();
      var Is3 = require_is7();
      var events_1 = require_events3();
      var CancellationToken18;
      (function(CancellationToken19) {
        CancellationToken19.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: events_1.Event.None
        });
        CancellationToken19.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: events_1.Event.None
        });
        function is(value) {
          const candidate = value;
          return candidate && (candidate === CancellationToken19.None || candidate === CancellationToken19.Cancelled || Is3.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
        }
        CancellationToken19.is = is;
      })(CancellationToken18 = exports2.CancellationToken || (exports2.CancellationToken = {}));
      var shortcutEvent = Object.freeze(function(callback, context) {
        const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
        return { dispose() {
          handle.dispose();
        } };
      });
      var MutableToken = class {
        constructor() {
          this._isCancelled = false;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new events_1.Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = void 0;
          }
        }
      };
      var CancellationTokenSource3 = class {
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken18.Cancelled;
          } else {
            this._token.cancel();
          }
        }
        dispose() {
          if (!this._token) {
            this._token = CancellationToken18.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
      exports2.CancellationTokenSource = CancellationTokenSource3;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageReader.js
  var require_messageReader3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
      var ral_1 = require_ral3();
      var Is3 = require_is7();
      var events_1 = require_events3();
      var MessageReader;
      (function(MessageReader2) {
        function is(value) {
          let candidate = value;
          return candidate && Is3.func(candidate.listen) && Is3.func(candidate.dispose) && Is3.func(candidate.onError) && Is3.func(candidate.onClose) && Is3.func(candidate.onPartialMessage);
        }
        MessageReader2.is = is;
      })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
      var AbstractMessageReader = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
          this.partialMessageEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error) {
          this.errorEmitter.fire(this.asError(error));
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        get onPartialMessage() {
          return this.partialMessageEmitter.event;
        }
        firePartialMessage(info) {
          this.partialMessageEmitter.fire(info);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Reader received error. Reason: ${Is3.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports2.AbstractMessageReader = AbstractMessageReader;
      var ResolvedMessageReaderOptions;
      (function(ResolvedMessageReaderOptions2) {
        function fromOptions(options) {
          let charset;
          let result;
          let contentDecoder;
          const contentDecoders = /* @__PURE__ */ new Map();
          let contentTypeDecoder;
          const contentTypeDecoders = /* @__PURE__ */ new Map();
          if (options === void 0 || typeof options === "string") {
            charset = options ?? "utf-8";
          } else {
            charset = options.charset ?? "utf-8";
            if (options.contentDecoder !== void 0) {
              contentDecoder = options.contentDecoder;
              contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== void 0) {
              for (const decoder of options.contentDecoders) {
                contentDecoders.set(decoder.name, decoder);
              }
            }
            if (options.contentTypeDecoder !== void 0) {
              contentTypeDecoder = options.contentTypeDecoder;
              contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== void 0) {
              for (const decoder of options.contentTypeDecoders) {
                contentTypeDecoders.set(decoder.name, decoder);
              }
            }
          }
          if (contentTypeDecoder === void 0) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
        }
        ResolvedMessageReaderOptions2.fromOptions = fromOptions;
      })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
      var ReadableStreamMessageReader = class extends AbstractMessageReader {
        constructor(readable, options) {
          super();
          this.readable = readable;
          this.options = ResolvedMessageReaderOptions.fromOptions(options);
          this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
          this._partialMessageTimeout = 1e4;
          this.nextMessageLength = -1;
          this.messageToken = 0;
        }
        set partialMessageTimeout(timeout) {
          this._partialMessageTimeout = timeout;
        }
        get partialMessageTimeout() {
          return this._partialMessageTimeout;
        }
        listen(callback) {
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.partialMessageTimer = void 0;
          this.callback = callback;
          const result = this.readable.onData((data) => {
            this.onData(data);
          });
          this.readable.onError((error) => this.fireError(error));
          this.readable.onClose(() => this.fireClose());
          return result;
        }
        onData(data) {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders();
              if (!headers) {
                return;
              }
              const contentLength = headers.get("Content-Length");
              if (!contentLength) {
                throw new Error("Header must provide a Content-Length property.");
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                throw new Error("Content-Length value must be a number.");
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== void 0) {
              p = this.options.contentDecoder.decode(body);
            } else {
              p = Promise.resolve(body);
            }
            p.then((value) => {
              this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                this.callback(msg);
              }, (error) => {
                this.fireError(error);
              });
            }, (error) => {
              this.fireError(error);
            });
          }
        }
        clearPartialMessageTimer() {
          if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = void 0;
          }
        }
        setPartialMessageTimer() {
          this.clearPartialMessageTimer();
          if (this._partialMessageTimeout <= 0) {
            return;
          }
          this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = void 0;
            if (token === this.messageToken) {
              this.firePartialMessage({ messageToken: token, waitingTime: timeout });
              this.setPartialMessageTimer();
            }
          }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
        }
      };
      exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/semaphore.js
  var require_semaphore3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Semaphore = void 0;
      var ral_1 = require_ral3();
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve, reject2) => {
            this._waiting.push({ thunk, resolve, reject: reject2 });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports2.Semaphore = Semaphore;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
  var require_messageWriter3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
      var ral_1 = require_ral3();
      var Is3 = require_is7();
      var semaphore_1 = require_semaphore3();
      var events_1 = require_events3();
      var ContentLength = "Content-Length: ";
      var CRLF = "\r\n";
      var MessageWriter;
      (function(MessageWriter2) {
        function is(value) {
          let candidate = value;
          return candidate && Is3.func(candidate.dispose) && Is3.func(candidate.onClose) && Is3.func(candidate.onError) && Is3.func(candidate.write);
        }
        MessageWriter2.is = is;
      })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
      var AbstractMessageWriter = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error, message, count) {
          this.errorEmitter.fire([this.asError(error), message, count]);
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Writer received error. Reason: ${Is3.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports2.AbstractMessageWriter = AbstractMessageWriter;
      var ResolvedMessageWriterOptions;
      (function(ResolvedMessageWriterOptions2) {
        function fromOptions(options) {
          if (options === void 0 || typeof options === "string") {
            return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
          } else {
            return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
          }
        }
        ResolvedMessageWriterOptions2.fromOptions = fromOptions;
      })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
      var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
        constructor(writable, options) {
          super();
          this.writable = writable;
          this.options = ResolvedMessageWriterOptions.fromOptions(options);
          this.errorCount = 0;
          this.writeSemaphore = new semaphore_1.Semaphore(1);
          this.writable.onError((error) => this.fireError(error));
          this.writable.onClose(() => this.fireClose());
        }
        async write(msg) {
          return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
              if (this.options.contentEncoder !== void 0) {
                return this.options.contentEncoder.encode(buffer);
              } else {
                return buffer;
              }
            });
            return payload.then((buffer) => {
              const headers = [];
              headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
              headers.push(CRLF);
              return this.doWrite(msg, headers, buffer);
            }, (error) => {
              this.fireError(error);
              throw error;
            });
          });
        }
        async doWrite(msg, headers, data) {
          try {
            await this.writable.write(headers.join(""), "ascii");
            return this.writable.write(data);
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
          this.writable.end();
        }
      };
      exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/connection.js
  var require_connection5 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createMessageConnection = exports2.ConnectionOptions = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
      var ral_1 = require_ral3();
      var Is3 = require_is7();
      var messages_1 = require_messages5();
      var linkedMap_1 = require_linkedMap3();
      var events_1 = require_events3();
      var cancellation_1 = require_cancellation3();
      var CancelNotification;
      (function(CancelNotification2) {
        CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
      })(CancelNotification || (CancelNotification = {}));
      var ProgressToken;
      (function(ProgressToken2) {
        function is(value) {
          return typeof value === "string" || typeof value === "number";
        }
        ProgressToken2.is = is;
      })(ProgressToken = exports2.ProgressToken || (exports2.ProgressToken = {}));
      var ProgressNotification;
      (function(ProgressNotification2) {
        ProgressNotification2.type = new messages_1.NotificationType("$/progress");
      })(ProgressNotification || (ProgressNotification = {}));
      var ProgressType = class {
        constructor() {
        }
      };
      exports2.ProgressType = ProgressType;
      var StarRequestHandler;
      (function(StarRequestHandler2) {
        function is(value) {
          return Is3.func(value);
        }
        StarRequestHandler2.is = is;
      })(StarRequestHandler || (StarRequestHandler = {}));
      exports2.NullLogger = Object.freeze({
        error: () => {
        },
        warn: () => {
        },
        info: () => {
        },
        log: () => {
        }
      });
      var Trace;
      (function(Trace2) {
        Trace2[Trace2["Off"] = 0] = "Off";
        Trace2[Trace2["Messages"] = 1] = "Messages";
        Trace2[Trace2["Compact"] = 2] = "Compact";
        Trace2[Trace2["Verbose"] = 3] = "Verbose";
      })(Trace = exports2.Trace || (exports2.Trace = {}));
      var TraceValues;
      (function(TraceValues2) {
        TraceValues2.Off = "off";
        TraceValues2.Messages = "messages";
        TraceValues2.Compact = "compact";
        TraceValues2.Verbose = "verbose";
      })(TraceValues = exports2.TraceValues || (exports2.TraceValues = {}));
      (function(Trace2) {
        function fromString(value) {
          if (!Is3.string(value)) {
            return Trace2.Off;
          }
          value = value.toLowerCase();
          switch (value) {
            case "off":
              return Trace2.Off;
            case "messages":
              return Trace2.Messages;
            case "compact":
              return Trace2.Compact;
            case "verbose":
              return Trace2.Verbose;
            default:
              return Trace2.Off;
          }
        }
        Trace2.fromString = fromString;
        function toString4(value) {
          switch (value) {
            case Trace2.Off:
              return "off";
            case Trace2.Messages:
              return "messages";
            case Trace2.Compact:
              return "compact";
            case Trace2.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        Trace2.toString = toString4;
      })(Trace = exports2.Trace || (exports2.Trace = {}));
      var TraceFormat;
      (function(TraceFormat2) {
        TraceFormat2["Text"] = "text";
        TraceFormat2["JSON"] = "json";
      })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
      (function(TraceFormat2) {
        function fromString(value) {
          if (!Is3.string(value)) {
            return TraceFormat2.Text;
          }
          value = value.toLowerCase();
          if (value === "json") {
            return TraceFormat2.JSON;
          } else {
            return TraceFormat2.Text;
          }
        }
        TraceFormat2.fromString = fromString;
      })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
      var SetTraceNotification;
      (function(SetTraceNotification2) {
        SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
      })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
      var LogTraceNotification;
      (function(LogTraceNotification2) {
        LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
      })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
      var ConnectionErrors;
      (function(ConnectionErrors2) {
        ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
        ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
        ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
      })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
      var ConnectionError = class _ConnectionError extends Error {
        constructor(code, message) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, _ConnectionError.prototype);
        }
      };
      exports2.ConnectionError = ConnectionError;
      var ConnectionStrategy;
      (function(ConnectionStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is3.func(candidate.cancelUndispatched);
        }
        ConnectionStrategy2.is = is;
      })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
      var CancellationReceiverStrategy;
      (function(CancellationReceiverStrategy2) {
        CancellationReceiverStrategy2.Message = Object.freeze({
          createCancellationTokenSource(_5) {
            return new cancellation_1.CancellationTokenSource();
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is3.func(candidate.createCancellationTokenSource);
        }
        CancellationReceiverStrategy2.is = is;
      })(CancellationReceiverStrategy = exports2.CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = {}));
      var CancellationSenderStrategy;
      (function(CancellationSenderStrategy2) {
        CancellationSenderStrategy2.Message = Object.freeze({
          sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
          },
          cleanup(_5) {
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is3.func(candidate.sendCancellation) && Is3.func(candidate.cleanup);
        }
        CancellationSenderStrategy2.is = is;
      })(CancellationSenderStrategy = exports2.CancellationSenderStrategy || (exports2.CancellationSenderStrategy = {}));
      var CancellationStrategy;
      (function(CancellationStrategy2) {
        CancellationStrategy2.Message = Object.freeze({
          receiver: CancellationReceiverStrategy.Message,
          sender: CancellationSenderStrategy.Message
        });
        function is(value) {
          const candidate = value;
          return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
        }
        CancellationStrategy2.is = is;
      })(CancellationStrategy = exports2.CancellationStrategy || (exports2.CancellationStrategy = {}));
      var ConnectionOptions;
      (function(ConnectionOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
        }
        ConnectionOptions2.is = is;
      })(ConnectionOptions = exports2.ConnectionOptions || (exports2.ConnectionOptions = {}));
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["New"] = 1] = "New";
        ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
        ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
        ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
      })(ConnectionState || (ConnectionState = {}));
      function createMessageConnection(messageReader2, messageWriter2, _logger, options) {
        const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
        let sequenceNumber = 0;
        let notificationSequenceNumber = 0;
        let unknownResponseSequenceNumber = 0;
        const version = "2.0";
        let starRequestHandler = void 0;
        const requestHandlers = /* @__PURE__ */ new Map();
        let starNotificationHandler = void 0;
        const notificationHandlers = /* @__PURE__ */ new Map();
        const progressHandlers = /* @__PURE__ */ new Map();
        let timer2;
        let messageQueue = new linkedMap_1.LinkedMap();
        let responsePromises = /* @__PURE__ */ new Map();
        let knownCanceledRequests = /* @__PURE__ */ new Set();
        let requestTokens = /* @__PURE__ */ new Map();
        let trace = Trace.Off;
        let traceFormat = TraceFormat.Text;
        let tracer;
        let state = ConnectionState.New;
        const errorEmitter = new events_1.Emitter();
        const closeEmitter = new events_1.Emitter();
        const unhandledNotificationEmitter = new events_1.Emitter();
        const unhandledProgressEmitter = new events_1.Emitter();
        const disposeEmitter = new events_1.Emitter();
        const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
        function createRequestQueueKey(id) {
          if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
          }
          return "req-" + id.toString();
        }
        function createResponseQueueKey(id) {
          if (id === null) {
            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
          } else {
            return "res-" + id.toString();
          }
        }
        function createNotificationQueueKey() {
          return "not-" + (++notificationSequenceNumber).toString();
        }
        function addMessageToQueue(queue, message) {
          if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
          } else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
          } else {
            queue.set(createNotificationQueueKey(), message);
          }
        }
        function cancelUndispatched(_message) {
          return void 0;
        }
        function isListening() {
          return state === ConnectionState.Listening;
        }
        function isClosed() {
          return state === ConnectionState.Closed;
        }
        function isDisposed() {
          return state === ConnectionState.Disposed;
        }
        function closeHandler() {
          if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(void 0);
          }
        }
        function readErrorHandler(error) {
          errorEmitter.fire([error, void 0, void 0]);
        }
        function writeErrorHandler(data) {
          errorEmitter.fire(data);
        }
        messageReader2.onClose(closeHandler);
        messageReader2.onError(readErrorHandler);
        messageWriter2.onClose(closeHandler);
        messageWriter2.onError(writeErrorHandler);
        function triggerMessageQueue() {
          if (timer2 || messageQueue.size === 0) {
            return;
          }
          timer2 = (0, ral_1.default)().timer.setImmediate(() => {
            timer2 = void 0;
            processMessageQueue();
          });
        }
        function processMessageQueue() {
          if (messageQueue.size === 0) {
            return;
          }
          const message = messageQueue.shift();
          try {
            if (messages_1.Message.isRequest(message)) {
              handleRequest(message);
            } else if (messages_1.Message.isNotification(message)) {
              handleNotification(message);
            } else if (messages_1.Message.isResponse(message)) {
              handleResponse(message);
            } else {
              handleInvalidMessage(message);
            }
          } finally {
            triggerMessageQueue();
          }
        }
        const callback = (message) => {
          try {
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
              const cancelId = message.params.id;
              const key = createRequestQueueKey(cancelId);
              const toCancel = messageQueue.get(key);
              if (messages_1.Message.isRequest(toCancel)) {
                const strategy = options?.connectionStrategy;
                const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                if (response && (response.error !== void 0 || response.result !== void 0)) {
                  messageQueue.delete(key);
                  requestTokens.delete(cancelId);
                  response.id = toCancel.id;
                  traceSendingResponse(response, message.method, Date.now());
                  messageWriter2.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                  return;
                }
              }
              const cancellationToken = requestTokens.get(cancelId);
              if (cancellationToken !== void 0) {
                cancellationToken.cancel();
                traceReceivedNotification(message);
                return;
              } else {
                knownCanceledRequests.add(cancelId);
              }
            }
            addMessageToQueue(messageQueue, message);
          } finally {
            triggerMessageQueue();
          }
        };
        function handleRequest(requestMessage) {
          if (isDisposed()) {
            return;
          }
          function reply(resultOrError, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
              message.error = resultOrError.toJson();
            } else {
              message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replyError(error, method, startTime2) {
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              error: error.toJson()
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replySuccess(result, method, startTime2) {
            if (result === void 0) {
              result = null;
            }
            const message = {
              jsonrpc: version,
              id: requestMessage.id,
              result
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          traceReceivedRequest(requestMessage);
          const element = requestHandlers.get(requestMessage.method);
          let type;
          let requestHandler;
          if (element) {
            type = element.type;
            requestHandler = element.handler;
          }
          const startTime = Date.now();
          if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now());
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
              cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
              requestTokens.set(tokenKey, cancellationSource);
            }
            try {
              let handlerResult;
              if (requestHandler) {
                if (requestMessage.params === void 0) {
                  if (type !== void 0 && type.numberOfParams !== 0) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(cancellationSource.token);
                } else if (Array.isArray(requestMessage.params)) {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                }
              } else if (starRequestHandler) {
                handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
              }
              const promise = handlerResult;
              if (!handlerResult) {
                requestTokens.delete(tokenKey);
                replySuccess(handlerResult, requestMessage.method, startTime);
              } else if (promise.then) {
                promise.then((resultOrError) => {
                  requestTokens.delete(tokenKey);
                  reply(resultOrError, requestMessage.method, startTime);
                }, (error) => {
                  requestTokens.delete(tokenKey);
                  if (error instanceof messages_1.ResponseError) {
                    replyError(error, requestMessage.method, startTime);
                  } else if (error && Is3.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                  } else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                  }
                });
              } else {
                requestTokens.delete(tokenKey);
                reply(handlerResult, requestMessage.method, startTime);
              }
            } catch (error) {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                reply(error, requestMessage.method, startTime);
              } else if (error && Is3.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            }
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
          }
        }
        function handleResponse(responseMessage) {
          if (isDisposed()) {
            return;
          }
          if (responseMessage.id === null) {
            if (responseMessage.error) {
              logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
            } else {
              logger.error(`Received response message without id. No further error information provided.`);
            }
          } else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== void 0) {
              responsePromises.delete(key);
              try {
                if (responseMessage.error) {
                  const error = responseMessage.error;
                  responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                } else if (responseMessage.result !== void 0) {
                  responsePromise.resolve(responseMessage.result);
                } else {
                  throw new Error("Should never happen.");
                }
              } catch (error) {
                if (error.message) {
                  logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                } else {
                  logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                }
              }
            }
          }
        }
        function handleNotification(message) {
          if (isDisposed()) {
            return;
          }
          let type = void 0;
          let notificationHandler;
          if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
          } else {
            const element = notificationHandlers.get(message.method);
            if (element) {
              notificationHandler = element.handler;
              type = element.type;
            }
          }
          if (notificationHandler || starNotificationHandler) {
            try {
              traceReceivedNotification(message);
              if (notificationHandler) {
                if (message.params === void 0) {
                  if (type !== void 0) {
                    if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                    }
                  }
                  notificationHandler();
                } else if (Array.isArray(message.params)) {
                  const params = message.params;
                  if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                    notificationHandler({ token: params[0], value: params[1] });
                  } else {
                    if (type !== void 0) {
                      if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                        logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                      }
                      if (type.numberOfParams !== message.params.length) {
                        logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                      }
                    }
                    notificationHandler(...params);
                  }
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                  }
                  notificationHandler(message.params);
                }
              } else if (starNotificationHandler) {
                starNotificationHandler(message.method, message.params);
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
              }
            }
          } else {
            unhandledNotificationEmitter.fire(message);
          }
        }
        function handleInvalidMessage(message) {
          if (!message) {
            logger.error("Received empty message.");
            return;
          }
          logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
          const responseMessage = message;
          if (Is3.string(responseMessage.id) || Is3.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
              responseHandler.reject(new Error("The received response has neither a result nor an error property."));
            }
          }
        }
        function stringifyTrace(params) {
          if (params === void 0 || params === null) {
            return void 0;
          }
          switch (trace) {
            case Trace.Verbose:
              return JSON.stringify(params, null, 4);
            case Trace.Compact:
              return JSON.stringify(params);
            default:
              return void 0;
          }
        }
        function traceSendingRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("send-request", message);
          }
        }
        function traceSendingNotification(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
          } else {
            logLSPMessage("send-notification", message);
          }
        }
        function traceSendingResponse(message, method, startTime) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
          } else {
            logLSPMessage("send-response", message);
          }
        }
        function traceReceivedRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("receive-request", message);
          }
        }
        function traceReceivedNotification(message) {
          if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
          } else {
            logLSPMessage("receive-notification", message);
          }
        }
        function traceReceivedResponse(message, responsePromise) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            if (responsePromise) {
              const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
              tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            } else {
              tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
          } else {
            logLSPMessage("receive-response", message);
          }
        }
        function logLSPMessage(type, message) {
          if (!tracer || trace === Trace.Off) {
            return;
          }
          const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
          };
          tracer.log(lspMessage);
        }
        function throwIfClosedOrDisposed() {
          if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
          }
          if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
          }
        }
        function throwIfListening() {
          if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
          }
        }
        function throwIfNotListening() {
          if (!isListening()) {
            throw new Error("Call listen() first.");
          }
        }
        function undefinedToNull(param) {
          if (param === void 0) {
            return null;
          } else {
            return param;
          }
        }
        function nullToUndefined(param) {
          if (param === null) {
            return void 0;
          } else {
            return param;
          }
        }
        function isNamedParam(param) {
          return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
        }
        function computeSingleParam(parameterStructures, param) {
          switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
              if (isNamedParam(param)) {
                return nullToUndefined(param);
              } else {
                return [undefinedToNull(param)];
              }
            case messages_1.ParameterStructures.byName:
              if (!isNamedParam(param)) {
                throw new Error(`Received parameters by name but param is not an object literal.`);
              }
              return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
              return [undefinedToNull(param)];
            default:
              throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
          }
        }
        function computeMessageParams(type, params) {
          let result;
          const numberOfParams = type.numberOfParams;
          switch (numberOfParams) {
            case 0:
              result = void 0;
              break;
            case 1:
              result = computeSingleParam(type.parameterStructures, params[0]);
              break;
            default:
              result = [];
              for (let i = 0; i < params.length && i < numberOfParams; i++) {
                result.push(undefinedToNull(params[i]));
              }
              if (params.length < numberOfParams) {
                for (let i = params.length; i < numberOfParams; i++) {
                  result.push(null);
                }
              }
              break;
          }
          return result;
        }
        const connection2 = {
          sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is3.string(type)) {
              method = type;
              const first2 = args[0];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first2)) {
                paramStart = 1;
                parameterStructures = first2;
              }
              let paramEnd = args.length;
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
              jsonrpc: version,
              method,
              params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter2.write(notificationMessage).catch(() => logger.error(`Sending notification failed.`));
          },
          onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is3.func(type)) {
              starNotificationHandler = type;
            } else if (handler) {
              if (Is3.string(type)) {
                method = type;
                notificationHandlers.set(type, { type: void 0, handler });
              } else {
                method = type.method;
                notificationHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method !== void 0) {
                  notificationHandlers.delete(method);
                } else {
                  starNotificationHandler = void 0;
                }
              }
            };
          },
          onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
              throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
              dispose: () => {
                progressHandlers.delete(token);
              }
            };
          },
          sendProgress: (_type, token, value) => {
            return connection2.sendNotification(ProgressNotification.type, { token, value });
          },
          onUnhandledProgress: unhandledProgressEmitter.event,
          sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = void 0;
            if (Is3.string(type)) {
              method = type;
              const first2 = args[0];
              const last2 = args[args.length - 1];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first2)) {
                paramStart = 1;
                parameterStructures = first2;
              }
              let paramEnd = args.length;
              if (cancellation_1.CancellationToken.is(last2)) {
                paramEnd = paramEnd - 1;
                token = last2;
              }
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
              const numberOfParams = type.numberOfParams;
              token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
              disposable = token.onCancellationRequested(() => {
                const p = cancellationStrategy.sender.sendCancellation(connection2, id);
                if (p === void 0) {
                  logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                  return Promise.resolve();
                } else {
                  return p.catch(() => {
                    logger.log(`Sending cancellation messages for id ${id} failed`);
                  });
                }
              });
            }
            const result = new Promise((resolve, reject2) => {
              const requestMessage = {
                jsonrpc: version,
                id,
                method,
                params: messageParams
              };
              const resolveWithCleanup = (r) => {
                resolve(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              const rejectWithCleanup = (r) => {
                reject2(r);
                cancellationStrategy.sender.cleanup(id);
                disposable?.dispose();
              };
              let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
              traceSendingRequest(requestMessage);
              try {
                messageWriter2.write(requestMessage).catch(() => logger.error(`Sending request failed.`));
              } catch (e) {
                responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
                responsePromise = null;
              }
              if (responsePromise) {
                responsePromises.set(id, responsePromise);
              }
            });
            return result;
          },
          onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
              method = void 0;
              starRequestHandler = type;
            } else if (Is3.string(type)) {
              method = null;
              if (handler !== void 0) {
                method = type;
                requestHandlers.set(type, { handler, type: void 0 });
              }
            } else {
              if (handler !== void 0) {
                method = type.method;
                requestHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method === null) {
                  return;
                }
                if (method !== void 0) {
                  requestHandlers.delete(method);
                } else {
                  starRequestHandler = void 0;
                }
              }
            };
          },
          hasPendingResponse: () => {
            return responsePromises.size > 0;
          },
          trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
              if (Is3.boolean(sendNotificationOrTraceOptions)) {
                _sendNotification = sendNotificationOrTraceOptions;
              } else {
                _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
              }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
              tracer = void 0;
            } else {
              tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
              await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
          },
          onError: errorEmitter.event,
          onClose: closeEmitter.event,
          onUnhandledNotification: unhandledNotificationEmitter.event,
          onDispose: disposeEmitter.event,
          end: () => {
            messageWriter2.end();
          },
          dispose: () => {
            if (isDisposed()) {
              return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(void 0);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
            for (const promise of responsePromises.values()) {
              promise.reject(error);
            }
            responsePromises = /* @__PURE__ */ new Map();
            requestTokens = /* @__PURE__ */ new Map();
            knownCanceledRequests = /* @__PURE__ */ new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            if (Is3.func(messageWriter2.dispose)) {
              messageWriter2.dispose();
            }
            if (Is3.func(messageReader2.dispose)) {
              messageReader2.dispose();
            }
          },
          listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader2.listen(callback);
          },
          inspect: () => {
            (0, ral_1.default)().console.log("inspect");
          }
        };
        connection2.onNotification(LogTraceNotification.type, (params) => {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          const verbose = trace === Trace.Verbose || trace === Trace.Compact;
          tracer.log(params.message, verbose ? params.verbose : void 0);
        });
        connection2.onNotification(ProgressNotification.type, (params) => {
          const handler = progressHandlers.get(params.token);
          if (handler) {
            handler(params.value);
          } else {
            unhandledProgressEmitter.fire(params);
          }
        });
        return connection2;
      }
      exports2.createMessageConnection = createMessageConnection;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/api.js
  var require_api7 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
      exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = void 0;
      var messages_1 = require_messages5();
      Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
        return messages_1.Message;
      } });
      Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
        return messages_1.RequestType;
      } });
      Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
        return messages_1.RequestType0;
      } });
      Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
        return messages_1.RequestType1;
      } });
      Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
        return messages_1.RequestType2;
      } });
      Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
        return messages_1.RequestType3;
      } });
      Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
        return messages_1.RequestType4;
      } });
      Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
        return messages_1.RequestType5;
      } });
      Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
        return messages_1.RequestType6;
      } });
      Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
        return messages_1.RequestType7;
      } });
      Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
        return messages_1.RequestType8;
      } });
      Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
        return messages_1.RequestType9;
      } });
      Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
        return messages_1.ResponseError;
      } });
      Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
        return messages_1.ErrorCodes;
      } });
      Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
        return messages_1.NotificationType;
      } });
      Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
        return messages_1.NotificationType0;
      } });
      Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
        return messages_1.NotificationType1;
      } });
      Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
        return messages_1.NotificationType2;
      } });
      Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
        return messages_1.NotificationType3;
      } });
      Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
        return messages_1.NotificationType4;
      } });
      Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
        return messages_1.NotificationType5;
      } });
      Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
        return messages_1.NotificationType6;
      } });
      Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
        return messages_1.NotificationType7;
      } });
      Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
        return messages_1.NotificationType8;
      } });
      Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
        return messages_1.NotificationType9;
      } });
      Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
        return messages_1.ParameterStructures;
      } });
      var linkedMap_1 = require_linkedMap3();
      Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
        return linkedMap_1.LinkedMap;
      } });
      Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
        return linkedMap_1.LRUCache;
      } });
      Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
        return linkedMap_1.Touch;
      } });
      var disposable_1 = require_disposable3();
      Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
        return disposable_1.Disposable;
      } });
      var events_1 = require_events3();
      Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
        return events_1.Event;
      } });
      Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
        return events_1.Emitter;
      } });
      var cancellation_1 = require_cancellation3();
      Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
        return cancellation_1.CancellationTokenSource;
      } });
      Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
        return cancellation_1.CancellationToken;
      } });
      var messageReader_1 = require_messageReader3();
      Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
        return messageReader_1.MessageReader;
      } });
      Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
        return messageReader_1.AbstractMessageReader;
      } });
      Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return messageReader_1.ReadableStreamMessageReader;
      } });
      var messageWriter_1 = require_messageWriter3();
      Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.MessageWriter;
      } });
      Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.AbstractMessageWriter;
      } });
      Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.WriteableStreamMessageWriter;
      } });
      var connection_1 = require_connection5();
      Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
        return connection_1.ConnectionStrategy;
      } });
      Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
        return connection_1.ConnectionOptions;
      } });
      Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
        return connection_1.NullLogger;
      } });
      Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
        return connection_1.createMessageConnection;
      } });
      Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
        return connection_1.ProgressToken;
      } });
      Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
        return connection_1.ProgressType;
      } });
      Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
        return connection_1.Trace;
      } });
      Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
        return connection_1.TraceValues;
      } });
      Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
        return connection_1.TraceFormat;
      } });
      Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
        return connection_1.SetTraceNotification;
      } });
      Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
        return connection_1.LogTraceNotification;
      } });
      Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
        return connection_1.ConnectionErrors;
      } });
      Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
        return connection_1.ConnectionError;
      } });
      Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationReceiverStrategy;
      } });
      Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationSenderStrategy;
      } });
      Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationStrategy;
      } });
      var ral_1 = require_ral3();
      exports2.RAL = ral_1.default;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/browser/main.js
  var require_main7 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createMessageConnection = exports2.BrowserMessageWriter = exports2.BrowserMessageReader = void 0;
      var ril_1 = require_ril3();
      ril_1.default.install();
      var api_1 = require_api7();
      __exportStar(require_api7(), exports2);
      var BrowserMessageReader2 = class extends api_1.AbstractMessageReader {
        constructor(context) {
          super();
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            this._onData.fire(event.data);
          };
          context.addEventListener("error", (event) => this.fireError(event));
          context.onmessage = this._messageListener;
        }
        listen(callback) {
          return this._onData.event(callback);
        }
      };
      exports2.BrowserMessageReader = BrowserMessageReader2;
      var BrowserMessageWriter2 = class extends api_1.AbstractMessageWriter {
        constructor(context) {
          super();
          this.context = context;
          this.errorCount = 0;
          context.addEventListener("error", (event) => this.fireError(event));
        }
        write(msg) {
          try {
            this.context.postMessage(msg);
            return Promise.resolve();
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
        }
      };
      exports2.BrowserMessageWriter = BrowserMessageWriter2;
      function createMessageConnection(reader, writer, logger, options) {
        if (logger === void 0) {
          logger = api_1.NullLogger;
        }
        if (api_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, api_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports2.createMessageConnection = createMessageConnection;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/browser.js
  var require_browser6 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/node_modules/vscode-jsonrpc/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = require_main7();
    }
  });

  // ../node_modules/vscode-languageserver-types/lib/umd/main.js
  var require_main8 = __commonJS({
    "../node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
      (function(factory) {
        if (typeof module2 === "object" && typeof module2.exports === "object") {
          var v = factory(__require, exports2);
          if (v !== void 0)
            module2.exports = v;
        } else if (typeof define === "function" && define.amd) {
          define(["require", "exports"], factory);
        }
      })(function(require2, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
        var DocumentUri3;
        (function(DocumentUri4) {
          function is(value) {
            return typeof value === "string";
          }
          DocumentUri4.is = is;
        })(DocumentUri3 = exports3.DocumentUri || (exports3.DocumentUri = {}));
        var URI4;
        (function(URI5) {
          function is(value) {
            return typeof value === "string";
          }
          URI5.is = is;
        })(URI4 = exports3.URI || (exports3.URI = {}));
        var integer3;
        (function(integer4) {
          integer4.MIN_VALUE = -2147483648;
          integer4.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && integer4.MIN_VALUE <= value && value <= integer4.MAX_VALUE;
          }
          integer4.is = is;
        })(integer3 = exports3.integer || (exports3.integer = {}));
        var uinteger3;
        (function(uinteger4) {
          uinteger4.MIN_VALUE = 0;
          uinteger4.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && uinteger4.MIN_VALUE <= value && value <= uinteger4.MAX_VALUE;
          }
          uinteger4.is = is;
        })(uinteger3 = exports3.uinteger || (exports3.uinteger = {}));
        var Position4;
        (function(Position5) {
          function create(line, character) {
            if (line === Number.MAX_VALUE) {
              line = uinteger3.MAX_VALUE;
            }
            if (character === Number.MAX_VALUE) {
              character = uinteger3.MAX_VALUE;
            }
            return { line, character };
          }
          Position5.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Is3.uinteger(candidate.line) && Is3.uinteger(candidate.character);
          }
          Position5.is = is;
        })(Position4 = exports3.Position || (exports3.Position = {}));
        var Range3;
        (function(Range4) {
          function create(one, two, three, four) {
            if (Is3.uinteger(one) && Is3.uinteger(two) && Is3.uinteger(three) && Is3.uinteger(four)) {
              return { start: Position4.create(one, two), end: Position4.create(three, four) };
            } else if (Position4.is(one) && Position4.is(two)) {
              return { start: one, end: two };
            } else {
              throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
            }
          }
          Range4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Position4.is(candidate.start) && Position4.is(candidate.end);
          }
          Range4.is = is;
        })(Range3 = exports3.Range || (exports3.Range = {}));
        var Location4;
        (function(Location5) {
          function create(uri, range) {
            return { uri, range };
          }
          Location5.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Range3.is(candidate.range) && (Is3.string(candidate.uri) || Is3.undefined(candidate.uri));
          }
          Location5.is = is;
        })(Location4 = exports3.Location || (exports3.Location = {}));
        var LocationLink4;
        (function(LocationLink5) {
          function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
            return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
          }
          LocationLink5.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Range3.is(candidate.targetRange) && Is3.string(candidate.targetUri) && Range3.is(candidate.targetSelectionRange) && (Range3.is(candidate.originSelectionRange) || Is3.undefined(candidate.originSelectionRange));
          }
          LocationLink5.is = is;
        })(LocationLink4 = exports3.LocationLink || (exports3.LocationLink = {}));
        var Color3;
        (function(Color4) {
          function create(red, green, blue, alpha) {
            return {
              red,
              green,
              blue,
              alpha
            };
          }
          Color4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Is3.numberRange(candidate.red, 0, 1) && Is3.numberRange(candidate.green, 0, 1) && Is3.numberRange(candidate.blue, 0, 1) && Is3.numberRange(candidate.alpha, 0, 1);
          }
          Color4.is = is;
        })(Color3 = exports3.Color || (exports3.Color = {}));
        var ColorInformation3;
        (function(ColorInformation4) {
          function create(range, color) {
            return {
              range,
              color
            };
          }
          ColorInformation4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Range3.is(candidate.range) && Color3.is(candidate.color);
          }
          ColorInformation4.is = is;
        })(ColorInformation3 = exports3.ColorInformation || (exports3.ColorInformation = {}));
        var ColorPresentation3;
        (function(ColorPresentation4) {
          function create(label, textEdit, additionalTextEdits) {
            return {
              label,
              textEdit,
              additionalTextEdits
            };
          }
          ColorPresentation4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Is3.string(candidate.label) && (Is3.undefined(candidate.textEdit) || TextEdit3.is(candidate)) && (Is3.undefined(candidate.additionalTextEdits) || Is3.typedArray(candidate.additionalTextEdits, TextEdit3.is));
          }
          ColorPresentation4.is = is;
        })(ColorPresentation3 = exports3.ColorPresentation || (exports3.ColorPresentation = {}));
        var FoldingRangeKind4;
        (function(FoldingRangeKind5) {
          FoldingRangeKind5.Comment = "comment";
          FoldingRangeKind5.Imports = "imports";
          FoldingRangeKind5.Region = "region";
        })(FoldingRangeKind4 = exports3.FoldingRangeKind || (exports3.FoldingRangeKind = {}));
        var FoldingRange4;
        (function(FoldingRange5) {
          function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
            var result = {
              startLine,
              endLine
            };
            if (Is3.defined(startCharacter)) {
              result.startCharacter = startCharacter;
            }
            if (Is3.defined(endCharacter)) {
              result.endCharacter = endCharacter;
            }
            if (Is3.defined(kind)) {
              result.kind = kind;
            }
            if (Is3.defined(collapsedText)) {
              result.collapsedText = collapsedText;
            }
            return result;
          }
          FoldingRange5.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Is3.uinteger(candidate.startLine) && Is3.uinteger(candidate.startLine) && (Is3.undefined(candidate.startCharacter) || Is3.uinteger(candidate.startCharacter)) && (Is3.undefined(candidate.endCharacter) || Is3.uinteger(candidate.endCharacter)) && (Is3.undefined(candidate.kind) || Is3.string(candidate.kind));
          }
          FoldingRange5.is = is;
        })(FoldingRange4 = exports3.FoldingRange || (exports3.FoldingRange = {}));
        var DiagnosticRelatedInformation3;
        (function(DiagnosticRelatedInformation4) {
          function create(location, message) {
            return {
              location,
              message
            };
          }
          DiagnosticRelatedInformation4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Location4.is(candidate.location) && Is3.string(candidate.message);
          }
          DiagnosticRelatedInformation4.is = is;
        })(DiagnosticRelatedInformation3 = exports3.DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = {}));
        var DiagnosticSeverity3;
        (function(DiagnosticSeverity4) {
          DiagnosticSeverity4.Error = 1;
          DiagnosticSeverity4.Warning = 2;
          DiagnosticSeverity4.Information = 3;
          DiagnosticSeverity4.Hint = 4;
        })(DiagnosticSeverity3 = exports3.DiagnosticSeverity || (exports3.DiagnosticSeverity = {}));
        var DiagnosticTag3;
        (function(DiagnosticTag4) {
          DiagnosticTag4.Unnecessary = 1;
          DiagnosticTag4.Deprecated = 2;
        })(DiagnosticTag3 = exports3.DiagnosticTag || (exports3.DiagnosticTag = {}));
        var CodeDescription3;
        (function(CodeDescription4) {
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Is3.string(candidate.href);
          }
          CodeDescription4.is = is;
        })(CodeDescription3 = exports3.CodeDescription || (exports3.CodeDescription = {}));
        var Diagnostic3;
        (function(Diagnostic4) {
          function create(range, message, severity, code, source, relatedInformation) {
            var result = { range, message };
            if (Is3.defined(severity)) {
              result.severity = severity;
            }
            if (Is3.defined(code)) {
              result.code = code;
            }
            if (Is3.defined(source)) {
              result.source = source;
            }
            if (Is3.defined(relatedInformation)) {
              result.relatedInformation = relatedInformation;
            }
            return result;
          }
          Diagnostic4.create = create;
          function is(value) {
            var _a;
            var candidate = value;
            return Is3.defined(candidate) && Range3.is(candidate.range) && Is3.string(candidate.message) && (Is3.number(candidate.severity) || Is3.undefined(candidate.severity)) && (Is3.integer(candidate.code) || Is3.string(candidate.code) || Is3.undefined(candidate.code)) && (Is3.undefined(candidate.codeDescription) || Is3.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is3.string(candidate.source) || Is3.undefined(candidate.source)) && (Is3.undefined(candidate.relatedInformation) || Is3.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation3.is));
          }
          Diagnostic4.is = is;
        })(Diagnostic3 = exports3.Diagnostic || (exports3.Diagnostic = {}));
        var Command3;
        (function(Command4) {
          function create(title, command) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              args[_i - 2] = arguments[_i];
            }
            var result = { title, command };
            if (Is3.defined(args) && args.length > 0) {
              result.arguments = args;
            }
            return result;
          }
          Command4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Is3.string(candidate.title) && Is3.string(candidate.command);
          }
          Command4.is = is;
        })(Command3 = exports3.Command || (exports3.Command = {}));
        var TextEdit3;
        (function(TextEdit4) {
          function replace(range, newText) {
            return { range, newText };
          }
          TextEdit4.replace = replace;
          function insert(position, newText) {
            return { range: { start: position, end: position }, newText };
          }
          TextEdit4.insert = insert;
          function del(range) {
            return { range, newText: "" };
          }
          TextEdit4.del = del;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Is3.string(candidate.newText) && Range3.is(candidate.range);
          }
          TextEdit4.is = is;
        })(TextEdit3 = exports3.TextEdit || (exports3.TextEdit = {}));
        var ChangeAnnotation3;
        (function(ChangeAnnotation4) {
          function create(label, needsConfirmation, description) {
            var result = { label };
            if (needsConfirmation !== void 0) {
              result.needsConfirmation = needsConfirmation;
            }
            if (description !== void 0) {
              result.description = description;
            }
            return result;
          }
          ChangeAnnotation4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Is3.string(candidate.label) && (Is3.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is3.string(candidate.description) || candidate.description === void 0);
          }
          ChangeAnnotation4.is = is;
        })(ChangeAnnotation3 = exports3.ChangeAnnotation || (exports3.ChangeAnnotation = {}));
        var ChangeAnnotationIdentifier3;
        (function(ChangeAnnotationIdentifier4) {
          function is(value) {
            var candidate = value;
            return Is3.string(candidate);
          }
          ChangeAnnotationIdentifier4.is = is;
        })(ChangeAnnotationIdentifier3 = exports3.ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = {}));
        var AnnotatedTextEdit3;
        (function(AnnotatedTextEdit4) {
          function replace(range, newText, annotation) {
            return { range, newText, annotationId: annotation };
          }
          AnnotatedTextEdit4.replace = replace;
          function insert(position, newText, annotation) {
            return { range: { start: position, end: position }, newText, annotationId: annotation };
          }
          AnnotatedTextEdit4.insert = insert;
          function del(range, annotation) {
            return { range, newText: "", annotationId: annotation };
          }
          AnnotatedTextEdit4.del = del;
          function is(value) {
            var candidate = value;
            return TextEdit3.is(candidate) && (ChangeAnnotation3.is(candidate.annotationId) || ChangeAnnotationIdentifier3.is(candidate.annotationId));
          }
          AnnotatedTextEdit4.is = is;
        })(AnnotatedTextEdit3 = exports3.AnnotatedTextEdit || (exports3.AnnotatedTextEdit = {}));
        var TextDocumentEdit3;
        (function(TextDocumentEdit4) {
          function create(textDocument, edits) {
            return { textDocument, edits };
          }
          TextDocumentEdit4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && OptionalVersionedTextDocumentIdentifier3.is(candidate.textDocument) && Array.isArray(candidate.edits);
          }
          TextDocumentEdit4.is = is;
        })(TextDocumentEdit3 = exports3.TextDocumentEdit || (exports3.TextDocumentEdit = {}));
        var CreateFile3;
        (function(CreateFile4) {
          function create(uri, options, annotation) {
            var result = {
              kind: "create",
              uri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          CreateFile4.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "create" && Is3.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is3.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is3.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier3.is(candidate.annotationId));
          }
          CreateFile4.is = is;
        })(CreateFile3 = exports3.CreateFile || (exports3.CreateFile = {}));
        var RenameFile3;
        (function(RenameFile4) {
          function create(oldUri, newUri, options, annotation) {
            var result = {
              kind: "rename",
              oldUri,
              newUri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          RenameFile4.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "rename" && Is3.string(candidate.oldUri) && Is3.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is3.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is3.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier3.is(candidate.annotationId));
          }
          RenameFile4.is = is;
        })(RenameFile3 = exports3.RenameFile || (exports3.RenameFile = {}));
        var DeleteFile3;
        (function(DeleteFile4) {
          function create(uri, options, annotation) {
            var result = {
              kind: "delete",
              uri
            };
            if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          DeleteFile4.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "delete" && Is3.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is3.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is3.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier3.is(candidate.annotationId));
          }
          DeleteFile4.is = is;
        })(DeleteFile3 = exports3.DeleteFile || (exports3.DeleteFile = {}));
        var WorkspaceEdit3;
        (function(WorkspaceEdit4) {
          function is(value) {
            var candidate = value;
            return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
              if (Is3.string(change.kind)) {
                return CreateFile3.is(change) || RenameFile3.is(change) || DeleteFile3.is(change);
              } else {
                return TextDocumentEdit3.is(change);
              }
            }));
          }
          WorkspaceEdit4.is = is;
        })(WorkspaceEdit3 = exports3.WorkspaceEdit || (exports3.WorkspaceEdit = {}));
        var TextEditChangeImpl3 = (
          /** @class */
          function() {
            function TextEditChangeImpl4(edits, changeAnnotations) {
              this.edits = edits;
              this.changeAnnotations = changeAnnotations;
            }
            TextEditChangeImpl4.prototype.insert = function(position, newText, annotation) {
              var edit;
              var id;
              if (annotation === void 0) {
                edit = TextEdit3.insert(position, newText);
              } else if (ChangeAnnotationIdentifier3.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit3.insert(position, newText, annotation);
              } else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit3.insert(position, newText, id);
              }
              this.edits.push(edit);
              if (id !== void 0) {
                return id;
              }
            };
            TextEditChangeImpl4.prototype.replace = function(range, newText, annotation) {
              var edit;
              var id;
              if (annotation === void 0) {
                edit = TextEdit3.replace(range, newText);
              } else if (ChangeAnnotationIdentifier3.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit3.replace(range, newText, annotation);
              } else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit3.replace(range, newText, id);
              }
              this.edits.push(edit);
              if (id !== void 0) {
                return id;
              }
            };
            TextEditChangeImpl4.prototype.delete = function(range, annotation) {
              var edit;
              var id;
              if (annotation === void 0) {
                edit = TextEdit3.del(range);
              } else if (ChangeAnnotationIdentifier3.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit3.del(range, annotation);
              } else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit3.del(range, id);
              }
              this.edits.push(edit);
              if (id !== void 0) {
                return id;
              }
            };
            TextEditChangeImpl4.prototype.add = function(edit) {
              this.edits.push(edit);
            };
            TextEditChangeImpl4.prototype.all = function() {
              return this.edits;
            };
            TextEditChangeImpl4.prototype.clear = function() {
              this.edits.splice(0, this.edits.length);
            };
            TextEditChangeImpl4.prototype.assertChangeAnnotations = function(value) {
              if (value === void 0) {
                throw new Error("Text edit change is not configured to manage change annotations.");
              }
            };
            return TextEditChangeImpl4;
          }()
        );
        var ChangeAnnotations3 = (
          /** @class */
          function() {
            function ChangeAnnotations4(annotations) {
              this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
              this._counter = 0;
              this._size = 0;
            }
            ChangeAnnotations4.prototype.all = function() {
              return this._annotations;
            };
            Object.defineProperty(ChangeAnnotations4.prototype, "size", {
              get: function() {
                return this._size;
              },
              enumerable: false,
              configurable: true
            });
            ChangeAnnotations4.prototype.manage = function(idOrAnnotation, annotation) {
              var id;
              if (ChangeAnnotationIdentifier3.is(idOrAnnotation)) {
                id = idOrAnnotation;
              } else {
                id = this.nextId();
                annotation = idOrAnnotation;
              }
              if (this._annotations[id] !== void 0) {
                throw new Error("Id ".concat(id, " is already in use."));
              }
              if (annotation === void 0) {
                throw new Error("No annotation provided for id ".concat(id));
              }
              this._annotations[id] = annotation;
              this._size++;
              return id;
            };
            ChangeAnnotations4.prototype.nextId = function() {
              this._counter++;
              return this._counter.toString();
            };
            return ChangeAnnotations4;
          }()
        );
        var WorkspaceChange3 = (
          /** @class */
          function() {
            function WorkspaceChange4(workspaceEdit) {
              var _this = this;
              this._textEditChanges = /* @__PURE__ */ Object.create(null);
              if (workspaceEdit !== void 0) {
                this._workspaceEdit = workspaceEdit;
                if (workspaceEdit.documentChanges) {
                  this._changeAnnotations = new ChangeAnnotations3(workspaceEdit.changeAnnotations);
                  workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                  workspaceEdit.documentChanges.forEach(function(change) {
                    if (TextDocumentEdit3.is(change)) {
                      var textEditChange = new TextEditChangeImpl3(change.edits, _this._changeAnnotations);
                      _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                  });
                } else if (workspaceEdit.changes) {
                  Object.keys(workspaceEdit.changes).forEach(function(key) {
                    var textEditChange = new TextEditChangeImpl3(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                  });
                }
              } else {
                this._workspaceEdit = {};
              }
            }
            Object.defineProperty(WorkspaceChange4.prototype, "edit", {
              /**
               * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
               * use to be returned from a workspace edit operation like rename.
               */
              get: function() {
                this.initDocumentChanges();
                if (this._changeAnnotations !== void 0) {
                  if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = void 0;
                  } else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                  }
                }
                return this._workspaceEdit;
              },
              enumerable: false,
              configurable: true
            });
            WorkspaceChange4.prototype.getTextEditChange = function(key) {
              if (OptionalVersionedTextDocumentIdentifier3.is(key)) {
                this.initDocumentChanges();
                if (this._workspaceEdit.documentChanges === void 0) {
                  throw new Error("Workspace edit is not configured for document changes.");
                }
                var textDocument = { uri: key.uri, version: key.version };
                var result = this._textEditChanges[textDocument.uri];
                if (!result) {
                  var edits = [];
                  var textDocumentEdit = {
                    textDocument,
                    edits
                  };
                  this._workspaceEdit.documentChanges.push(textDocumentEdit);
                  result = new TextEditChangeImpl3(edits, this._changeAnnotations);
                  this._textEditChanges[textDocument.uri] = result;
                }
                return result;
              } else {
                this.initChanges();
                if (this._workspaceEdit.changes === void 0) {
                  throw new Error("Workspace edit is not configured for normal text edit changes.");
                }
                var result = this._textEditChanges[key];
                if (!result) {
                  var edits = [];
                  this._workspaceEdit.changes[key] = edits;
                  result = new TextEditChangeImpl3(edits);
                  this._textEditChanges[key] = result;
                }
                return result;
              }
            };
            WorkspaceChange4.prototype.initDocumentChanges = function() {
              if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
                this._changeAnnotations = new ChangeAnnotations3();
                this._workspaceEdit.documentChanges = [];
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              }
            };
            WorkspaceChange4.prototype.initChanges = function() {
              if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
                this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
              }
            };
            WorkspaceChange4.prototype.createFile = function(uri, optionsOrAnnotation, options) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var annotation;
              if (ChangeAnnotation3.is(optionsOrAnnotation) || ChangeAnnotationIdentifier3.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
              } else {
                options = optionsOrAnnotation;
              }
              var operation;
              var id;
              if (annotation === void 0) {
                operation = CreateFile3.create(uri, options);
              } else {
                id = ChangeAnnotationIdentifier3.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = CreateFile3.create(uri, options, id);
              }
              this._workspaceEdit.documentChanges.push(operation);
              if (id !== void 0) {
                return id;
              }
            };
            WorkspaceChange4.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var annotation;
              if (ChangeAnnotation3.is(optionsOrAnnotation) || ChangeAnnotationIdentifier3.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
              } else {
                options = optionsOrAnnotation;
              }
              var operation;
              var id;
              if (annotation === void 0) {
                operation = RenameFile3.create(oldUri, newUri, options);
              } else {
                id = ChangeAnnotationIdentifier3.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = RenameFile3.create(oldUri, newUri, options, id);
              }
              this._workspaceEdit.documentChanges.push(operation);
              if (id !== void 0) {
                return id;
              }
            };
            WorkspaceChange4.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var annotation;
              if (ChangeAnnotation3.is(optionsOrAnnotation) || ChangeAnnotationIdentifier3.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
              } else {
                options = optionsOrAnnotation;
              }
              var operation;
              var id;
              if (annotation === void 0) {
                operation = DeleteFile3.create(uri, options);
              } else {
                id = ChangeAnnotationIdentifier3.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = DeleteFile3.create(uri, options, id);
              }
              this._workspaceEdit.documentChanges.push(operation);
              if (id !== void 0) {
                return id;
              }
            };
            return WorkspaceChange4;
          }()
        );
        exports3.WorkspaceChange = WorkspaceChange3;
        var TextDocumentIdentifier3;
        (function(TextDocumentIdentifier4) {
          function create(uri) {
            return { uri };
          }
          TextDocumentIdentifier4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Is3.string(candidate.uri);
          }
          TextDocumentIdentifier4.is = is;
        })(TextDocumentIdentifier3 = exports3.TextDocumentIdentifier || (exports3.TextDocumentIdentifier = {}));
        var VersionedTextDocumentIdentifier3;
        (function(VersionedTextDocumentIdentifier4) {
          function create(uri, version) {
            return { uri, version };
          }
          VersionedTextDocumentIdentifier4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Is3.string(candidate.uri) && Is3.integer(candidate.version);
          }
          VersionedTextDocumentIdentifier4.is = is;
        })(VersionedTextDocumentIdentifier3 = exports3.VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = {}));
        var OptionalVersionedTextDocumentIdentifier3;
        (function(OptionalVersionedTextDocumentIdentifier4) {
          function create(uri, version) {
            return { uri, version };
          }
          OptionalVersionedTextDocumentIdentifier4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Is3.string(candidate.uri) && (candidate.version === null || Is3.integer(candidate.version));
          }
          OptionalVersionedTextDocumentIdentifier4.is = is;
        })(OptionalVersionedTextDocumentIdentifier3 = exports3.OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = {}));
        var TextDocumentItem3;
        (function(TextDocumentItem4) {
          function create(uri, languageId, version, text) {
            return { uri, languageId, version, text };
          }
          TextDocumentItem4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Is3.string(candidate.uri) && Is3.string(candidate.languageId) && Is3.integer(candidate.version) && Is3.string(candidate.text);
          }
          TextDocumentItem4.is = is;
        })(TextDocumentItem3 = exports3.TextDocumentItem || (exports3.TextDocumentItem = {}));
        var MarkupKind3;
        (function(MarkupKind4) {
          MarkupKind4.PlainText = "plaintext";
          MarkupKind4.Markdown = "markdown";
          function is(value) {
            var candidate = value;
            return candidate === MarkupKind4.PlainText || candidate === MarkupKind4.Markdown;
          }
          MarkupKind4.is = is;
        })(MarkupKind3 = exports3.MarkupKind || (exports3.MarkupKind = {}));
        var MarkupContent3;
        (function(MarkupContent4) {
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(value) && MarkupKind3.is(candidate.kind) && Is3.string(candidate.value);
          }
          MarkupContent4.is = is;
        })(MarkupContent3 = exports3.MarkupContent || (exports3.MarkupContent = {}));
        var CompletionItemKind6;
        (function(CompletionItemKind7) {
          CompletionItemKind7.Text = 1;
          CompletionItemKind7.Method = 2;
          CompletionItemKind7.Function = 3;
          CompletionItemKind7.Constructor = 4;
          CompletionItemKind7.Field = 5;
          CompletionItemKind7.Variable = 6;
          CompletionItemKind7.Class = 7;
          CompletionItemKind7.Interface = 8;
          CompletionItemKind7.Module = 9;
          CompletionItemKind7.Property = 10;
          CompletionItemKind7.Unit = 11;
          CompletionItemKind7.Value = 12;
          CompletionItemKind7.Enum = 13;
          CompletionItemKind7.Keyword = 14;
          CompletionItemKind7.Snippet = 15;
          CompletionItemKind7.Color = 16;
          CompletionItemKind7.File = 17;
          CompletionItemKind7.Reference = 18;
          CompletionItemKind7.Folder = 19;
          CompletionItemKind7.EnumMember = 20;
          CompletionItemKind7.Constant = 21;
          CompletionItemKind7.Struct = 22;
          CompletionItemKind7.Event = 23;
          CompletionItemKind7.Operator = 24;
          CompletionItemKind7.TypeParameter = 25;
        })(CompletionItemKind6 = exports3.CompletionItemKind || (exports3.CompletionItemKind = {}));
        var InsertTextFormat3;
        (function(InsertTextFormat4) {
          InsertTextFormat4.PlainText = 1;
          InsertTextFormat4.Snippet = 2;
        })(InsertTextFormat3 = exports3.InsertTextFormat || (exports3.InsertTextFormat = {}));
        var CompletionItemTag3;
        (function(CompletionItemTag4) {
          CompletionItemTag4.Deprecated = 1;
        })(CompletionItemTag3 = exports3.CompletionItemTag || (exports3.CompletionItemTag = {}));
        var InsertReplaceEdit3;
        (function(InsertReplaceEdit4) {
          function create(newText, insert, replace) {
            return { newText, insert, replace };
          }
          InsertReplaceEdit4.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is3.string(candidate.newText) && Range3.is(candidate.insert) && Range3.is(candidate.replace);
          }
          InsertReplaceEdit4.is = is;
        })(InsertReplaceEdit3 = exports3.InsertReplaceEdit || (exports3.InsertReplaceEdit = {}));
        var InsertTextMode3;
        (function(InsertTextMode4) {
          InsertTextMode4.asIs = 1;
          InsertTextMode4.adjustIndentation = 2;
        })(InsertTextMode3 = exports3.InsertTextMode || (exports3.InsertTextMode = {}));
        var CompletionItemLabelDetails3;
        (function(CompletionItemLabelDetails4) {
          function is(value) {
            var candidate = value;
            return candidate && (Is3.string(candidate.detail) || candidate.detail === void 0) && (Is3.string(candidate.description) || candidate.description === void 0);
          }
          CompletionItemLabelDetails4.is = is;
        })(CompletionItemLabelDetails3 = exports3.CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = {}));
        var CompletionItem3;
        (function(CompletionItem4) {
          function create(label) {
            return { label };
          }
          CompletionItem4.create = create;
        })(CompletionItem3 = exports3.CompletionItem || (exports3.CompletionItem = {}));
        var CompletionList4;
        (function(CompletionList5) {
          function create(items, isIncomplete) {
            return { items: items ? items : [], isIncomplete: !!isIncomplete };
          }
          CompletionList5.create = create;
        })(CompletionList4 = exports3.CompletionList || (exports3.CompletionList = {}));
        var MarkedString3;
        (function(MarkedString4) {
          function fromPlainText(plainText) {
            return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
          }
          MarkedString4.fromPlainText = fromPlainText;
          function is(value) {
            var candidate = value;
            return Is3.string(candidate) || Is3.objectLiteral(candidate) && Is3.string(candidate.language) && Is3.string(candidate.value);
          }
          MarkedString4.is = is;
        })(MarkedString3 = exports3.MarkedString || (exports3.MarkedString = {}));
        var Hover3;
        (function(Hover4) {
          function is(value) {
            var candidate = value;
            return !!candidate && Is3.objectLiteral(candidate) && (MarkupContent3.is(candidate.contents) || MarkedString3.is(candidate.contents) || Is3.typedArray(candidate.contents, MarkedString3.is)) && (value.range === void 0 || Range3.is(value.range));
          }
          Hover4.is = is;
        })(Hover3 = exports3.Hover || (exports3.Hover = {}));
        var ParameterInformation3;
        (function(ParameterInformation4) {
          function create(label, documentation) {
            return documentation ? { label, documentation } : { label };
          }
          ParameterInformation4.create = create;
        })(ParameterInformation3 = exports3.ParameterInformation || (exports3.ParameterInformation = {}));
        var SignatureInformation3;
        (function(SignatureInformation4) {
          function create(label, documentation) {
            var parameters = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              parameters[_i - 2] = arguments[_i];
            }
            var result = { label };
            if (Is3.defined(documentation)) {
              result.documentation = documentation;
            }
            if (Is3.defined(parameters)) {
              result.parameters = parameters;
            } else {
              result.parameters = [];
            }
            return result;
          }
          SignatureInformation4.create = create;
        })(SignatureInformation3 = exports3.SignatureInformation || (exports3.SignatureInformation = {}));
        var DocumentHighlightKind3;
        (function(DocumentHighlightKind4) {
          DocumentHighlightKind4.Text = 1;
          DocumentHighlightKind4.Read = 2;
          DocumentHighlightKind4.Write = 3;
        })(DocumentHighlightKind3 = exports3.DocumentHighlightKind || (exports3.DocumentHighlightKind = {}));
        var DocumentHighlight4;
        (function(DocumentHighlight5) {
          function create(range, kind) {
            var result = { range };
            if (Is3.number(kind)) {
              result.kind = kind;
            }
            return result;
          }
          DocumentHighlight5.create = create;
        })(DocumentHighlight4 = exports3.DocumentHighlight || (exports3.DocumentHighlight = {}));
        var SymbolKind6;
        (function(SymbolKind7) {
          SymbolKind7.File = 1;
          SymbolKind7.Module = 2;
          SymbolKind7.Namespace = 3;
          SymbolKind7.Package = 4;
          SymbolKind7.Class = 5;
          SymbolKind7.Method = 6;
          SymbolKind7.Property = 7;
          SymbolKind7.Field = 8;
          SymbolKind7.Constructor = 9;
          SymbolKind7.Enum = 10;
          SymbolKind7.Interface = 11;
          SymbolKind7.Function = 12;
          SymbolKind7.Variable = 13;
          SymbolKind7.Constant = 14;
          SymbolKind7.String = 15;
          SymbolKind7.Number = 16;
          SymbolKind7.Boolean = 17;
          SymbolKind7.Array = 18;
          SymbolKind7.Object = 19;
          SymbolKind7.Key = 20;
          SymbolKind7.Null = 21;
          SymbolKind7.EnumMember = 22;
          SymbolKind7.Struct = 23;
          SymbolKind7.Event = 24;
          SymbolKind7.Operator = 25;
          SymbolKind7.TypeParameter = 26;
        })(SymbolKind6 = exports3.SymbolKind || (exports3.SymbolKind = {}));
        var SymbolTag3;
        (function(SymbolTag4) {
          SymbolTag4.Deprecated = 1;
        })(SymbolTag3 = exports3.SymbolTag || (exports3.SymbolTag = {}));
        var SymbolInformation3;
        (function(SymbolInformation4) {
          function create(name, kind, range, uri, containerName) {
            var result = {
              name,
              kind,
              location: { uri, range }
            };
            if (containerName) {
              result.containerName = containerName;
            }
            return result;
          }
          SymbolInformation4.create = create;
        })(SymbolInformation3 = exports3.SymbolInformation || (exports3.SymbolInformation = {}));
        var WorkspaceSymbol3;
        (function(WorkspaceSymbol4) {
          function create(name, kind, uri, range) {
            return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
          }
          WorkspaceSymbol4.create = create;
        })(WorkspaceSymbol3 = exports3.WorkspaceSymbol || (exports3.WorkspaceSymbol = {}));
        var DocumentSymbol3;
        (function(DocumentSymbol4) {
          function create(name, detail, kind, range, selectionRange, children) {
            var result = {
              name,
              detail,
              kind,
              range,
              selectionRange
            };
            if (children !== void 0) {
              result.children = children;
            }
            return result;
          }
          DocumentSymbol4.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is3.string(candidate.name) && Is3.number(candidate.kind) && Range3.is(candidate.range) && Range3.is(candidate.selectionRange) && (candidate.detail === void 0 || Is3.string(candidate.detail)) && (candidate.deprecated === void 0 || Is3.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
          }
          DocumentSymbol4.is = is;
        })(DocumentSymbol3 = exports3.DocumentSymbol || (exports3.DocumentSymbol = {}));
        var CodeActionKind3;
        (function(CodeActionKind4) {
          CodeActionKind4.Empty = "";
          CodeActionKind4.QuickFix = "quickfix";
          CodeActionKind4.Refactor = "refactor";
          CodeActionKind4.RefactorExtract = "refactor.extract";
          CodeActionKind4.RefactorInline = "refactor.inline";
          CodeActionKind4.RefactorRewrite = "refactor.rewrite";
          CodeActionKind4.Source = "source";
          CodeActionKind4.SourceOrganizeImports = "source.organizeImports";
          CodeActionKind4.SourceFixAll = "source.fixAll";
        })(CodeActionKind3 = exports3.CodeActionKind || (exports3.CodeActionKind = {}));
        var CodeActionTriggerKind3;
        (function(CodeActionTriggerKind4) {
          CodeActionTriggerKind4.Invoked = 1;
          CodeActionTriggerKind4.Automatic = 2;
        })(CodeActionTriggerKind3 = exports3.CodeActionTriggerKind || (exports3.CodeActionTriggerKind = {}));
        var CodeActionContext3;
        (function(CodeActionContext4) {
          function create(diagnostics, only, triggerKind) {
            var result = { diagnostics };
            if (only !== void 0 && only !== null) {
              result.only = only;
            }
            if (triggerKind !== void 0 && triggerKind !== null) {
              result.triggerKind = triggerKind;
            }
            return result;
          }
          CodeActionContext4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Is3.typedArray(candidate.diagnostics, Diagnostic3.is) && (candidate.only === void 0 || Is3.typedArray(candidate.only, Is3.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind3.Invoked || candidate.triggerKind === CodeActionTriggerKind3.Automatic);
          }
          CodeActionContext4.is = is;
        })(CodeActionContext3 = exports3.CodeActionContext || (exports3.CodeActionContext = {}));
        var CodeAction3;
        (function(CodeAction4) {
          function create(title, kindOrCommandOrEdit, kind) {
            var result = { title };
            var checkKind = true;
            if (typeof kindOrCommandOrEdit === "string") {
              checkKind = false;
              result.kind = kindOrCommandOrEdit;
            } else if (Command3.is(kindOrCommandOrEdit)) {
              result.command = kindOrCommandOrEdit;
            } else {
              result.edit = kindOrCommandOrEdit;
            }
            if (checkKind && kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          CodeAction4.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is3.string(candidate.title) && (candidate.diagnostics === void 0 || Is3.typedArray(candidate.diagnostics, Diagnostic3.is)) && (candidate.kind === void 0 || Is3.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command3.is(candidate.command)) && (candidate.isPreferred === void 0 || Is3.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit3.is(candidate.edit));
          }
          CodeAction4.is = is;
        })(CodeAction3 = exports3.CodeAction || (exports3.CodeAction = {}));
        var CodeLens3;
        (function(CodeLens4) {
          function create(range, data) {
            var result = { range };
            if (Is3.defined(data)) {
              result.data = data;
            }
            return result;
          }
          CodeLens4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Range3.is(candidate.range) && (Is3.undefined(candidate.command) || Command3.is(candidate.command));
          }
          CodeLens4.is = is;
        })(CodeLens3 = exports3.CodeLens || (exports3.CodeLens = {}));
        var FormattingOptions3;
        (function(FormattingOptions4) {
          function create(tabSize, insertSpaces) {
            return { tabSize, insertSpaces };
          }
          FormattingOptions4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Is3.uinteger(candidate.tabSize) && Is3.boolean(candidate.insertSpaces);
          }
          FormattingOptions4.is = is;
        })(FormattingOptions3 = exports3.FormattingOptions || (exports3.FormattingOptions = {}));
        var DocumentLink3;
        (function(DocumentLink4) {
          function create(range, target, data) {
            return { range, target, data };
          }
          DocumentLink4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Range3.is(candidate.range) && (Is3.undefined(candidate.target) || Is3.string(candidate.target));
          }
          DocumentLink4.is = is;
        })(DocumentLink3 = exports3.DocumentLink || (exports3.DocumentLink = {}));
        var SelectionRange3;
        (function(SelectionRange4) {
          function create(range, parent) {
            return { range, parent };
          }
          SelectionRange4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Range3.is(candidate.range) && (candidate.parent === void 0 || SelectionRange4.is(candidate.parent));
          }
          SelectionRange4.is = is;
        })(SelectionRange3 = exports3.SelectionRange || (exports3.SelectionRange = {}));
        var SemanticTokenTypes5;
        (function(SemanticTokenTypes6) {
          SemanticTokenTypes6["namespace"] = "namespace";
          SemanticTokenTypes6["type"] = "type";
          SemanticTokenTypes6["class"] = "class";
          SemanticTokenTypes6["enum"] = "enum";
          SemanticTokenTypes6["interface"] = "interface";
          SemanticTokenTypes6["struct"] = "struct";
          SemanticTokenTypes6["typeParameter"] = "typeParameter";
          SemanticTokenTypes6["parameter"] = "parameter";
          SemanticTokenTypes6["variable"] = "variable";
          SemanticTokenTypes6["property"] = "property";
          SemanticTokenTypes6["enumMember"] = "enumMember";
          SemanticTokenTypes6["event"] = "event";
          SemanticTokenTypes6["function"] = "function";
          SemanticTokenTypes6["method"] = "method";
          SemanticTokenTypes6["macro"] = "macro";
          SemanticTokenTypes6["keyword"] = "keyword";
          SemanticTokenTypes6["modifier"] = "modifier";
          SemanticTokenTypes6["comment"] = "comment";
          SemanticTokenTypes6["string"] = "string";
          SemanticTokenTypes6["number"] = "number";
          SemanticTokenTypes6["regexp"] = "regexp";
          SemanticTokenTypes6["operator"] = "operator";
          SemanticTokenTypes6["decorator"] = "decorator";
        })(SemanticTokenTypes5 = exports3.SemanticTokenTypes || (exports3.SemanticTokenTypes = {}));
        var SemanticTokenModifiers4;
        (function(SemanticTokenModifiers5) {
          SemanticTokenModifiers5["declaration"] = "declaration";
          SemanticTokenModifiers5["definition"] = "definition";
          SemanticTokenModifiers5["readonly"] = "readonly";
          SemanticTokenModifiers5["static"] = "static";
          SemanticTokenModifiers5["deprecated"] = "deprecated";
          SemanticTokenModifiers5["abstract"] = "abstract";
          SemanticTokenModifiers5["async"] = "async";
          SemanticTokenModifiers5["modification"] = "modification";
          SemanticTokenModifiers5["documentation"] = "documentation";
          SemanticTokenModifiers5["defaultLibrary"] = "defaultLibrary";
        })(SemanticTokenModifiers4 = exports3.SemanticTokenModifiers || (exports3.SemanticTokenModifiers = {}));
        var SemanticTokens3;
        (function(SemanticTokens4) {
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
          }
          SemanticTokens4.is = is;
        })(SemanticTokens3 = exports3.SemanticTokens || (exports3.SemanticTokens = {}));
        var InlineValueText3;
        (function(InlineValueText4) {
          function create(range, text) {
            return { range, text };
          }
          InlineValueText4.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range3.is(candidate.range) && Is3.string(candidate.text);
          }
          InlineValueText4.is = is;
        })(InlineValueText3 = exports3.InlineValueText || (exports3.InlineValueText = {}));
        var InlineValueVariableLookup3;
        (function(InlineValueVariableLookup4) {
          function create(range, variableName, caseSensitiveLookup) {
            return { range, variableName, caseSensitiveLookup };
          }
          InlineValueVariableLookup4.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range3.is(candidate.range) && Is3.boolean(candidate.caseSensitiveLookup) && (Is3.string(candidate.variableName) || candidate.variableName === void 0);
          }
          InlineValueVariableLookup4.is = is;
        })(InlineValueVariableLookup3 = exports3.InlineValueVariableLookup || (exports3.InlineValueVariableLookup = {}));
        var InlineValueEvaluatableExpression3;
        (function(InlineValueEvaluatableExpression4) {
          function create(range, expression) {
            return { range, expression };
          }
          InlineValueEvaluatableExpression4.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range3.is(candidate.range) && (Is3.string(candidate.expression) || candidate.expression === void 0);
          }
          InlineValueEvaluatableExpression4.is = is;
        })(InlineValueEvaluatableExpression3 = exports3.InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = {}));
        var InlineValueContext3;
        (function(InlineValueContext4) {
          function create(frameId, stoppedLocation) {
            return { frameId, stoppedLocation };
          }
          InlineValueContext4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Range3.is(value.stoppedLocation);
          }
          InlineValueContext4.is = is;
        })(InlineValueContext3 = exports3.InlineValueContext || (exports3.InlineValueContext = {}));
        var InlayHintKind3;
        (function(InlayHintKind4) {
          InlayHintKind4.Type = 1;
          InlayHintKind4.Parameter = 2;
          function is(value) {
            return value === 1 || value === 2;
          }
          InlayHintKind4.is = is;
        })(InlayHintKind3 = exports3.InlayHintKind || (exports3.InlayHintKind = {}));
        var InlayHintLabelPart3;
        (function(InlayHintLabelPart4) {
          function create(value) {
            return { value };
          }
          InlayHintLabelPart4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is3.string(candidate.tooltip) || MarkupContent3.is(candidate.tooltip)) && (candidate.location === void 0 || Location4.is(candidate.location)) && (candidate.command === void 0 || Command3.is(candidate.command));
          }
          InlayHintLabelPart4.is = is;
        })(InlayHintLabelPart3 = exports3.InlayHintLabelPart || (exports3.InlayHintLabelPart = {}));
        var InlayHint3;
        (function(InlayHint4) {
          function create(position, label, kind) {
            var result = { position, label };
            if (kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          InlayHint4.create = create;
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && Position4.is(candidate.position) && (Is3.string(candidate.label) || Is3.typedArray(candidate.label, InlayHintLabelPart3.is)) && (candidate.kind === void 0 || InlayHintKind3.is(candidate.kind)) && candidate.textEdits === void 0 || Is3.typedArray(candidate.textEdits, TextEdit3.is) && (candidate.tooltip === void 0 || Is3.string(candidate.tooltip) || MarkupContent3.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is3.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is3.boolean(candidate.paddingRight));
          }
          InlayHint4.is = is;
        })(InlayHint3 = exports3.InlayHint || (exports3.InlayHint = {}));
        var WorkspaceFolder3;
        (function(WorkspaceFolder4) {
          function is(value) {
            var candidate = value;
            return Is3.objectLiteral(candidate) && URI4.is(candidate.uri) && Is3.string(candidate.name);
          }
          WorkspaceFolder4.is = is;
        })(WorkspaceFolder3 = exports3.WorkspaceFolder || (exports3.WorkspaceFolder = {}));
        exports3.EOL = ["\n", "\r\n", "\r"];
        var TextDocument4;
        (function(TextDocument5) {
          function create(uri, languageId, version, content) {
            return new FullTextDocument4(uri, languageId, version, content);
          }
          TextDocument5.create = create;
          function is(value) {
            var candidate = value;
            return Is3.defined(candidate) && Is3.string(candidate.uri) && (Is3.undefined(candidate.languageId) || Is3.string(candidate.languageId)) && Is3.uinteger(candidate.lineCount) && Is3.func(candidate.getText) && Is3.func(candidate.positionAt) && Is3.func(candidate.offsetAt) ? true : false;
          }
          TextDocument5.is = is;
          function applyEdits(document, edits) {
            var text = document.getText();
            var sortedEdits = mergeSort2(edits, function(a2, b) {
              var diff = a2.range.start.line - b.range.start.line;
              if (diff === 0) {
                return a2.range.start.character - b.range.start.character;
              }
              return diff;
            });
            var lastModifiedOffset = text.length;
            for (var i = sortedEdits.length - 1; i >= 0; i--) {
              var e = sortedEdits[i];
              var startOffset = document.offsetAt(e.range.start);
              var endOffset = document.offsetAt(e.range.end);
              if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
              } else {
                throw new Error("Overlapping edit");
              }
              lastModifiedOffset = startOffset;
            }
            return text;
          }
          TextDocument5.applyEdits = applyEdits;
          function mergeSort2(data, compare) {
            if (data.length <= 1) {
              return data;
            }
            var p = data.length / 2 | 0;
            var left = data.slice(0, p);
            var right = data.slice(p);
            mergeSort2(left, compare);
            mergeSort2(right, compare);
            var leftIdx = 0;
            var rightIdx = 0;
            var i = 0;
            while (leftIdx < left.length && rightIdx < right.length) {
              var ret = compare(left[leftIdx], right[rightIdx]);
              if (ret <= 0) {
                data[i++] = left[leftIdx++];
              } else {
                data[i++] = right[rightIdx++];
              }
            }
            while (leftIdx < left.length) {
              data[i++] = left[leftIdx++];
            }
            while (rightIdx < right.length) {
              data[i++] = right[rightIdx++];
            }
            return data;
          }
        })(TextDocument4 = exports3.TextDocument || (exports3.TextDocument = {}));
        var FullTextDocument4 = (
          /** @class */
          function() {
            function FullTextDocument5(uri, languageId, version, content) {
              this._uri = uri;
              this._languageId = languageId;
              this._version = version;
              this._content = content;
              this._lineOffsets = void 0;
            }
            Object.defineProperty(FullTextDocument5.prototype, "uri", {
              get: function() {
                return this._uri;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(FullTextDocument5.prototype, "languageId", {
              get: function() {
                return this._languageId;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(FullTextDocument5.prototype, "version", {
              get: function() {
                return this._version;
              },
              enumerable: false,
              configurable: true
            });
            FullTextDocument5.prototype.getText = function(range) {
              if (range) {
                var start = this.offsetAt(range.start);
                var end = this.offsetAt(range.end);
                return this._content.substring(start, end);
              }
              return this._content;
            };
            FullTextDocument5.prototype.update = function(event, version) {
              this._content = event.text;
              this._version = version;
              this._lineOffsets = void 0;
            };
            FullTextDocument5.prototype.getLineOffsets = function() {
              if (this._lineOffsets === void 0) {
                var lineOffsets = [];
                var text = this._content;
                var isLineStart = true;
                for (var i = 0; i < text.length; i++) {
                  if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                  }
                  var ch = text.charAt(i);
                  isLineStart = ch === "\r" || ch === "\n";
                  if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                    i++;
                  }
                }
                if (isLineStart && text.length > 0) {
                  lineOffsets.push(text.length);
                }
                this._lineOffsets = lineOffsets;
              }
              return this._lineOffsets;
            };
            FullTextDocument5.prototype.positionAt = function(offset) {
              offset = Math.max(Math.min(offset, this._content.length), 0);
              var lineOffsets = this.getLineOffsets();
              var low = 0, high = lineOffsets.length;
              if (high === 0) {
                return Position4.create(0, offset);
              }
              while (low < high) {
                var mid = Math.floor((low + high) / 2);
                if (lineOffsets[mid] > offset) {
                  high = mid;
                } else {
                  low = mid + 1;
                }
              }
              var line = low - 1;
              return Position4.create(line, offset - lineOffsets[line]);
            };
            FullTextDocument5.prototype.offsetAt = function(position) {
              var lineOffsets = this.getLineOffsets();
              if (position.line >= lineOffsets.length) {
                return this._content.length;
              } else if (position.line < 0) {
                return 0;
              }
              var lineOffset = lineOffsets[position.line];
              var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
              return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
            };
            Object.defineProperty(FullTextDocument5.prototype, "lineCount", {
              get: function() {
                return this.getLineOffsets().length;
              },
              enumerable: false,
              configurable: true
            });
            return FullTextDocument5;
          }()
        );
        var Is3;
        (function(Is4) {
          var toString4 = Object.prototype.toString;
          function defined(value) {
            return typeof value !== "undefined";
          }
          Is4.defined = defined;
          function undefined2(value) {
            return typeof value === "undefined";
          }
          Is4.undefined = undefined2;
          function boolean(value) {
            return value === true || value === false;
          }
          Is4.boolean = boolean;
          function string(value) {
            return toString4.call(value) === "[object String]";
          }
          Is4.string = string;
          function number(value) {
            return toString4.call(value) === "[object Number]";
          }
          Is4.number = number;
          function numberRange(value, min2, max) {
            return toString4.call(value) === "[object Number]" && min2 <= value && value <= max;
          }
          Is4.numberRange = numberRange;
          function integer4(value) {
            return toString4.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
          }
          Is4.integer = integer4;
          function uinteger4(value) {
            return toString4.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
          }
          Is4.uinteger = uinteger4;
          function func(value) {
            return toString4.call(value) === "[object Function]";
          }
          Is4.func = func;
          function objectLiteral(value) {
            return value !== null && typeof value === "object";
          }
          Is4.objectLiteral = objectLiteral;
          function typedArray(value, check) {
            return Array.isArray(value) && value.every(check);
          }
          Is4.typedArray = typedArray;
        })(Is3 || (Is3 = {}));
      });
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/messages.js
  var require_messages6 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
      var vscode_jsonrpc_1 = require_main7();
      var MessageDirection;
      (function(MessageDirection2) {
        MessageDirection2["clientToServer"] = "clientToServer";
        MessageDirection2["serverToClient"] = "serverToClient";
        MessageDirection2["both"] = "both";
      })(MessageDirection = exports2.MessageDirection || (exports2.MessageDirection = {}));
      var RegistrationType = class {
        constructor(method) {
          this.method = method;
        }
      };
      exports2.RegistrationType = RegistrationType;
      var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
        constructor(method) {
          super(method);
        }
      };
      exports2.ProtocolRequestType0 = ProtocolRequestType0;
      var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports2.ProtocolRequestType = ProtocolRequestType;
      var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
        constructor(method) {
          super(method);
        }
      };
      exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
      var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports2.ProtocolNotificationType = ProtocolNotificationType;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
  var require_is8 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports2.typedArray = typedArray;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      exports2.objectLiteral = objectLiteral;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
  var require_protocol_implementation3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ImplementationRequest = void 0;
      var messages_1 = require_messages6();
      var ImplementationRequest;
      (function(ImplementationRequest2) {
        ImplementationRequest2.method = "textDocument/implementation";
        ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
      })(ImplementationRequest = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
  var require_protocol_typeDefinition3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeDefinitionRequest = void 0;
      var messages_1 = require_messages6();
      var TypeDefinitionRequest;
      (function(TypeDefinitionRequest2) {
        TypeDefinitionRequest2.method = "textDocument/typeDefinition";
        TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
      })(TypeDefinitionRequest = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
  var require_protocol_workspaceFolder3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
      var messages_1 = require_messages6();
      var WorkspaceFoldersRequest;
      (function(WorkspaceFoldersRequest2) {
        WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
        WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
      })(WorkspaceFoldersRequest = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
      var DidChangeWorkspaceFoldersNotification;
      (function(DidChangeWorkspaceFoldersNotification2) {
        DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
        DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
      })(DidChangeWorkspaceFoldersNotification = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
  var require_protocol_configuration3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConfigurationRequest = void 0;
      var messages_1 = require_messages6();
      var ConfigurationRequest;
      (function(ConfigurationRequest2) {
        ConfigurationRequest2.method = "workspace/configuration";
        ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
      })(ConfigurationRequest = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
  var require_protocol_colorProvider3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
      var messages_1 = require_messages6();
      var DocumentColorRequest;
      (function(DocumentColorRequest2) {
        DocumentColorRequest2.method = "textDocument/documentColor";
        DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
      })(DocumentColorRequest = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
      var ColorPresentationRequest;
      (function(ColorPresentationRequest2) {
        ColorPresentationRequest2.method = "textDocument/colorPresentation";
        ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
      })(ColorPresentationRequest = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
  var require_protocol_foldingRange3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FoldingRangeRequest = void 0;
      var messages_1 = require_messages6();
      var FoldingRangeRequest;
      (function(FoldingRangeRequest2) {
        FoldingRangeRequest2.method = "textDocument/foldingRange";
        FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
      })(FoldingRangeRequest = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
  var require_protocol_declaration3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DeclarationRequest = void 0;
      var messages_1 = require_messages6();
      var DeclarationRequest;
      (function(DeclarationRequest2) {
        DeclarationRequest2.method = "textDocument/declaration";
        DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
      })(DeclarationRequest = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
  var require_protocol_selectionRange3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SelectionRangeRequest = void 0;
      var messages_1 = require_messages6();
      var SelectionRangeRequest;
      (function(SelectionRangeRequest2) {
        SelectionRangeRequest2.method = "textDocument/selectionRange";
        SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
      })(SelectionRangeRequest = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
  var require_protocol_progress3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
      var vscode_jsonrpc_1 = require_main7();
      var messages_1 = require_messages6();
      var WorkDoneProgress;
      (function(WorkDoneProgress2) {
        WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
        function is(value) {
          return value === WorkDoneProgress2.type;
        }
        WorkDoneProgress2.is = is;
      })(WorkDoneProgress = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
      var WorkDoneProgressCreateRequest;
      (function(WorkDoneProgressCreateRequest2) {
        WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
        WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
      })(WorkDoneProgressCreateRequest = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
      var WorkDoneProgressCancelNotification;
      (function(WorkDoneProgressCancelNotification2) {
        WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
        WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
      })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
  var require_protocol_callHierarchy3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages6();
      var CallHierarchyPrepareRequest;
      (function(CallHierarchyPrepareRequest2) {
        CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
        CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
      })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
      var CallHierarchyIncomingCallsRequest;
      (function(CallHierarchyIncomingCallsRequest2) {
        CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
        CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
      })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
      var CallHierarchyOutgoingCallsRequest;
      (function(CallHierarchyOutgoingCallsRequest2) {
        CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
        CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
      })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
  var require_protocol_semanticTokens3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
      var messages_1 = require_messages6();
      var TokenFormat;
      (function(TokenFormat2) {
        TokenFormat2.Relative = "relative";
      })(TokenFormat = exports2.TokenFormat || (exports2.TokenFormat = {}));
      var SemanticTokensRegistrationType;
      (function(SemanticTokensRegistrationType2) {
        SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
        SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
      })(SemanticTokensRegistrationType = exports2.SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = {}));
      var SemanticTokensRequest;
      (function(SemanticTokensRequest2) {
        SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
        SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
        SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
      var SemanticTokensDeltaRequest;
      (function(SemanticTokensDeltaRequest2) {
        SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
        SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
        SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensDeltaRequest = exports2.SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = {}));
      var SemanticTokensRangeRequest;
      (function(SemanticTokensRangeRequest2) {
        SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
        SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
        SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
      var SemanticTokensRefreshRequest;
      (function(SemanticTokensRefreshRequest2) {
        SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
        SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
      })(SemanticTokensRefreshRequest = exports2.SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
  var require_protocol_showDocument3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ShowDocumentRequest = void 0;
      var messages_1 = require_messages6();
      var ShowDocumentRequest;
      (function(ShowDocumentRequest2) {
        ShowDocumentRequest2.method = "window/showDocument";
        ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
      })(ShowDocumentRequest = exports2.ShowDocumentRequest || (exports2.ShowDocumentRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
  var require_protocol_linkedEditingRange3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LinkedEditingRangeRequest = void 0;
      var messages_1 = require_messages6();
      var LinkedEditingRangeRequest;
      (function(LinkedEditingRangeRequest2) {
        LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
        LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
      })(LinkedEditingRangeRequest = exports2.LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
  var require_protocol_fileOperations3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
      var messages_1 = require_messages6();
      var FileOperationPatternKind;
      (function(FileOperationPatternKind2) {
        FileOperationPatternKind2.file = "file";
        FileOperationPatternKind2.folder = "folder";
      })(FileOperationPatternKind = exports2.FileOperationPatternKind || (exports2.FileOperationPatternKind = {}));
      var WillCreateFilesRequest;
      (function(WillCreateFilesRequest2) {
        WillCreateFilesRequest2.method = "workspace/willCreateFiles";
        WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
      })(WillCreateFilesRequest = exports2.WillCreateFilesRequest || (exports2.WillCreateFilesRequest = {}));
      var DidCreateFilesNotification;
      (function(DidCreateFilesNotification2) {
        DidCreateFilesNotification2.method = "workspace/didCreateFiles";
        DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
      })(DidCreateFilesNotification = exports2.DidCreateFilesNotification || (exports2.DidCreateFilesNotification = {}));
      var WillRenameFilesRequest;
      (function(WillRenameFilesRequest2) {
        WillRenameFilesRequest2.method = "workspace/willRenameFiles";
        WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
      })(WillRenameFilesRequest = exports2.WillRenameFilesRequest || (exports2.WillRenameFilesRequest = {}));
      var DidRenameFilesNotification;
      (function(DidRenameFilesNotification2) {
        DidRenameFilesNotification2.method = "workspace/didRenameFiles";
        DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
      })(DidRenameFilesNotification = exports2.DidRenameFilesNotification || (exports2.DidRenameFilesNotification = {}));
      var DidDeleteFilesNotification;
      (function(DidDeleteFilesNotification2) {
        DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
        DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
      })(DidDeleteFilesNotification = exports2.DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = {}));
      var WillDeleteFilesRequest;
      (function(WillDeleteFilesRequest2) {
        WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
        WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
      })(WillDeleteFilesRequest = exports2.WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
  var require_protocol_moniker3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
      var messages_1 = require_messages6();
      var UniquenessLevel;
      (function(UniquenessLevel2) {
        UniquenessLevel2.document = "document";
        UniquenessLevel2.project = "project";
        UniquenessLevel2.group = "group";
        UniquenessLevel2.scheme = "scheme";
        UniquenessLevel2.global = "global";
      })(UniquenessLevel = exports2.UniquenessLevel || (exports2.UniquenessLevel = {}));
      var MonikerKind;
      (function(MonikerKind2) {
        MonikerKind2.$import = "import";
        MonikerKind2.$export = "export";
        MonikerKind2.local = "local";
      })(MonikerKind = exports2.MonikerKind || (exports2.MonikerKind = {}));
      var MonikerRequest;
      (function(MonikerRequest2) {
        MonikerRequest2.method = "textDocument/moniker";
        MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
      })(MonikerRequest = exports2.MonikerRequest || (exports2.MonikerRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
  var require_protocol_typeHierarchy3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages6();
      var TypeHierarchyPrepareRequest;
      (function(TypeHierarchyPrepareRequest2) {
        TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
        TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
      })(TypeHierarchyPrepareRequest = exports2.TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = {}));
      var TypeHierarchySupertypesRequest;
      (function(TypeHierarchySupertypesRequest2) {
        TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
        TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
      })(TypeHierarchySupertypesRequest = exports2.TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = {}));
      var TypeHierarchySubtypesRequest;
      (function(TypeHierarchySubtypesRequest2) {
        TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
        TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
      })(TypeHierarchySubtypesRequest = exports2.TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
  var require_protocol_inlineValue3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
      var messages_1 = require_messages6();
      var InlineValueRequest;
      (function(InlineValueRequest2) {
        InlineValueRequest2.method = "textDocument/inlineValue";
        InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
      })(InlineValueRequest = exports2.InlineValueRequest || (exports2.InlineValueRequest = {}));
      var InlineValueRefreshRequest;
      (function(InlineValueRefreshRequest2) {
        InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
        InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
      })(InlineValueRefreshRequest = exports2.InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
  var require_protocol_inlayHint3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
      var messages_1 = require_messages6();
      var InlayHintRequest;
      (function(InlayHintRequest2) {
        InlayHintRequest2.method = "textDocument/inlayHint";
        InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
      })(InlayHintRequest = exports2.InlayHintRequest || (exports2.InlayHintRequest = {}));
      var InlayHintResolveRequest;
      (function(InlayHintResolveRequest2) {
        InlayHintResolveRequest2.method = "inlayHint/resolve";
        InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
      })(InlayHintResolveRequest = exports2.InlayHintResolveRequest || (exports2.InlayHintResolveRequest = {}));
      var InlayHintRefreshRequest;
      (function(InlayHintRefreshRequest2) {
        InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
        InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
      })(InlayHintRefreshRequest = exports2.InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
  var require_protocol_diagnostic3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
      var vscode_jsonrpc_1 = require_main7();
      var Is3 = require_is8();
      var messages_1 = require_messages6();
      var DiagnosticServerCancellationData;
      (function(DiagnosticServerCancellationData2) {
        function is(value) {
          const candidate = value;
          return candidate && Is3.boolean(candidate.retriggerRequest);
        }
        DiagnosticServerCancellationData2.is = is;
      })(DiagnosticServerCancellationData = exports2.DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = {}));
      var DocumentDiagnosticReportKind;
      (function(DocumentDiagnosticReportKind2) {
        DocumentDiagnosticReportKind2.Full = "full";
        DocumentDiagnosticReportKind2.Unchanged = "unchanged";
      })(DocumentDiagnosticReportKind = exports2.DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = {}));
      var DocumentDiagnosticRequest;
      (function(DocumentDiagnosticRequest2) {
        DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
        DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
        DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(DocumentDiagnosticRequest = exports2.DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = {}));
      var WorkspaceDiagnosticRequest;
      (function(WorkspaceDiagnosticRequest2) {
        WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
        WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
        WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(WorkspaceDiagnosticRequest = exports2.WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = {}));
      var DiagnosticRefreshRequest;
      (function(DiagnosticRefreshRequest2) {
        DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
        DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
      })(DiagnosticRefreshRequest = exports2.DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
  var require_protocol_notebook3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
      var vscode_languageserver_types_1 = require_main8();
      var Is3 = require_is8();
      var messages_1 = require_messages6();
      var NotebookCellKind;
      (function(NotebookCellKind2) {
        NotebookCellKind2.Markup = 1;
        NotebookCellKind2.Code = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        NotebookCellKind2.is = is;
      })(NotebookCellKind = exports2.NotebookCellKind || (exports2.NotebookCellKind = {}));
      var ExecutionSummary;
      (function(ExecutionSummary2) {
        function create(executionOrder, success) {
          const result = { executionOrder };
          if (success === true || success === false) {
            result.success = success;
          }
          return result;
        }
        ExecutionSummary2.create = create;
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is3.boolean(candidate.success));
        }
        ExecutionSummary2.is = is;
        function equals(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          return one.executionOrder === other.executionOrder && one.success === other.success;
        }
        ExecutionSummary2.equals = equals;
      })(ExecutionSummary = exports2.ExecutionSummary || (exports2.ExecutionSummary = {}));
      var NotebookCell;
      (function(NotebookCell2) {
        function create(kind, document) {
          return { kind, document };
        }
        NotebookCell2.create = create;
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is3.objectLiteral(candidate.metadata));
        }
        NotebookCell2.is = is;
        function diff(one, two) {
          const result = /* @__PURE__ */ new Set();
          if (one.document !== two.document) {
            result.add("document");
          }
          if (one.kind !== two.kind) {
            result.add("kind");
          }
          if (one.executionSummary !== two.executionSummary) {
            result.add("executionSummary");
          }
          if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add("metadata");
          }
          if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add("executionSummary");
          }
          return result;
        }
        NotebookCell2.diff = diff;
        function equalsMetadata(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          if (typeof one !== typeof other) {
            return false;
          }
          if (typeof one !== "object") {
            return false;
          }
          const oneArray = Array.isArray(one);
          const otherArray = Array.isArray(other);
          if (oneArray !== otherArray) {
            return false;
          }
          if (oneArray && otherArray) {
            if (one.length !== other.length) {
              return false;
            }
            for (let i = 0; i < one.length; i++) {
              if (!equalsMetadata(one[i], other[i])) {
                return false;
              }
            }
          }
          if (Is3.objectLiteral(one) && Is3.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
              return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
              return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
              const prop = oneKeys[i];
              if (!equalsMetadata(one[prop], other[prop])) {
                return false;
              }
            }
          }
          return true;
        }
      })(NotebookCell = exports2.NotebookCell || (exports2.NotebookCell = {}));
      var NotebookDocument;
      (function(NotebookDocument2) {
        function create(uri, notebookType, version, cells) {
          return { uri, notebookType, version, cells };
        }
        NotebookDocument2.create = create;
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && Is3.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is3.typedArray(candidate.cells, NotebookCell.is);
        }
        NotebookDocument2.is = is;
      })(NotebookDocument = exports2.NotebookDocument || (exports2.NotebookDocument = {}));
      var NotebookDocumentSyncRegistrationType;
      (function(NotebookDocumentSyncRegistrationType2) {
        NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
        NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
        NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
      })(NotebookDocumentSyncRegistrationType = exports2.NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = {}));
      var DidOpenNotebookDocumentNotification;
      (function(DidOpenNotebookDocumentNotification2) {
        DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
        DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
        DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidOpenNotebookDocumentNotification = exports2.DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = {}));
      var NotebookCellArrayChange;
      (function(NotebookCellArrayChange2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is3.typedArray(candidate.cells, NotebookCell.is));
        }
        NotebookCellArrayChange2.is = is;
        function create(start, deleteCount, cells) {
          const result = { start, deleteCount };
          if (cells !== void 0) {
            result.cells = cells;
          }
          return result;
        }
        NotebookCellArrayChange2.create = create;
      })(NotebookCellArrayChange = exports2.NotebookCellArrayChange || (exports2.NotebookCellArrayChange = {}));
      var DidChangeNotebookDocumentNotification;
      (function(DidChangeNotebookDocumentNotification2) {
        DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
        DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
        DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidChangeNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = {}));
      var DidSaveNotebookDocumentNotification;
      (function(DidSaveNotebookDocumentNotification2) {
        DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
        DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
        DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidSaveNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = {}));
      var DidCloseNotebookDocumentNotification;
      (function(DidCloseNotebookDocumentNotification2) {
        DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
        DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
        DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidCloseNotebookDocumentNotification = exports2.DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/protocol.js
  var require_protocol3 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
      exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
      exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = void 0;
      var messages_1 = require_messages6();
      var vscode_languageserver_types_1 = require_main8();
      var Is3 = require_is8();
      var protocol_implementation_1 = require_protocol_implementation3();
      Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
        return protocol_implementation_1.ImplementationRequest;
      } });
      var protocol_typeDefinition_1 = require_protocol_typeDefinition3();
      Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
        return protocol_typeDefinition_1.TypeDefinitionRequest;
      } });
      var protocol_workspaceFolder_1 = require_protocol_workspaceFolder3();
      Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
      } });
      Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
      } });
      var protocol_configuration_1 = require_protocol_configuration3();
      Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
        return protocol_configuration_1.ConfigurationRequest;
      } });
      var protocol_colorProvider_1 = require_protocol_colorProvider3();
      Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.DocumentColorRequest;
      } });
      Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.ColorPresentationRequest;
      } });
      var protocol_foldingRange_1 = require_protocol_foldingRange3();
      Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
        return protocol_foldingRange_1.FoldingRangeRequest;
      } });
      var protocol_declaration_1 = require_protocol_declaration3();
      Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
        return protocol_declaration_1.DeclarationRequest;
      } });
      var protocol_selectionRange_1 = require_protocol_selectionRange3();
      Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
        return protocol_selectionRange_1.SelectionRangeRequest;
      } });
      var protocol_progress_1 = require_protocol_progress3();
      Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgress;
      } });
      Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCreateRequest;
      } });
      Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCancelNotification;
      } });
      var protocol_callHierarchy_1 = require_protocol_callHierarchy3();
      Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
      } });
      Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
      } });
      Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
      } });
      var protocol_semanticTokens_1 = require_protocol_semanticTokens3();
      Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.TokenFormat;
      } });
      Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
      } });
      var protocol_showDocument_1 = require_protocol_showDocument3();
      Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
        return protocol_showDocument_1.ShowDocumentRequest;
      } });
      var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange3();
      Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
      } });
      var protocol_fileOperations_1 = require_protocol_fileOperations3();
      Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
        return protocol_fileOperations_1.FileOperationPatternKind;
      } });
      Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidCreateFilesNotification;
      } });
      Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillCreateFilesRequest;
      } });
      Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidRenameFilesNotification;
      } });
      Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillRenameFilesRequest;
      } });
      Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidDeleteFilesNotification;
      } });
      Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillDeleteFilesRequest;
      } });
      var protocol_moniker_1 = require_protocol_moniker3();
      Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
        return protocol_moniker_1.UniquenessLevel;
      } });
      Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerKind;
      } });
      Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerRequest;
      } });
      var protocol_typeHierarchy_1 = require_protocol_typeHierarchy3();
      Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
      } });
      Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
      } });
      Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
      } });
      var protocol_inlineValue_1 = require_protocol_inlineValue3();
      Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRequest;
      } });
      Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRefreshRequest;
      } });
      var protocol_inlayHint_1 = require_protocol_inlayHint3();
      Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRequest;
      } });
      Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintResolveRequest;
      } });
      Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRefreshRequest;
      } });
      var protocol_diagnostic_1 = require_protocol_diagnostic3();
      Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticServerCancellationData;
      } });
      Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
      } });
      Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticRequest;
      } });
      Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
      } });
      Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticRefreshRequest;
      } });
      var protocol_notebook_1 = require_protocol_notebook3();
      Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellKind;
      } });
      Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
        return protocol_notebook_1.ExecutionSummary;
      } });
      Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCell;
      } });
      Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocument;
      } });
      Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
      } });
      Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellArrayChange;
      } });
      Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
      } });
      var TextDocumentFilter;
      (function(TextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is3.string(candidate.language) || Is3.string(candidate.scheme) || Is3.string(candidate.pattern);
        }
        TextDocumentFilter2.is = is;
      })(TextDocumentFilter = exports2.TextDocumentFilter || (exports2.TextDocumentFilter = {}));
      var NotebookDocumentFilter;
      (function(NotebookDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (Is3.string(candidate.notebookType) || Is3.string(candidate.scheme) || Is3.string(candidate.pattern));
        }
        NotebookDocumentFilter2.is = is;
      })(NotebookDocumentFilter = exports2.NotebookDocumentFilter || (exports2.NotebookDocumentFilter = {}));
      var NotebookCellTextDocumentFilter;
      (function(NotebookCellTextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (Is3.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is3.string(candidate.language));
        }
        NotebookCellTextDocumentFilter2.is = is;
      })(NotebookCellTextDocumentFilter = exports2.NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = {}));
      var DocumentSelector;
      (function(DocumentSelector2) {
        function is(value) {
          if (!Array.isArray(value)) {
            return false;
          }
          for (let elem of value) {
            if (!Is3.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
              return false;
            }
          }
          return true;
        }
        DocumentSelector2.is = is;
      })(DocumentSelector = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
      var RegistrationRequest;
      (function(RegistrationRequest2) {
        RegistrationRequest2.method = "client/registerCapability";
        RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
      })(RegistrationRequest = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
      var UnregistrationRequest;
      (function(UnregistrationRequest2) {
        UnregistrationRequest2.method = "client/unregisterCapability";
        UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
      })(UnregistrationRequest = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
      var ResourceOperationKind;
      (function(ResourceOperationKind2) {
        ResourceOperationKind2.Create = "create";
        ResourceOperationKind2.Rename = "rename";
        ResourceOperationKind2.Delete = "delete";
      })(ResourceOperationKind = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
      var FailureHandlingKind;
      (function(FailureHandlingKind2) {
        FailureHandlingKind2.Abort = "abort";
        FailureHandlingKind2.Transactional = "transactional";
        FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
        FailureHandlingKind2.Undo = "undo";
      })(FailureHandlingKind = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
      var PositionEncodingKind;
      (function(PositionEncodingKind2) {
        PositionEncodingKind2.UTF8 = "utf-8";
        PositionEncodingKind2.UTF16 = "utf-16";
        PositionEncodingKind2.UTF32 = "utf-32";
      })(PositionEncodingKind = exports2.PositionEncodingKind || (exports2.PositionEncodingKind = {}));
      var StaticRegistrationOptions;
      (function(StaticRegistrationOptions2) {
        function hasId(value) {
          const candidate = value;
          return candidate && Is3.string(candidate.id) && candidate.id.length > 0;
        }
        StaticRegistrationOptions2.hasId = hasId;
      })(StaticRegistrationOptions = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
      var TextDocumentRegistrationOptions;
      (function(TextDocumentRegistrationOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
        }
        TextDocumentRegistrationOptions2.is = is;
      })(TextDocumentRegistrationOptions = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
      var WorkDoneProgressOptions;
      (function(WorkDoneProgressOptions2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is3.boolean(candidate.workDoneProgress));
        }
        WorkDoneProgressOptions2.is = is;
        function hasWorkDoneProgress(value) {
          const candidate = value;
          return candidate && Is3.boolean(candidate.workDoneProgress);
        }
        WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
      })(WorkDoneProgressOptions = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
      var InitializeRequest;
      (function(InitializeRequest2) {
        InitializeRequest2.method = "initialize";
        InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
      })(InitializeRequest = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
      var InitializeErrorCodes;
      (function(InitializeErrorCodes2) {
        InitializeErrorCodes2.unknownProtocolVersion = 1;
      })(InitializeErrorCodes = exports2.InitializeErrorCodes || (exports2.InitializeErrorCodes = {}));
      var InitializedNotification;
      (function(InitializedNotification2) {
        InitializedNotification2.method = "initialized";
        InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
      })(InitializedNotification = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
      var ShutdownRequest;
      (function(ShutdownRequest2) {
        ShutdownRequest2.method = "shutdown";
        ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
      })(ShutdownRequest = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
      var ExitNotification;
      (function(ExitNotification2) {
        ExitNotification2.method = "exit";
        ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
      })(ExitNotification = exports2.ExitNotification || (exports2.ExitNotification = {}));
      var DidChangeConfigurationNotification2;
      (function(DidChangeConfigurationNotification3) {
        DidChangeConfigurationNotification3.method = "workspace/didChangeConfiguration";
        DidChangeConfigurationNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeConfigurationNotification3.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification3.method);
      })(DidChangeConfigurationNotification2 = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
      var MessageType;
      (function(MessageType2) {
        MessageType2.Error = 1;
        MessageType2.Warning = 2;
        MessageType2.Info = 3;
        MessageType2.Log = 4;
      })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
      var ShowMessageNotification;
      (function(ShowMessageNotification2) {
        ShowMessageNotification2.method = "window/showMessage";
        ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
      })(ShowMessageNotification = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
      var ShowMessageRequest;
      (function(ShowMessageRequest2) {
        ShowMessageRequest2.method = "window/showMessageRequest";
        ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
      })(ShowMessageRequest = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
      var LogMessageNotification;
      (function(LogMessageNotification2) {
        LogMessageNotification2.method = "window/logMessage";
        LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
      })(LogMessageNotification = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
      var TelemetryEventNotification;
      (function(TelemetryEventNotification2) {
        TelemetryEventNotification2.method = "telemetry/event";
        TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
      })(TelemetryEventNotification = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
      var TextDocumentSyncKind2;
      (function(TextDocumentSyncKind3) {
        TextDocumentSyncKind3.None = 0;
        TextDocumentSyncKind3.Full = 1;
        TextDocumentSyncKind3.Incremental = 2;
      })(TextDocumentSyncKind2 = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
      var DidOpenTextDocumentNotification;
      (function(DidOpenTextDocumentNotification2) {
        DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
        DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
      })(DidOpenTextDocumentNotification = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
      var TextDocumentContentChangeEvent;
      (function(TextDocumentContentChangeEvent2) {
        function isIncremental(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
        }
        TextDocumentContentChangeEvent2.isIncremental = isIncremental;
        function isFull(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
        }
        TextDocumentContentChangeEvent2.isFull = isFull;
      })(TextDocumentContentChangeEvent = exports2.TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = {}));
      var DidChangeTextDocumentNotification;
      (function(DidChangeTextDocumentNotification2) {
        DidChangeTextDocumentNotification2.method = "textDocument/didChange";
        DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
      })(DidChangeTextDocumentNotification = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
      var DidCloseTextDocumentNotification;
      (function(DidCloseTextDocumentNotification2) {
        DidCloseTextDocumentNotification2.method = "textDocument/didClose";
        DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
      })(DidCloseTextDocumentNotification = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
      var DidSaveTextDocumentNotification;
      (function(DidSaveTextDocumentNotification2) {
        DidSaveTextDocumentNotification2.method = "textDocument/didSave";
        DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
      })(DidSaveTextDocumentNotification = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
      var TextDocumentSaveReason;
      (function(TextDocumentSaveReason2) {
        TextDocumentSaveReason2.Manual = 1;
        TextDocumentSaveReason2.AfterDelay = 2;
        TextDocumentSaveReason2.FocusOut = 3;
      })(TextDocumentSaveReason = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
      var WillSaveTextDocumentNotification;
      (function(WillSaveTextDocumentNotification2) {
        WillSaveTextDocumentNotification2.method = "textDocument/willSave";
        WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
      })(WillSaveTextDocumentNotification = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
      var WillSaveTextDocumentWaitUntilRequest;
      (function(WillSaveTextDocumentWaitUntilRequest2) {
        WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
        WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
      })(WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
      var DidChangeWatchedFilesNotification2;
      (function(DidChangeWatchedFilesNotification3) {
        DidChangeWatchedFilesNotification3.method = "workspace/didChangeWatchedFiles";
        DidChangeWatchedFilesNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeWatchedFilesNotification3.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification3.method);
      })(DidChangeWatchedFilesNotification2 = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
      var FileChangeType2;
      (function(FileChangeType3) {
        FileChangeType3.Created = 1;
        FileChangeType3.Changed = 2;
        FileChangeType3.Deleted = 3;
      })(FileChangeType2 = exports2.FileChangeType || (exports2.FileChangeType = {}));
      var RelativePattern;
      (function(RelativePattern2) {
        function is(value) {
          const candidate = value;
          return Is3.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is3.string(candidate.pattern);
        }
        RelativePattern2.is = is;
      })(RelativePattern = exports2.RelativePattern || (exports2.RelativePattern = {}));
      var WatchKind;
      (function(WatchKind2) {
        WatchKind2.Create = 1;
        WatchKind2.Change = 2;
        WatchKind2.Delete = 4;
      })(WatchKind = exports2.WatchKind || (exports2.WatchKind = {}));
      var PublishDiagnosticsNotification;
      (function(PublishDiagnosticsNotification2) {
        PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
        PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
      })(PublishDiagnosticsNotification = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
      var CompletionTriggerKind;
      (function(CompletionTriggerKind2) {
        CompletionTriggerKind2.Invoked = 1;
        CompletionTriggerKind2.TriggerCharacter = 2;
        CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
      })(CompletionTriggerKind = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
      var CompletionRequest;
      (function(CompletionRequest2) {
        CompletionRequest2.method = "textDocument/completion";
        CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
      })(CompletionRequest = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
      var CompletionResolveRequest;
      (function(CompletionResolveRequest2) {
        CompletionResolveRequest2.method = "completionItem/resolve";
        CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
      })(CompletionResolveRequest = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
      var HoverRequest;
      (function(HoverRequest2) {
        HoverRequest2.method = "textDocument/hover";
        HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
      })(HoverRequest = exports2.HoverRequest || (exports2.HoverRequest = {}));
      var SignatureHelpTriggerKind;
      (function(SignatureHelpTriggerKind2) {
        SignatureHelpTriggerKind2.Invoked = 1;
        SignatureHelpTriggerKind2.TriggerCharacter = 2;
        SignatureHelpTriggerKind2.ContentChange = 3;
      })(SignatureHelpTriggerKind = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
      var SignatureHelpRequest;
      (function(SignatureHelpRequest2) {
        SignatureHelpRequest2.method = "textDocument/signatureHelp";
        SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
      })(SignatureHelpRequest = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
      var DefinitionRequest;
      (function(DefinitionRequest2) {
        DefinitionRequest2.method = "textDocument/definition";
        DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
      })(DefinitionRequest = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
      var ReferencesRequest;
      (function(ReferencesRequest2) {
        ReferencesRequest2.method = "textDocument/references";
        ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
      })(ReferencesRequest = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
      var DocumentHighlightRequest;
      (function(DocumentHighlightRequest2) {
        DocumentHighlightRequest2.method = "textDocument/documentHighlight";
        DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
      })(DocumentHighlightRequest = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
      var DocumentSymbolRequest;
      (function(DocumentSymbolRequest2) {
        DocumentSymbolRequest2.method = "textDocument/documentSymbol";
        DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
      })(DocumentSymbolRequest = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
      var CodeActionRequest;
      (function(CodeActionRequest2) {
        CodeActionRequest2.method = "textDocument/codeAction";
        CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
      })(CodeActionRequest = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
      var CodeActionResolveRequest;
      (function(CodeActionResolveRequest2) {
        CodeActionResolveRequest2.method = "codeAction/resolve";
        CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
      })(CodeActionResolveRequest = exports2.CodeActionResolveRequest || (exports2.CodeActionResolveRequest = {}));
      var WorkspaceSymbolRequest;
      (function(WorkspaceSymbolRequest2) {
        WorkspaceSymbolRequest2.method = "workspace/symbol";
        WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
      })(WorkspaceSymbolRequest = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
      var WorkspaceSymbolResolveRequest;
      (function(WorkspaceSymbolResolveRequest2) {
        WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
        WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
      })(WorkspaceSymbolResolveRequest = exports2.WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = {}));
      var CodeLensRequest;
      (function(CodeLensRequest2) {
        CodeLensRequest2.method = "textDocument/codeLens";
        CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
      })(CodeLensRequest = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
      var CodeLensResolveRequest;
      (function(CodeLensResolveRequest2) {
        CodeLensResolveRequest2.method = "codeLens/resolve";
        CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
      })(CodeLensResolveRequest = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
      var CodeLensRefreshRequest;
      (function(CodeLensRefreshRequest2) {
        CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
        CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
      })(CodeLensRefreshRequest = exports2.CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = {}));
      var DocumentLinkRequest;
      (function(DocumentLinkRequest2) {
        DocumentLinkRequest2.method = "textDocument/documentLink";
        DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
      })(DocumentLinkRequest = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
      var DocumentLinkResolveRequest;
      (function(DocumentLinkResolveRequest2) {
        DocumentLinkResolveRequest2.method = "documentLink/resolve";
        DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
      })(DocumentLinkResolveRequest = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
      var DocumentFormattingRequest;
      (function(DocumentFormattingRequest2) {
        DocumentFormattingRequest2.method = "textDocument/formatting";
        DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
      })(DocumentFormattingRequest = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
      var DocumentRangeFormattingRequest;
      (function(DocumentRangeFormattingRequest2) {
        DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
        DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
      })(DocumentRangeFormattingRequest = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
      var DocumentOnTypeFormattingRequest;
      (function(DocumentOnTypeFormattingRequest2) {
        DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
        DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
      })(DocumentOnTypeFormattingRequest = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
      var PrepareSupportDefaultBehavior;
      (function(PrepareSupportDefaultBehavior2) {
        PrepareSupportDefaultBehavior2.Identifier = 1;
      })(PrepareSupportDefaultBehavior = exports2.PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = {}));
      var RenameRequest;
      (function(RenameRequest2) {
        RenameRequest2.method = "textDocument/rename";
        RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
      })(RenameRequest = exports2.RenameRequest || (exports2.RenameRequest = {}));
      var PrepareRenameRequest;
      (function(PrepareRenameRequest2) {
        PrepareRenameRequest2.method = "textDocument/prepareRename";
        PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
      })(PrepareRenameRequest = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
      var ExecuteCommandRequest;
      (function(ExecuteCommandRequest2) {
        ExecuteCommandRequest2.method = "workspace/executeCommand";
        ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
      })(ExecuteCommandRequest = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
      var ApplyWorkspaceEditRequest;
      (function(ApplyWorkspaceEditRequest2) {
        ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
        ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
      })(ApplyWorkspaceEditRequest = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/connection.js
  var require_connection6 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createProtocolConnection = void 0;
      var vscode_jsonrpc_1 = require_main7();
      function createProtocolConnection(input, output, logger, options) {
        if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
      }
      exports2.createProtocolConnection = createProtocolConnection;
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/common/api.js
  var require_api8 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
      __exportStar(require_main7(), exports2);
      __exportStar(require_main8(), exports2);
      __exportStar(require_messages6(), exports2);
      __exportStar(require_protocol3(), exports2);
      var connection_1 = require_connection6();
      Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
        return connection_1.createProtocolConnection;
      } });
      var LSPErrorCodes2;
      (function(LSPErrorCodes3) {
        LSPErrorCodes3.lspReservedErrorRangeStart = -32899;
        LSPErrorCodes3.RequestFailed = -32803;
        LSPErrorCodes3.ServerCancelled = -32802;
        LSPErrorCodes3.ContentModified = -32801;
        LSPErrorCodes3.RequestCancelled = -32800;
        LSPErrorCodes3.lspReservedErrorRangeEnd = -32800;
      })(LSPErrorCodes2 = exports2.LSPErrorCodes || (exports2.LSPErrorCodes = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/lib/browser/main.js
  var require_main9 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createProtocolConnection = void 0;
      var browser_1 = require_browser6();
      __exportStar(require_browser6(), exports2);
      __exportStar(require_api8(), exports2);
      function createProtocolConnection(reader, writer, logger, options) {
        return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports2.createProtocolConnection = createProtocolConnection;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/semanticTokens.js
  var require_semanticTokens3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var SemanticTokensFeature = (Base) => {
        return class extends Base {
          get semanticTokens() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
              },
              on: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onDelta: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onRange: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.SemanticTokensFeature = SemanticTokensFeature;
      var SemanticTokensDiff = class {
        constructor(originalSequence, modifiedSequence) {
          this.originalSequence = originalSequence;
          this.modifiedSequence = modifiedSequence;
        }
        computeDiff() {
          const originalLength = this.originalSequence.length;
          const modifiedLength = this.modifiedSequence.length;
          let startIndex = 0;
          while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
            startIndex++;
          }
          if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
              originalEndIndex--;
              modifiedEndIndex--;
            }
            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
              originalEndIndex++;
              modifiedEndIndex++;
            }
            const deleteCount = originalEndIndex - startIndex + 1;
            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
              return [
                { start: startIndex, deleteCount: deleteCount - 1 }
              ];
            } else {
              return [
                { start: startIndex, deleteCount, data: newData }
              ];
            }
          } else if (startIndex < modifiedLength) {
            return [
              { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
            ];
          } else if (startIndex < originalLength) {
            return [
              { start: startIndex, deleteCount: originalLength - startIndex }
            ];
          } else {
            return [];
          }
        }
      };
      exports2.SemanticTokensDiff = SemanticTokensDiff;
      var SemanticTokensBuilder2 = class {
        constructor() {
          this._prevData = void 0;
          this.initialize();
        }
        initialize() {
          this._id = Date.now();
          this._prevLine = 0;
          this._prevChar = 0;
          this._data = [];
          this._dataLen = 0;
        }
        push(line, char, length, tokenType, tokenModifiers) {
          let pushLine = line;
          let pushChar = char;
          if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
              pushChar -= this._prevChar;
            }
          }
          this._data[this._dataLen++] = pushLine;
          this._data[this._dataLen++] = pushChar;
          this._data[this._dataLen++] = length;
          this._data[this._dataLen++] = tokenType;
          this._data[this._dataLen++] = tokenModifiers;
          this._prevLine = line;
          this._prevChar = char;
        }
        get id() {
          return this._id.toString();
        }
        previousResult(id) {
          if (this.id === id) {
            this._prevData = this._data;
          }
          this.initialize();
        }
        build() {
          this._prevData = void 0;
          return {
            resultId: this.id,
            data: this._data
          };
        }
        canBuildEdits() {
          return this._prevData !== void 0;
        }
        buildEdits() {
          if (this._prevData !== void 0) {
            return {
              resultId: this.id,
              edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
            };
          } else {
            return this.build();
          }
        }
      };
      exports2.SemanticTokensBuilder = SemanticTokensBuilder2;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/textDocuments.js
  var require_textDocuments3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TextDocuments = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var TextDocuments2 = class {
        /**
         * Create a new text document manager.
         */
        constructor(configuration) {
          this._configuration = configuration;
          this._syncedDocuments = /* @__PURE__ */ new Map();
          this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
          this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
          this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
          this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
          this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been opened.
         */
        get onDidOpen() {
          return this._onDidOpen.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been opened or the content changes.
         */
        get onDidChangeContent() {
          return this._onDidChangeContent.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * will be saved.
         */
        get onWillSave() {
          return this._onWillSave.event;
        }
        /**
         * Sets a handler that will be called if a participant wants to provide
         * edits during a text document save.
         */
        onWillSaveWaitUntil(handler) {
          this._willSaveWaitUntil = handler;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been saved.
         */
        get onDidSave() {
          return this._onDidSave.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been closed.
         */
        get onDidClose() {
          return this._onDidClose.event;
        }
        /**
         * Returns the document for the given URI. Returns undefined if
         * the document is not managed by this instance.
         *
         * @param uri The text document's URI to retrieve.
         * @return the text document or `undefined`.
         */
        get(uri) {
          return this._syncedDocuments.get(uri);
        }
        /**
         * Returns all text documents managed by this instance.
         *
         * @return all text documents.
         */
        all() {
          return Array.from(this._syncedDocuments.values());
        }
        /**
         * Returns the URIs of all text documents managed by this instance.
         *
         * @return the URI's of all text documents.
         */
        keys() {
          return Array.from(this._syncedDocuments.keys());
        }
        /**
         * Listens for `low level` notification on the given connection to
         * update the text documents managed by this instance.
         *
         * Please note that the connection only provides handlers not an event model. Therefore
         * listening on a connection will overwrite the following handlers on a connection:
         * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
         * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
         *
         * Use the corresponding events on the TextDocuments instance instead.
         *
         * @param connection The connection to listen on.
         */
        listen(connection2) {
          connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
          const disposables = [];
          disposables.push(connection2.onDidOpenTextDocument((event) => {
            const td = event.textDocument;
            const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
            this._syncedDocuments.set(td.uri, document);
            const toFire = Object.freeze({ document });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
          }));
          disposables.push(connection2.onDidChangeTextDocument((event) => {
            const td = event.textDocument;
            const changes = event.contentChanges;
            if (changes.length === 0) {
              return;
            }
            const { version } = td;
            if (version === null || version === void 0) {
              throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
            }
            let syncedDocument = this._syncedDocuments.get(td.uri);
            if (syncedDocument !== void 0) {
              syncedDocument = this._configuration.update(syncedDocument, changes, version);
              this._syncedDocuments.set(td.uri, syncedDocument);
              this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          disposables.push(connection2.onDidCloseTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._syncedDocuments.delete(event.textDocument.uri);
              this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          disposables.push(connection2.onWillSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
            }
          }));
          disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
              return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
            } else {
              return [];
            }
          }));
          disposables.push(connection2.onDidSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            disposables.forEach((disposable) => disposable.dispose());
          });
        }
      };
      exports2.TextDocuments = TextDocuments2;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/notebook.js
  var require_notebook3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var textDocuments_1 = require_textDocuments3();
      var NotebookSyncFeature = (Base) => {
        return class extends Base {
          get synchronization() {
            return {
              onDidOpenNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidChangeNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidSaveNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidCloseNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              }
            };
          }
        };
      };
      exports2.NotebookSyncFeature = NotebookSyncFeature;
      var CellTextDocumentConnection = class _CellTextDocumentConnection {
        onDidOpenTextDocument(handler) {
          this.openHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.openHandler = void 0;
          });
        }
        openTextDocument(params) {
          this.openHandler && this.openHandler(params);
        }
        onDidChangeTextDocument(handler) {
          this.changeHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.changeHandler = handler;
          });
        }
        changeTextDocument(params) {
          this.changeHandler && this.changeHandler(params);
        }
        onDidCloseTextDocument(handler) {
          this.closeHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.closeHandler = void 0;
          });
        }
        closeTextDocument(params) {
          this.closeHandler && this.closeHandler(params);
        }
        onWillSaveTextDocument() {
          return _CellTextDocumentConnection.NULL_DISPOSE;
        }
        onWillSaveTextDocumentWaitUntil() {
          return _CellTextDocumentConnection.NULL_DISPOSE;
        }
        onDidSaveTextDocument() {
          return _CellTextDocumentConnection.NULL_DISPOSE;
        }
      };
      CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
      } });
      var NotebookDocuments = class {
        constructor(configurationOrTextDocuments) {
          if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
            this._cellTextDocuments = configurationOrTextDocuments;
          } else {
            this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
          }
          this.notebookDocuments = /* @__PURE__ */ new Map();
          this.notebookCellMap = /* @__PURE__ */ new Map();
          this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
          this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
          this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
          this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        }
        get cellTextDocuments() {
          return this._cellTextDocuments;
        }
        getCellTextDocument(cell) {
          return this._cellTextDocuments.get(cell.document);
        }
        getNotebookDocument(uri) {
          return this.notebookDocuments.get(uri);
        }
        getNotebookCell(uri) {
          const value = this.notebookCellMap.get(uri);
          return value && value[0];
        }
        findNotebookDocumentForCell(cell) {
          const key = typeof cell === "string" ? cell : cell.document;
          const value = this.notebookCellMap.get(key);
          return value && value[1];
        }
        get onDidOpen() {
          return this._onDidOpen.event;
        }
        get onDidSave() {
          return this._onDidSave.event;
        }
        get onDidChange() {
          return this._onDidChange.event;
        }
        get onDidClose() {
          return this._onDidClose.event;
        }
        /**
         * Listens for `low level` notification on the given connection to
         * update the notebook documents managed by this instance.
         *
         * Please note that the connection only provides handlers not an event model. Therefore
         * listening on a connection will overwrite the following handlers on a connection:
         * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
         *  and `onDidCloseNotebookDocument`.
         *
         * @param connection The connection to listen on.
         */
        listen(connection2) {
          const cellTextDocumentConnection = new CellTextDocumentConnection();
          const disposables = [];
          disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
          disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
            this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
              cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
            }
            this.updateCellMap(params.notebookDocument);
            this._onDidOpen.fire(params.notebookDocument);
          }));
          disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            notebookDocument.version = params.notebookDocument.version;
            const oldMetadata = notebookDocument.metadata;
            let metadataChanged = false;
            const change = params.change;
            if (change.metadata !== void 0) {
              metadataChanged = true;
              notebookDocument.metadata = change.metadata;
            }
            const opened = [];
            const closed = [];
            const data = [];
            const text = [];
            if (change.cells !== void 0) {
              const changedCells = change.cells;
              if (changedCells.structure !== void 0) {
                const array = changedCells.structure.array;
                notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
                if (changedCells.structure.didOpen !== void 0) {
                  for (const open of changedCells.structure.didOpen) {
                    cellTextDocumentConnection.openTextDocument({ textDocument: open });
                    opened.push(open.uri);
                  }
                }
                if (changedCells.structure.didClose) {
                  for (const close of changedCells.structure.didClose) {
                    cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                    closed.push(close.uri);
                  }
                }
              }
              if (changedCells.data !== void 0) {
                const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
                for (let i = 0; i <= notebookDocument.cells.length; i++) {
                  const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                  if (change2 !== void 0) {
                    const old = notebookDocument.cells.splice(i, 1, change2);
                    data.push({ old: old[0], new: change2 });
                    cellUpdates.delete(change2.document);
                    if (cellUpdates.size === 0) {
                      break;
                    }
                  }
                }
              }
              if (changedCells.textContent !== void 0) {
                for (const cellTextDocument of changedCells.textContent) {
                  cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                  text.push(cellTextDocument.document.uri);
                }
              }
            }
            this.updateCellMap(notebookDocument);
            const changeEvent = { notebookDocument };
            if (metadataChanged) {
              changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
            }
            const added = [];
            for (const open of opened) {
              added.push(this.getNotebookCell(open));
            }
            const removed = [];
            for (const close of closed) {
              removed.push(this.getNotebookCell(close));
            }
            const textContent = [];
            for (const change2 of text) {
              textContent.push(this.getNotebookCell(change2));
            }
            if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
              changeEvent.cells = { added, removed, changed: { data, textContent } };
            }
            if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
              this._onDidChange.fire(changeEvent);
            }
          }));
          disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            this._onDidSave.fire(notebookDocument);
          }));
          disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            this._onDidClose.fire(notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
              cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
            }
            this.notebookDocuments.delete(params.notebookDocument.uri);
            for (const cell of notebookDocument.cells) {
              this.notebookCellMap.delete(cell.document);
            }
          }));
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            disposables.forEach((disposable) => disposable.dispose());
          });
        }
        updateCellMap(notebookDocument) {
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
          }
        }
      };
      exports2.NotebookDocuments = NotebookDocuments;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/utils/is.js
  var require_is9 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports2.typedArray = typedArray;
      function thenable(value) {
        return value && func(value.then);
      }
      exports2.thenable = thenable;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/utils/uuid.js
  var require_uuid3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
      var ValueUUID = class {
        constructor(_value) {
          this._value = _value;
        }
        asHex() {
          return this._value;
        }
        equals(other) {
          return this.asHex() === other.asHex();
        }
      };
      var V4UUID = class _V4UUID extends ValueUUID {
        constructor() {
          super([
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            "4",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._oneOf(_V4UUID._timeHighBits),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            "-",
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex(),
            _V4UUID._randomHex()
          ].join(""));
        }
        static _oneOf(array) {
          return array[Math.floor(array.length * Math.random())];
        }
        static _randomHex() {
          return _V4UUID._oneOf(_V4UUID._chars);
        }
      };
      V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      V4UUID._timeHighBits = ["8", "9", "a", "b"];
      exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
      function v4() {
        return new V4UUID();
      }
      exports2.v4 = v4;
      var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      function isUUID(value) {
        return _UUIDPattern.test(value);
      }
      exports2.isUUID = isUUID;
      function parse(value) {
        if (!isUUID(value)) {
          throw new Error("invalid uuid");
        }
        return new ValueUUID(value);
      }
      exports2.parse = parse;
      function generateUuid() {
        return v4().asHex();
      }
      exports2.generateUuid = generateUuid;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/progress.js
  var require_progress3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var uuid_1 = require_uuid3();
      var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
        constructor(_connection, _token) {
          this._connection = _connection;
          this._token = _token;
          _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
        }
        begin(title, percentage, message, cancellable) {
          let param = {
            kind: "begin",
            title,
            percentage,
            message,
            cancellable
          };
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
        }
        report(arg0, arg1) {
          let param = {
            kind: "report"
          };
          if (typeof arg0 === "number") {
            param.percentage = arg0;
            if (arg1 !== void 0) {
              param.message = arg1;
            }
          } else {
            param.message = arg0;
          }
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
        }
        done() {
          _WorkDoneProgressReporterImpl.Instances.delete(this._token);
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
        }
      };
      WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
      var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
        constructor(connection2, token) {
          super(connection2, token);
          this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        }
        get token() {
          return this._source.token;
        }
        done() {
          this._source.dispose();
          super.done();
        }
        cancel() {
          this._source.cancel();
        }
      };
      var NullProgressReporter = class {
        constructor() {
        }
        begin() {
        }
        report() {
        }
        done() {
        }
      };
      var NullProgressServerReporter = class extends NullProgressReporter {
        constructor() {
          super();
          this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        }
        get token() {
          return this._source.token;
        }
        done() {
          this._source.dispose();
        }
        cancel() {
          this._source.cancel();
        }
      };
      function attachWorkDone(connection2, params) {
        if (params === void 0 || params.workDoneToken === void 0) {
          return new NullProgressReporter();
        }
        const token = params.workDoneToken;
        delete params.workDoneToken;
        return new WorkDoneProgressReporterImpl(connection2, token);
      }
      exports2.attachWorkDone = attachWorkDone;
      var ProgressFeature = (Base) => {
        return class extends Base {
          constructor() {
            super();
            this._progressSupported = false;
          }
          initialize(capabilities) {
            super.initialize(capabilities);
            if (capabilities?.window?.workDoneProgress === true) {
              this._progressSupported = true;
              this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
                let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
                if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                  progress.cancel();
                }
              });
            }
          }
          attachWorkDoneProgress(token) {
            if (token === void 0) {
              return new NullProgressReporter();
            } else {
              return new WorkDoneProgressReporterImpl(this.connection, token);
            }
          }
          createWorkDoneProgress() {
            if (this._progressSupported) {
              const token = (0, uuid_1.generateUuid)();
              return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
                return result;
              });
            } else {
              return Promise.resolve(new NullProgressServerReporter());
            }
          }
        };
      };
      exports2.ProgressFeature = ProgressFeature;
      var ResultProgress;
      (function(ResultProgress2) {
        ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
      })(ResultProgress || (ResultProgress = {}));
      var ResultProgressReporterImpl = class {
        constructor(_connection, _token) {
          this._connection = _connection;
          this._token = _token;
        }
        report(data) {
          this._connection.sendProgress(ResultProgress.type, this._token, data);
        }
      };
      function attachPartialResult(connection2, params) {
        if (params === void 0 || params.partialResultToken === void 0) {
          return void 0;
        }
        const token = params.partialResultToken;
        delete params.partialResultToken;
        return new ResultProgressReporterImpl(connection2, token);
      }
      exports2.attachPartialResult = attachPartialResult;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/configuration.js
  var require_configuration3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConfigurationFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var Is3 = require_is9();
      var ConfigurationFeature = (Base) => {
        return class extends Base {
          getConfiguration(arg) {
            if (!arg) {
              return this._getConfiguration({});
            } else if (Is3.string(arg)) {
              return this._getConfiguration({ section: arg });
            } else {
              return this._getConfiguration(arg);
            }
          }
          _getConfiguration(arg) {
            let params = {
              items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
              if (Array.isArray(result)) {
                return Array.isArray(arg) ? result : result[0];
              } else {
                return Array.isArray(arg) ? [] : null;
              }
            });
          }
        };
      };
      exports2.ConfigurationFeature = ConfigurationFeature;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/workspaceFolder.js
  var require_workspaceFolder3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkspaceFoldersFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var WorkspaceFoldersFeature = (Base) => {
        return class extends Base {
          constructor() {
            super();
            this._notificationIsAutoRegistered = false;
          }
          initialize(capabilities) {
            super.initialize(capabilities);
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
              this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
              this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
                this._onDidChangeWorkspaceFolders.fire(params.event);
              });
            }
          }
          fillServerCapabilities(capabilities) {
            super.fillServerCapabilities(capabilities);
            const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
          }
          getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
          }
          get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
              throw new Error("Client doesn't support sending workspace folder change events.");
            }
            if (!this._notificationIsAutoRegistered && !this._unregistration) {
              this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
          }
        };
      };
      exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/callHierarchy.js
  var require_callHierarchy3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CallHierarchyFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var CallHierarchyFeature = (Base) => {
        return class extends Base {
          get callHierarchy() {
            return {
              onPrepare: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
                });
              },
              onIncomingCalls: (handler) => {
                const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onOutgoingCalls: (handler) => {
                const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.CallHierarchyFeature = CallHierarchyFeature;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/showDocument.js
  var require_showDocument3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ShowDocumentFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var ShowDocumentFeature = (Base) => {
        return class extends Base {
          showDocument(params) {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
          }
        };
      };
      exports2.ShowDocumentFeature = ShowDocumentFeature;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/fileOperations.js
  var require_fileOperations3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FileOperationsFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var FileOperationsFeature = (Base) => {
        return class extends Base {
          onDidCreateFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onDidRenameFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onDidDeleteFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onWillCreateFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
          onWillRenameFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
          onWillDeleteFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
        };
      };
      exports2.FileOperationsFeature = FileOperationsFeature;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
  var require_linkedEditingRange3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LinkedEditingRangeFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var LinkedEditingRangeFeature = (Base) => {
        return class extends Base {
          onLinkedEditingRange(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
            });
          }
        };
      };
      exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/typeHierarchy.js
  var require_typeHierarchy3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeHierarchyFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var TypeHierarchyFeature = (Base) => {
        return class extends Base {
          get typeHierarchy() {
            return {
              onPrepare: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
                });
              },
              onSupertypes: (handler) => {
                const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onSubtypes: (handler) => {
                const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.TypeHierarchyFeature = TypeHierarchyFeature;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/inlineValue.js
  var require_inlineValue3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineValueFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var InlineValueFeature = (Base) => {
        return class extends Base {
          get inlineValue() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params));
                });
              }
            };
          }
        };
      };
      exports2.InlineValueFeature = InlineValueFeature;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/inlayHint.js
  var require_inlayHint3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlayHintFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var InlayHintFeature = (Base) => {
        return class extends Base {
          get inlayHint() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params));
                });
              },
              resolve: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                  return handler(params, cancel);
                });
              }
            };
          }
        };
      };
      exports2.InlayHintFeature = InlayHintFeature;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/diagnostic.js
  var require_diagnostic3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DiagnosticFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var DiagnosticFeature = (Base) => {
        return class extends Base {
          get diagnostics() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
                });
              },
              onWorkspace: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
                });
              }
            };
          }
        };
      };
      exports2.DiagnosticFeature = DiagnosticFeature;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/moniker.js
  var require_moniker3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MonikerFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var MonikerFeature = (Base) => {
        return class extends Base {
          get moniker() {
            return {
              on: (handler) => {
                const type = vscode_languageserver_protocol_1.MonikerRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.MonikerFeature = MonikerFeature;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/server.js
  var require_server3 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
      var vscode_languageserver_protocol_1 = require_main9();
      var Is3 = require_is9();
      var UUID = require_uuid3();
      var progress_1 = require_progress3();
      var configuration_1 = require_configuration3();
      var workspaceFolder_1 = require_workspaceFolder3();
      var callHierarchy_1 = require_callHierarchy3();
      var semanticTokens_1 = require_semanticTokens3();
      var showDocument_1 = require_showDocument3();
      var fileOperations_1 = require_fileOperations3();
      var linkedEditingRange_1 = require_linkedEditingRange3();
      var typeHierarchy_1 = require_typeHierarchy3();
      var inlineValue_1 = require_inlineValue3();
      var inlayHint_1 = require_inlayHint3();
      var diagnostic_1 = require_diagnostic3();
      var notebook_1 = require_notebook3();
      var moniker_1 = require_moniker3();
      function null2Undefined(value) {
        if (value === null) {
          return void 0;
        }
        return value;
      }
      var ErrorMessageTracker = class {
        constructor() {
          this._messages = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Add a message to the tracker.
         *
         * @param message The message to add.
         */
        add(message) {
          let count = this._messages[message];
          if (!count) {
            count = 0;
          }
          count++;
          this._messages[message] = count;
        }
        /**
         * Send all tracked messages to the connection's window.
         *
         * @param connection The connection established between client and server.
         */
        sendErrors(connection2) {
          Object.keys(this._messages).forEach((message) => {
            connection2.window.showErrorMessage(message);
          });
        }
      };
      exports2.ErrorMessageTracker = ErrorMessageTracker;
      var RemoteConsoleImpl = class {
        constructor() {
        }
        rawAttach(connection2) {
          this._rawConnection = connection2;
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        fillServerCapabilities(_capabilities) {
        }
        initialize(_capabilities) {
        }
        error(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
        }
        warn(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
        }
        info(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
        }
        log(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
        }
        send(type, message) {
          if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
              (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
            });
          }
        }
      };
      var _RemoteWindowImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        showErrorMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
        showWarningMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
        showInformationMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
      };
      var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
      var BulkRegistration;
      (function(BulkRegistration2) {
        function create() {
          return new BulkRegistrationImpl();
        }
        BulkRegistration2.create = create;
      })(BulkRegistration = exports2.BulkRegistration || (exports2.BulkRegistration = {}));
      var BulkRegistrationImpl = class {
        constructor() {
          this._registrations = [];
          this._registered = /* @__PURE__ */ new Set();
        }
        add(type, registerOptions) {
          const method = Is3.string(type) ? type : type.method;
          if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
          }
          const id = UUID.generateUuid();
          this._registrations.push({
            id,
            method,
            registerOptions: registerOptions || {}
          });
          this._registered.add(method);
        }
        asRegistrationParams() {
          return {
            registrations: this._registrations
          };
        }
      };
      var BulkUnregistration;
      (function(BulkUnregistration2) {
        function create() {
          return new BulkUnregistrationImpl(void 0, []);
        }
        BulkUnregistration2.create = create;
      })(BulkUnregistration = exports2.BulkUnregistration || (exports2.BulkUnregistration = {}));
      var BulkUnregistrationImpl = class {
        constructor(_connection, unregistrations) {
          this._connection = _connection;
          this._unregistrations = /* @__PURE__ */ new Map();
          unregistrations.forEach((unregistration) => {
            this._unregistrations.set(unregistration.method, unregistration);
          });
        }
        get isAttached() {
          return !!this._connection;
        }
        attach(connection2) {
          this._connection = connection2;
        }
        add(unregistration) {
          this._unregistrations.set(unregistration.method, unregistration);
        }
        dispose() {
          let unregistrations = [];
          for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
          }
          let params = {
            unregisterations: unregistrations
          };
          this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this._connection.console.info(`Bulk unregistration failed.`);
          });
        }
        disposeSingle(arg) {
          const method = Is3.string(arg) ? arg : arg.method;
          const unregistration = this._unregistrations.get(method);
          if (!unregistration) {
            return false;
          }
          let params = {
            unregisterations: [unregistration]
          };
          this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
          }, (_error) => {
            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
          });
          return true;
        }
      };
      var RemoteClientImpl = class {
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
          if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
          } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
          } else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
          }
        }
        registerSingle1(unregistration, type, registerOptions) {
          const method = Is3.string(type) ? type : type.method;
          const id = UUID.generateUuid();
          let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
          };
          if (!unregistration.isAttached) {
            unregistration.attach(this.connection);
          }
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id, method });
            return unregistration;
          }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
          });
        }
        registerSingle2(type, registerOptions) {
          const method = Is3.string(type) ? type : type.method;
          const id = UUID.generateUuid();
          let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
              this.unregisterSingle(id, method).catch(() => {
                this.connection.console.info(`Un-registering capability with id ${id} failed.`);
              });
            });
          }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
          });
        }
        unregisterSingle(id, method) {
          let params = {
            unregisterations: [{ id, method }]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this.connection.console.info(`Un-registering request handler for ${id} failed.`);
          });
        }
        registerMany(registrations) {
          let params = registrations.asRegistrationParams();
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
              return { id: registration.id, method: registration.method };
            }));
          }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
          });
        }
      };
      var _RemoteWorkspaceImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        applyEdit(paramOrEdit) {
          function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
          }
          let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
        }
      };
      var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
      var TracerImpl = class {
        constructor() {
          this._trace = vscode_languageserver_protocol_1.Trace.Off;
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        set trace(value) {
          this._trace = value;
        }
        log(message, verbose) {
          if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
          }
          this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
          }).catch(() => {
          });
        }
      };
      var TelemetryImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        logEvent(data) {
          this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
            this.connection.console.log(`Sending TelemetryEventNotification failed`);
          });
        }
      };
      var _LanguagesImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        attachWorkDoneProgress(params) {
          return (0, progress_1.attachWorkDone)(this.connection, params);
        }
        attachPartialResultProgress(_type, params) {
          return (0, progress_1.attachPartialResult)(this.connection, params);
        }
      };
      exports2._LanguagesImpl = _LanguagesImpl;
      var LanguagesImpl = (0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl))))))));
      var _NotebooksImpl = class {
        constructor() {
        }
        attach(connection2) {
          this._connection = connection2;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        attachWorkDoneProgress(params) {
          return (0, progress_1.attachWorkDone)(this.connection, params);
        }
        attachPartialResultProgress(_type, params) {
          return (0, progress_1.attachPartialResult)(this.connection, params);
        }
      };
      exports2._NotebooksImpl = _NotebooksImpl;
      var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
      function combineConsoleFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineConsoleFeatures = combineConsoleFeatures;
      function combineTelemetryFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineTelemetryFeatures = combineTelemetryFeatures;
      function combineTracerFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineTracerFeatures = combineTracerFeatures;
      function combineClientFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineClientFeatures = combineClientFeatures;
      function combineWindowFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineWindowFeatures = combineWindowFeatures;
      function combineWorkspaceFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
      function combineLanguagesFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineLanguagesFeatures = combineLanguagesFeatures;
      function combineNotebooksFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineNotebooksFeatures = combineNotebooksFeatures;
      function combineFeatures(one, two) {
        function combine(one2, two2, func) {
          if (one2 && two2) {
            return func(one2, two2);
          } else if (one2) {
            return one2;
          } else {
            return two2;
          }
        }
        let result = {
          __brand: "features",
          console: combine(one.console, two.console, combineConsoleFeatures),
          tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
          telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
          client: combine(one.client, two.client, combineClientFeatures),
          window: combine(one.window, two.window, combineWindowFeatures),
          workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
          languages: combine(one.languages, two.languages, combineLanguagesFeatures),
          notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
        };
        return result;
      }
      exports2.combineFeatures = combineFeatures;
      function createConnection2(connectionFactory, watchDog, factories) {
        const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
        const connection2 = connectionFactory(logger);
        logger.rawAttach(connection2);
        const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
        const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
        const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
        const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
        const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
        const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
        const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
        const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
        function asPromise(value) {
          if (value instanceof Promise) {
            return value;
          } else if (Is3.thenable(value)) {
            return new Promise((resolve, reject2) => {
              value.then((resolved) => resolve(resolved), (error) => reject2(error));
            });
          } else {
            return Promise.resolve(value);
          }
        }
        let shutdownHandler = void 0;
        let initializeHandler = void 0;
        let exitHandler = void 0;
        let protocolConnection = {
          listen: () => connection2.listen(),
          sendRequest: (type, ...params) => connection2.sendRequest(Is3.string(type) ? type : type.method, ...params),
          onRequest: (type, handler) => connection2.onRequest(type, handler),
          sendNotification: (type, param) => {
            const method = Is3.string(type) ? type : type.method;
            if (arguments.length === 1) {
              return connection2.sendNotification(method);
            } else {
              return connection2.sendNotification(method, param);
            }
          },
          onNotification: (type, handler) => connection2.onNotification(type, handler),
          onProgress: connection2.onProgress,
          sendProgress: connection2.sendProgress,
          onInitialize: (handler) => {
            initializeHandler = handler;
            return {
              dispose: () => {
                initializeHandler = void 0;
              }
            };
          },
          onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
          onShutdown: (handler) => {
            shutdownHandler = handler;
            return {
              dispose: () => {
                shutdownHandler = void 0;
              }
            };
          },
          onExit: (handler) => {
            exitHandler = handler;
            return {
              dispose: () => {
                exitHandler = void 0;
              }
            };
          },
          get console() {
            return logger;
          },
          get telemetry() {
            return telemetry;
          },
          get tracer() {
            return tracer;
          },
          get client() {
            return client;
          },
          get window() {
            return remoteWindow;
          },
          get workspace() {
            return workspace;
          },
          get languages() {
            return languages;
          },
          get notebooks() {
            return notebooks;
          },
          onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
          onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
          __textDocumentSync: void 0,
          onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
          onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
          onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
          onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
          onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
          onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
          sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
          onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
          onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
          onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
          }),
          onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          }),
          dispose: () => connection2.dispose()
        };
        for (let remote of allRemotes) {
          remote.attach(protocolConnection);
        }
        connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
          watchDog.initialize(params);
          if (Is3.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
          }
          for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
          }
          if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
            return asPromise(result).then((value) => {
              if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                return value;
              }
              let result2 = value;
              if (!result2) {
                result2 = { capabilities: {} };
              }
              let capabilities = result2.capabilities;
              if (!capabilities) {
                capabilities = {};
                result2.capabilities = capabilities;
              }
              if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
                capabilities.textDocumentSync = Is3.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
              } else if (!Is3.number(capabilities.textDocumentSync) && !Is3.number(capabilities.textDocumentSync.change)) {
                capabilities.textDocumentSync.change = Is3.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
              }
              for (let remote of allRemotes) {
                remote.fillServerCapabilities(capabilities);
              }
              return result2;
            });
          } else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(result.capabilities);
            }
            return result;
          }
        });
        connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
          watchDog.shutdownReceived = true;
          if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
          } else {
            return void 0;
          }
        });
        connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
          try {
            if (exitHandler) {
              exitHandler();
            }
          } finally {
            if (watchDog.shutdownReceived) {
              watchDog.exit(0);
            } else {
              watchDog.exit(1);
            }
          }
        });
        connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
        });
        return protocolConnection;
      }
      exports2.createConnection = createConnection2;
    }
  });

  // ../node_modules/vscode-languageserver/lib/common/api.js
  var require_api9 = __commonJS({
    "../node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
      var semanticTokens_1 = require_semanticTokens3();
      Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
        return semanticTokens_1.SemanticTokensBuilder;
      } });
      __exportStar(require_main9(), exports2);
      var textDocuments_1 = require_textDocuments3();
      Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
        return textDocuments_1.TextDocuments;
      } });
      var notebook_1 = require_notebook3();
      Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
        return notebook_1.NotebookDocuments;
      } });
      __exportStar(require_server3(), exports2);
      var ProposedFeatures;
      (function(ProposedFeatures2) {
        ProposedFeatures2.all = {
          __brand: "features"
        };
      })(ProposedFeatures = exports2.ProposedFeatures || (exports2.ProposedFeatures = {}));
    }
  });

  // ../node_modules/vscode-languageserver-protocol/browser.js
  var require_browser7 = __commonJS({
    "../node_modules/vscode-languageserver-protocol/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = require_main9();
    }
  });

  // ../node_modules/vscode-languageserver/lib/browser/main.js
  var require_main10 = __commonJS({
    "../node_modules/vscode-languageserver/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createConnection = void 0;
      var api_1 = require_api9();
      __exportStar(require_browser7(), exports2);
      __exportStar(require_api9(), exports2);
      var _shutdownReceived = false;
      var watchDog = {
        initialize: (_params) => {
        },
        get shutdownReceived() {
          return _shutdownReceived;
        },
        set shutdownReceived(value) {
          _shutdownReceived = value;
        },
        exit: (_code) => {
        }
      };
      function createConnection2(arg1, arg2, arg3, arg4) {
        let factories;
        let reader;
        let writer;
        let options;
        if (arg1 !== void 0 && arg1.__brand === "features") {
          factories = arg1;
          arg1 = arg2;
          arg2 = arg3;
          arg3 = arg4;
        }
        if (api_1.ConnectionStrategy.is(arg1) || api_1.ConnectionOptions.is(arg1)) {
          options = arg1;
        } else {
          reader = arg1;
          writer = arg2;
          options = arg3;
        }
        const connectionFactory = (logger) => {
          return (0, api_1.createProtocolConnection)(reader, writer, logger, options);
        };
        return (0, api_1.createConnection)(connectionFactory, watchDog, factories);
      }
      exports2.createConnection = createConnection2;
    }
  });

  // ../node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "../node_modules/lodash/lodash.js"(exports2, module2) {
      (function() {
        var undefined2;
        var VERSION2 = "4.17.21";
        var LARGE_ARRAY_SIZE4 = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT3 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED4 = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE2 = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG2 = 1, CLONE_FLAT_FLAG2 = 2, CLONE_SYMBOLS_FLAG3 = 4;
        var COMPARE_PARTIAL_FLAG7 = 1, COMPARE_UNORDERED_FLAG5 = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY5 = 1 / 0, MAX_SAFE_INTEGER3 = 9007199254740991, MAX_INTEGER2 = 17976931348623157e292, NAN2 = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag5 = "[object Arguments]", arrayTag4 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag5 = "[object Boolean]", dateTag5 = "[object Date]", domExcTag = "[object DOMException]", errorTag4 = "[object Error]", funcTag4 = "[object Function]", genTag3 = "[object GeneratorFunction]", mapTag8 = "[object Map]", numberTag5 = "[object Number]", nullTag2 = "[object Null]", objectTag5 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag6 = "[object RegExp]", setTag8 = "[object Set]", stringTag6 = "[object String]", symbolTag5 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag4 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag5 = "[object ArrayBuffer]", dataViewTag6 = "[object DataView]", float32Tag4 = "[object Float32Array]", float64Tag4 = "[object Float64Array]", int8Tag4 = "[object Int8Array]", int16Tag4 = "[object Int16Array]", int32Tag4 = "[object Int32Array]", uint8Tag4 = "[object Uint8Array]", uint8ClampedTag4 = "[object Uint8ClampedArray]", uint16Tag4 = "[object Uint16Array]", uint32Tag4 = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
        var reTrimStart2 = /^\s+/;
        var reWhitespace2 = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar2 = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags2 = /\w*$/;
        var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary2 = /^0b[01]+$/i;
        var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
        var reIsOctal2 = /^0o[0-7]+$/i;
        var reIsUint2 = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags2 = {};
        typedArrayTags2[float32Tag4] = typedArrayTags2[float64Tag4] = typedArrayTags2[int8Tag4] = typedArrayTags2[int16Tag4] = typedArrayTags2[int32Tag4] = typedArrayTags2[uint8Tag4] = typedArrayTags2[uint8ClampedTag4] = typedArrayTags2[uint16Tag4] = typedArrayTags2[uint32Tag4] = true;
        typedArrayTags2[argsTag5] = typedArrayTags2[arrayTag4] = typedArrayTags2[arrayBufferTag5] = typedArrayTags2[boolTag5] = typedArrayTags2[dataViewTag6] = typedArrayTags2[dateTag5] = typedArrayTags2[errorTag4] = typedArrayTags2[funcTag4] = typedArrayTags2[mapTag8] = typedArrayTags2[numberTag5] = typedArrayTags2[objectTag5] = typedArrayTags2[regexpTag6] = typedArrayTags2[setTag8] = typedArrayTags2[stringTag6] = typedArrayTags2[weakMapTag4] = false;
        var cloneableTags2 = {};
        cloneableTags2[argsTag5] = cloneableTags2[arrayTag4] = cloneableTags2[arrayBufferTag5] = cloneableTags2[dataViewTag6] = cloneableTags2[boolTag5] = cloneableTags2[dateTag5] = cloneableTags2[float32Tag4] = cloneableTags2[float64Tag4] = cloneableTags2[int8Tag4] = cloneableTags2[int16Tag4] = cloneableTags2[int32Tag4] = cloneableTags2[mapTag8] = cloneableTags2[numberTag5] = cloneableTags2[objectTag5] = cloneableTags2[regexpTag6] = cloneableTags2[setTag8] = cloneableTags2[stringTag6] = cloneableTags2[symbolTag5] = cloneableTags2[uint8Tag4] = cloneableTags2[uint8ClampedTag4] = cloneableTags2[uint16Tag4] = cloneableTags2[uint32Tag4] = true;
        cloneableTags2[errorTag4] = cloneableTags2[funcTag4] = cloneableTags2[weakMapTag4] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
        var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
        var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
        var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
        var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
        var freeProcess2 = moduleExports4 && freeGlobal2.process;
        var nodeUtil2 = function() {
          try {
            var types = freeModule4 && freeModule4.require && freeModule4.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap2 = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp2 = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet2 = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
        function apply2(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator2(array, setter, iteratee, accumulator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach2(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery2(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter2(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes2(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf2(array, value, 0) > -1;
        }
        function arrayIncludesWith2(array, value, comparator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap2(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush2(array, values2) {
          var index = -1, length = values2.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values2[index];
          }
          return array;
        }
        function arrayReduce2(array, iteratee, accumulator, initAccum) {
          var index = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome2(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty2("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex2(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf2(array, value, fromIndex) {
          return value === value ? strictIndexOf2(array, value, fromIndex) : baseFindIndex2(array, baseIsNaN2, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN2(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN2;
        }
        function baseProperty2(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce2(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes2(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap2(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim2(string) {
          return string ? string.slice(0, trimmedEndIndex2(string) + 1).replace(reTrimStart2, "") : string;
        }
        function baseUnary2(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues2(object, props) {
          return arrayMap2(props, function(key) {
            return object[key];
          });
        }
        function cacheHas2(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf2(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf2(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue2(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray2(map2) {
          var index = -1, result = Array(map2.size);
          map2.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg2(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray2(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf2(array, value, fromIndex) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex2(string) {
          var index = string.length;
          while (index-- && reWhitespace2.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root2 : _5.defaults(root2.Object(), context, _5.pick(root2, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto2 = Array2.prototype, funcProto3 = Function2.prototype, objectProto21 = Object2.prototype;
          var coreJsData2 = context["__core-js_shared__"];
          var funcToString3 = funcProto3.toString;
          var hasOwnProperty18 = objectProto21.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey2 = function() {
            var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString3 = objectProto21.toString;
          var objectCtorString = funcToString3.call(Object2);
          var oldDash = root2._;
          var reIsNative2 = RegExp2(
            "^" + funcToString3.call(hasOwnProperty18).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer4 = moduleExports4 ? context.Buffer : undefined2, Symbol3 = context.Symbol, Uint8Array3 = context.Uint8Array, allocUnsafe2 = Buffer4 ? Buffer4.allocUnsafe : undefined2, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate2 = Object2.create, propertyIsEnumerable3 = objectProto21.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol2 = Symbol3 ? Symbol3.isConcatSpreadable : undefined2, symIterator = Symbol3 ? Symbol3.iterator : undefined2, symToStringTag3 = Symbol3 ? Symbol3.toStringTag : undefined2;
          var defineProperty2 = function() {
            try {
              var func = getNative2(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols3 = Object2.getOwnPropertySymbols, nativeIsBuffer2 = Buffer4 ? Buffer4.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax5 = Math2.max, nativeMin = Math2.min, nativeNow2 = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
          var DataView2 = getNative2(context, "DataView"), Map3 = getNative2(context, "Map"), Promise3 = getNative2(context, "Promise"), Set3 = getNative2(context, "Set"), WeakMap2 = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map3), promiseCtorString2 = toSource2(Promise3), setCtorString2 = toSource2(Set3), weakMapCtorString2 = toSource2(WeakMap2);
          var symbolProto4 = Symbol3 ? Symbol3.prototype : undefined2, symbolValueOf3 = symbolProto4 ? symbolProto4.valueOf : undefined2, symbolToString2 = symbolProto4 ? symbolProto4.toString : undefined2;
          function lodash(value) {
            if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty18.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate2 = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject2(proto)) {
                return {};
              }
              if (objectCreate2) {
                return objectCreate2(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray2(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray2(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray2(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash2(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear2() {
            this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
            this.size = 0;
          }
          function hashDelete2(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet2(key) {
            var data = this.__data__;
            if (nativeCreate2) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED4 ? undefined2 : result2;
            }
            return hasOwnProperty18.call(data, key) ? data[key] : undefined2;
          }
          function hashHas2(key) {
            var data = this.__data__;
            return nativeCreate2 ? data[key] !== undefined2 : hasOwnProperty18.call(data, key);
          }
          function hashSet2(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate2 && value === undefined2 ? HASH_UNDEFINED4 : value;
            return this;
          }
          Hash2.prototype.clear = hashClear2;
          Hash2.prototype["delete"] = hashDelete2;
          Hash2.prototype.get = hashGet2;
          Hash2.prototype.has = hashHas2;
          Hash2.prototype.set = hashSet2;
          function ListCache2(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear2() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete2(key) {
            var data = this.__data__, index = assocIndexOf2(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice2.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet2(key) {
            var data = this.__data__, index = assocIndexOf2(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas2(key) {
            return assocIndexOf2(this.__data__, key) > -1;
          }
          function listCacheSet2(key, value) {
            var data = this.__data__, index = assocIndexOf2(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache2.prototype.clear = listCacheClear2;
          ListCache2.prototype["delete"] = listCacheDelete2;
          ListCache2.prototype.get = listCacheGet2;
          ListCache2.prototype.has = listCacheHas2;
          ListCache2.prototype.set = listCacheSet2;
          function MapCache2(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear2() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash2(),
              "map": new (Map3 || ListCache2)(),
              "string": new Hash2()
            };
          }
          function mapCacheDelete2(key) {
            var result2 = getMapData2(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet2(key) {
            return getMapData2(this, key).get(key);
          }
          function mapCacheHas2(key) {
            return getMapData2(this, key).has(key);
          }
          function mapCacheSet2(key, value) {
            var data = getMapData2(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache2.prototype.clear = mapCacheClear2;
          MapCache2.prototype["delete"] = mapCacheDelete2;
          MapCache2.prototype.get = mapCacheGet2;
          MapCache2.prototype.has = mapCacheHas2;
          MapCache2.prototype.set = mapCacheSet2;
          function SetCache2(values3) {
            var index = -1, length = values3 == null ? 0 : values3.length;
            this.__data__ = new MapCache2();
            while (++index < length) {
              this.add(values3[index]);
            }
          }
          function setCacheAdd2(value) {
            this.__data__.set(value, HASH_UNDEFINED4);
            return this;
          }
          function setCacheHas2(value) {
            return this.__data__.has(value);
          }
          SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
          SetCache2.prototype.has = setCacheHas2;
          function Stack2(entries) {
            var data = this.__data__ = new ListCache2(entries);
            this.size = data.size;
          }
          function stackClear2() {
            this.__data__ = new ListCache2();
            this.size = 0;
          }
          function stackDelete2(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet2(key) {
            return this.__data__.get(key);
          }
          function stackHas2(key) {
            return this.__data__.has(key);
          }
          function stackSet2(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache2) {
              var pairs = data.__data__;
              if (!Map3 || pairs.length < LARGE_ARRAY_SIZE4 - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache2(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack2.prototype.clear = stackClear2;
          Stack2.prototype["delete"] = stackDelete2;
          Stack2.prototype.get = stackGet2;
          Stack2.prototype.has = stackHas2;
          Stack2.prototype.set = stackSet2;
          function arrayLikeKeys2(value, inherited) {
            var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType3 = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType3, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty18.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType3 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex2(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray2(array), baseClamp(n, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray2(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq2(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue2(object, key, value);
            }
          }
          function assignValue2(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty18.call(object, key) && eq2(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue2(object, key, value);
            }
          }
          function assocIndexOf2(array, key) {
            var length = array.length;
            while (length--) {
              if (eq2(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator2(collection, setter, iteratee2, accumulator) {
            baseEach2(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign2(object, source) {
            return object && copyObject2(source, keys2(source), object);
          }
          function baseAssignIn2(object, source) {
            return object && copyObject2(source, keysIn2(source), object);
          }
          function baseAssignValue2(object, key, value) {
            if (key == "__proto__" && defineProperty2) {
              defineProperty2(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get2(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone2(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG2, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG3;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject2(value)) {
              return value;
            }
            var isArr = isArray2(value);
            if (isArr) {
              result2 = initCloneArray2(value);
              if (!isDeep) {
                return copyArray2(value, result2);
              }
            } else {
              var tag = getTag2(value), isFunc = tag == funcTag4 || tag == genTag3;
              if (isBuffer2(value)) {
                return cloneBuffer2(value, isDeep);
              }
              if (tag == objectTag5 || tag == argsTag5 || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject2(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn2(value, baseAssignIn2(result2, value)) : copySymbols2(value, baseAssign2(result2, value));
                }
              } else {
                if (!cloneableTags2[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag2(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack2());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet2(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone2(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap2(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn2 : getAllKeys2 : isFlat ? keysIn2 : keys2;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach2(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue2(result2, key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys2(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference2(array, values3, iteratee2, comparator) {
            var index = -1, includes3 = arrayIncludes2, isCommon = true, length = array.length, result2 = [], valuesLength = values3.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values3 = arrayMap2(values3, baseUnary2(iteratee2));
            }
            if (comparator) {
              includes3 = arrayIncludesWith2;
              isCommon = false;
            } else if (values3.length >= LARGE_ARRAY_SIZE4) {
              includes3 = cacheHas2;
              isCommon = false;
              values3 = new SetCache2(values3);
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values3[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes3(values3, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach2 = createBaseEach2(baseForOwn2);
          var baseEachRight = createBaseEach2(baseForOwnRight, true);
          function baseEvery2(collection, predicate) {
            var result2 = true;
            baseEach2(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum2(array, iteratee2, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger2(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger2(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter2(collection, predicate) {
            var result2 = [];
            baseEach2(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten2(array, depth, predicate, isStrict, result2) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable2);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten2(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush2(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor2 = createBaseFor2();
          var baseForRight = createBaseFor2(true);
          function baseForOwn2(object, iteratee2) {
            return object && baseFor2(object, iteratee2, keys2);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys2);
          }
          function baseFunctions(object, props) {
            return arrayFilter2(props, function(key) {
              return isFunction2(object[key]);
            });
          }
          function baseGet2(object, path) {
            path = castPath2(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey2(path[index++])];
            }
            return index && index == length ? object : undefined2;
          }
          function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray2(object) ? result2 : arrayPush2(result2, symbolsFunc(object));
          }
          function baseGetTag2(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag2 : nullTag2;
            }
            return symToStringTag3 && symToStringTag3 in Object2(value) ? getRawTag2(value) : objectToString2(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas2(object, key) {
            return object != null && hasOwnProperty18.call(object, key);
          }
          function baseHasIn2(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax5(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes3 = comparator ? arrayIncludesWith2 : arrayIncludes2, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap2(array, baseUnary2(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache2(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas2(seen, computed) : includes3(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas2(cache, computed) : includes3(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn2(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath2(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey2(last2(path))];
            return func == null ? undefined2 : apply2(func, object, args);
          }
          function baseIsArguments2(value) {
            return isObjectLike2(value) && baseGetTag2(value) == argsTag5;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag5;
          }
          function baseIsDate(value) {
            return isObjectLike2(value) && baseGetTag2(value) == dateTag5;
          }
          function baseIsEqual2(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack);
          }
          function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag4 : getTag2(object), othTag = othIsArr ? arrayTag4 : getTag2(other);
            objTag = objTag == argsTag5 ? objectTag5 : objTag;
            othTag = othTag == argsTag5 ? objectTag5 : othTag;
            var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer2(object)) {
              if (!isBuffer2(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack2());
              return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG7)) {
              var objIsWrapped = objIsObj && hasOwnProperty18.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty18.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack2());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack2());
            return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap2(value) {
            return isObjectLike2(value) && getTag2(value) == mapTag8;
          }
          function baseIsMatch2(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack2();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG7 | COMPARE_UNORDERED_FLAG5, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative2(value) {
            if (!isObject2(value) || isMasked2(value)) {
              return false;
            }
            var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
            return pattern.test(toSource2(value));
          }
          function baseIsRegExp2(value) {
            return isObjectLike2(value) && baseGetTag2(value) == regexpTag6;
          }
          function baseIsSet2(value) {
            return isObjectLike2(value) && getTag2(value) == setTag8;
          }
          function baseIsTypedArray2(value) {
            return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
          }
          function baseIteratee2(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity2;
            }
            if (typeof value == "object") {
              return isArray2(value) ? baseMatchesProperty2(value[0], value[1]) : baseMatches2(value);
            }
            return property2(value);
          }
          function baseKeys2(object) {
            if (!isPrototype2(object)) {
              return nativeKeys2(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty18.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn2(object) {
            if (!isObject2(object)) {
              return nativeKeysIn2(object);
            }
            var isProto = isPrototype2(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty18.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt2(value, other) {
            return value < other;
          }
          function baseMap2(collection, iteratee2) {
            var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
            baseEach2(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches2(source) {
            var matchData = getMatchData2(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable2(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch2(object, source, matchData);
            };
          }
          function baseMatchesProperty2(path, srcValue) {
            if (isKey2(path) && isStrictComparable2(srcValue)) {
              return matchesStrictComparable2(toKey2(path), srcValue);
            }
            return function(object) {
              var objValue = get2(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn2(object, path) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG7 | COMPARE_UNORDERED_FLAG5);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor2(source, function(srcValue, key) {
              stack || (stack = new Stack2());
              if (isObject2(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn2);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray2(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject2(objValue)) {
                  newValue = copyArray2(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer2(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray2(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments2(srcValue)) {
                newValue = objValue;
                if (isArguments2(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject2(objValue) || isFunction2(objValue)) {
                  newValue = initCloneObject2(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n) {
            var length = array.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex2(n, length) ? array[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap2(iteratees, function(iteratee2) {
                if (isArray2(iteratee2)) {
                  return function(value) {
                    return baseGet2(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity2];
            }
            var index = -1;
            iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
            var result2 = baseMap2(collection, function(value, key, collection2) {
              var criteria = arrayMap2(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy2(object, paths, function(value, path) {
              return hasIn2(object, path);
            });
          }
          function basePickBy2(object, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path = paths[index], value = baseGet2(object, path);
              if (predicate(value, path)) {
                baseSet2(result2, castPath2(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep2(path) {
            return function(object) {
              return baseGet2(object, path);
            };
          }
          function basePullAll(array, values3, iteratee2, comparator) {
            var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf2, index = -1, length = values3.length, seen = array;
            if (array === values3) {
              values3 = copyArray2(values3);
            }
            if (iteratee2) {
              seen = arrayMap2(array, baseUnary2(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values3[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf3(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice2.call(seen, fromIndex, 1);
                }
                splice2.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex2(index)) {
                  splice2.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax5(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER3) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest2(func, start) {
            return setToString2(overRest2(func, start, identity2), func + "");
          }
          function baseSample(collection) {
            return arraySample(values2(collection));
          }
          function baseSampleSize(collection, n) {
            var array = values2(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          function baseSet2(object, path, value, customizer) {
            if (!isObject2(object)) {
              return object;
            }
            path = castPath2(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey2(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject2(objValue) ? objValue : isIndex2(path[index + 1]) ? [] : {};
                }
              }
              assignValue2(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity2 : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString2 = !defineProperty2 ? identity2 : function(func, string) {
            return defineProperty2(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant2(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values2(collection));
          }
          function baseSlice2(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array[index + start];
            }
            return result2;
          }
          function baseSome2(collection, predicate) {
            var result2;
            baseEach2(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity2, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq2(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN2;
            }
            return +value;
          }
          function baseToString2(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray2(value)) {
              return arrayMap2(value, baseToString2) + "";
            }
            if (isSymbol2(value)) {
              return symbolToString2 ? symbolToString2.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY5 ? "-0" : result2;
          }
          function baseUniq2(array, iteratee2, comparator) {
            var index = -1, includes3 = arrayIncludes2, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes3 = arrayIncludesWith2;
            } else if (length >= LARGE_ARRAY_SIZE4) {
              var set2 = iteratee2 ? null : createSet2(array);
              if (set2) {
                return setToArray2(set2);
              }
              isCommon = false;
              includes3 = cacheHas2;
              seen = new SetCache2();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes3(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath2(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey2(last2(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet2(object, path, updater(baseGet2(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice2(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice2(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce2(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush2([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq2(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference2(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq2(baseFlatten2(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values3, assignFunc) {
            var index = -1, length = props.length, valsLength = values3.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values3[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject2(value) ? value : [];
          }
          function castFunction2(value) {
            return typeof value == "function" ? value : identity2;
          }
          function castPath2(value, object) {
            if (isArray2(value)) {
              return value;
            }
            return isKey2(value, object) ? [value] : stringToPath2(toString4(value));
          }
          var castRest = baseRest2;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array : baseSlice2(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root2.clearTimeout(id);
          };
          function cloneBuffer2(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer2(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array3(result2).set(new Uint8Array3(arrayBuffer));
            return result2;
          }
          function cloneDataView2(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp2(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol2(symbol) {
            return symbolValueOf3 ? Object2(symbolValueOf3.call(symbol)) : {};
          }
          function cloneTypedArray2(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax5(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax5(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray2(source, array) {
            var index = -1, length = source.length;
            array || (array = Array2(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject2(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue2(object, key, newValue);
              } else {
                assignValue2(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols2(source, object) {
            return copyObject2(source, getSymbols2(source), object);
          }
          function copySymbolsIn2(source, object) {
            return copyObject2(source, getSymbolsIn2(source), object);
          }
          function createAggregator2(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray2(collection) ? arrayAggregator2 : baseAggregator2, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner2(assigner) {
            return baseRest2(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach2(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike2(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor2(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString4(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce2(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate2(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject2(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              return apply2(fn, this, args);
            }
            return wrapper;
          }
          function createFind2(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike2(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys2(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT3);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray2(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root2 && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString2(value);
                  other = baseToString2(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
              return baseRest2(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply2(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString2(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply2(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall2(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite2(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite2(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite2(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber2(value);
                other = toNumber2(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber2(number);
              precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString4(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString4(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet2 = !(Set3 && 1 / setToArray2(new Set3([, -0]))[1] == INFINITY5) ? noop2 : function(values3) {
            return new Set3(values3);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag2(object);
              if (tag == mapTag8) {
                return mapToArray2(object);
              }
              if (tag == setTag8) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax5(toInteger2(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger2(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax5(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq2(objValue, objectProto21[key]) && !hasOwnProperty18.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject2(objValue) && isObject2(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays2(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG7, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG5 ? new SetCache2() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome2(other, function(othValue2, othIndex) {
                  if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag6:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag5:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
                  return false;
                }
                return true;
              case boolTag5:
              case dateTag5:
              case numberTag5:
                return eq2(+object, +other);
              case errorTag4:
                return object.name == other.name && object.message == other.message;
              case regexpTag6:
              case stringTag6:
                return object == other + "";
              case mapTag8:
                var convert = mapToArray2;
              case setTag8:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG7;
                convert || (convert = setToArray2);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG5;
                stack.set(object, other);
                var result2 = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag5:
                if (symbolValueOf3) {
                  return symbolValueOf3.call(object) == symbolValueOf3.call(other);
                }
            }
            return false;
          }
          function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG7, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty18.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString2(overRest2(func, undefined2, flatten2), func + "");
          }
          function getAllKeys2(object) {
            return baseGetAllKeys2(object, keys2, getSymbols2);
          }
          function getAllKeysIn2(object) {
            return baseGetAllKeys2(object, keysIn2, getSymbolsIn2);
          }
          var getData = !metaMap ? noop2 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty18.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty18.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee2 : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData2(map3, key) {
            var data = map3.__data__;
            return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData2(object) {
            var result2 = keys2(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable2(value)];
            }
            return result2;
          }
          function getNative2(object, key) {
            var value = getValue2(object, key);
            return baseIsNative2(value) ? value : undefined2;
          }
          function getRawTag2(value) {
            var isOwn = hasOwnProperty18.call(value, symToStringTag3), tag = value[symToStringTag3];
            try {
              value[symToStringTag3] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString3.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag3] = tag;
              } else {
                delete value[symToStringTag3];
              }
            }
            return result2;
          }
          var getSymbols2 = !nativeGetSymbols3 ? stubArray2 : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter2(nativeGetSymbols3(object), function(symbol) {
              return propertyIsEnumerable3.call(object, symbol);
            });
          };
          var getSymbolsIn2 = !nativeGetSymbols3 ? stubArray2 : function(object) {
            var result2 = [];
            while (object) {
              arrayPush2(result2, getSymbols2(object));
              object = getPrototype2(object);
            }
            return result2;
          };
          var getTag2 = baseGetTag2;
          if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag6 || Map3 && getTag2(new Map3()) != mapTag8 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set3 && getTag2(new Set3()) != setTag8 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag4) {
            getTag2 = function(value) {
              var result2 = baseGetTag2(value), Ctor = result2 == objectTag5 ? value.constructor : undefined2, ctorString = Ctor ? toSource2(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString2:
                    return dataViewTag6;
                  case mapCtorString2:
                    return mapTag8;
                  case promiseCtorString2:
                    return promiseTag2;
                  case setCtorString2:
                    return setTag8;
                  case weakMapCtorString2:
                    return weakMapTag4;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax5(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath2(object, path, hasFunc) {
            path = castPath2(path, object);
            var index = -1, length = path.length, result2 = false;
            while (++index < length) {
              var key = toKey2(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength2(length) && isIndex2(key, length) && (isArray2(object) || isArguments2(object));
          }
          function initCloneArray2(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty18.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject2(object) {
            return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
          }
          function initCloneByTag2(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag5:
                return cloneArrayBuffer2(object);
              case boolTag5:
              case dateTag5:
                return new Ctor(+object);
              case dataViewTag6:
                return cloneDataView2(object, isDeep);
              case float32Tag4:
              case float64Tag4:
              case int8Tag4:
              case int16Tag4:
              case int32Tag4:
              case uint8Tag4:
              case uint8ClampedTag4:
              case uint16Tag4:
              case uint32Tag4:
                return cloneTypedArray2(object, isDeep);
              case mapTag8:
                return new Ctor();
              case numberTag5:
              case stringTag6:
                return new Ctor(object);
              case regexpTag6:
                return cloneRegExp2(object);
              case setTag8:
                return new Ctor();
              case symbolTag5:
                return cloneSymbol2(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable2(value) {
            return isArray2(value) || isArguments2(value) || !!(spreadableSymbol2 && value && value[spreadableSymbol2]);
          }
          function isIndex2(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER3 : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall2(value, index, object) {
            if (!isObject2(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike2(object) && isIndex2(index, object.length) : type == "string" && index in object) {
              return eq2(object[index], value);
            }
            return false;
          }
          function isKey2(value, object) {
            if (isArray2(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
              return true;
            }
            return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object2(object);
          }
          function isKeyable2(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked2(func) {
            return !!maskSrcKey2 && maskSrcKey2 in func;
          }
          var isMaskable = coreJsData2 ? isFunction2 : stubFalse2;
          function isPrototype2(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto21;
            return value === proto;
          }
          function isStrictComparable2(value) {
            return value === value && !isObject2(value);
          }
          function matchesStrictComparable2(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped2(func) {
            var result2 = memoize2(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE2) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn2(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString2(value) {
            return nativeObjectToString3.call(value);
          }
          function overRest2(func, start, transform2) {
            start = nativeMax5(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax5(args.length - start, 0), array = Array2(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array2(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform2(array);
              return apply2(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet2(object, baseSlice2(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray2(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex2(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut2(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root2.setTimeout(func, wait);
          };
          var setToString2 = shortOut2(baseSetToString2);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString2(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut2(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT2) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath2 = memoizeCapped2(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName2, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar2, "$1") : number || match);
            });
            return result2;
          });
          function toKey2(value) {
            if (typeof value == "string" || isSymbol2(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY5 ? "-0" : result2;
          }
          function toSource2(func) {
            if (func != null) {
              try {
                return funcToString3.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach2(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes2(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray2(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall2(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax5(toInteger2(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice2(array, index, index += size2);
            }
            return result2;
          }
          function compact2(array) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush2(isArray2(array) ? copyArray2(array) : [array], baseFlatten2(args, 1));
          }
          var difference2 = baseRest2(function(array, values3) {
            return isArrayLikeObject2(array) ? baseDifference2(array, baseFlatten2(values3, 1, isArrayLikeObject2, true)) : [];
          });
          var differenceBy = baseRest2(function(array, values3) {
            var iteratee2 = last2(values3);
            if (isArrayLikeObject2(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject2(array) ? baseDifference2(array, baseFlatten2(values3, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest2(function(array, values3) {
            var comparator = last2(values3);
            if (isArrayLikeObject2(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject2(array) ? baseDifference2(array, baseFlatten2(values3, 1, isArrayLikeObject2, true), undefined2, comparator) : [];
          });
          function drop2(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger2(n);
            return baseSlice2(array, n < 0 ? 0 : n, length);
          }
          function dropRight2(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger2(n);
            n = length - n;
            return baseSlice2(array, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall2(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex2(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger2(fromIndex);
            if (index < 0) {
              index = nativeMax5(length + index, 0);
            }
            return baseFindIndex2(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger2(fromIndex);
              index = fromIndex < 0 ? nativeMax5(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex2(array, getIteratee(predicate, 3), index, true);
          }
          function flatten2(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten2(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten2(array, INFINITY5) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger2(depth);
            return baseFlatten2(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head2(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf2(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger2(fromIndex);
            if (index < 0) {
              index = nativeMax5(length + index, 0);
            }
            return baseIndexOf2(array, value, index);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice2(array, 0, -1) : [];
          }
          var intersection = baseRest2(function(arrays) {
            var mapped = arrayMap2(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest2(function(arrays) {
            var iteratee2 = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
            if (iteratee2 === last2(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest2(function(arrays) {
            var comparator = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last2(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger2(fromIndex);
              index = index < 0 ? nativeMax5(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex2(array, baseIsNaN2, index, true);
          }
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger2(n)) : undefined2;
          }
          var pull = baseRest2(pullAll);
          function pullAll(array, values3) {
            return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
          }
          function pullAllBy(array, values3, iteratee2) {
            return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values3, comparator) {
            return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap2(indexes, function(index) {
              return isIndex2(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall2(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger2(start);
              end = end === undefined2 ? length : toInteger2(end);
            }
            return baseSlice2(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq2(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq2(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice2(array, 1, length) : [];
          }
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger2(n);
            return baseSlice2(array, 0, n < 0 ? 0 : n);
          }
          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger2(n);
            n = length - n;
            return baseSlice2(array, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest2(function(arrays) {
            return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true));
          });
          var unionBy = baseRest2(function(arrays) {
            var iteratee2 = last2(arrays);
            if (isArrayLikeObject2(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest2(function(arrays) {
            var comparator = last2(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true), undefined2, comparator);
          });
          function uniq2(array) {
            return array && array.length ? baseUniq2(array) : [];
          }
          function uniqBy2(array, iteratee2) {
            return array && array.length ? baseUniq2(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq2(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter2(array, function(group) {
              if (isArrayLikeObject2(group)) {
                length = nativeMax5(group.length, length);
                return true;
              }
            });
            return baseTimes2(length, function(index) {
              return arrayMap2(array, baseProperty2(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap2(result2, function(group) {
              return apply2(iteratee2, undefined2, group);
            });
          }
          var without = baseRest2(function(array, values3) {
            return isArrayLikeObject2(array) ? baseDifference2(array, values3) : [];
          });
          var xor = baseRest2(function(arrays) {
            return baseXor(arrayFilter2(arrays, isArrayLikeObject2));
          });
          var xorBy = baseRest2(function(arrays) {
            var iteratee2 = last2(arrays);
            if (isArrayLikeObject2(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter2(arrays, isArrayLikeObject2), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest2(function(arrays) {
            var comparator = last2(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter2(arrays, isArrayLikeObject2), undefined2, comparator);
          });
          var zip = baseRest2(unzip);
          function zipObject(props, values3) {
            return baseZipObject(props || [], values3 || [], assignValue2);
          }
          function zipObjectDeep(props, values3) {
            return baseZipObject(props || [], values3 || [], baseSet2);
          }
          var zipWith = baseRest2(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone3 = wrapperClone(parent2);
              clone3.__index__ = 0;
              clone3.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone3;
              } else {
                result2 = clone3;
              }
              var previous = clone3;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator2(function(result2, value, key) {
            if (hasOwnProperty18.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue2(result2, key, 1);
            }
          });
          function every2(collection, predicate, guard) {
            var func = isArray2(collection) ? arrayEvery2 : baseEvery2;
            if (guard && isIterateeCall2(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter2(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter2 : baseFilter2;
            return func(collection, getIteratee(predicate, 3));
          }
          var find2 = createFind2(findIndex2);
          var findLast = createFind2(findLastIndex);
          function flatMap3(collection, iteratee2) {
            return baseFlatten2(map2(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten2(map2(collection, iteratee2), INFINITY5);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger2(depth);
            return baseFlatten2(map2(collection, iteratee2), depth);
          }
          function forEach2(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEach2 : baseEach2;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy2 = createAggregator2(function(result2, value, key) {
            if (hasOwnProperty18.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue2(result2, key, [value]);
            }
          });
          function includes2(collection, value, fromIndex, guard) {
            collection = isArrayLike2(collection) ? collection : values2(collection);
            fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax5(length + fromIndex, 0);
            }
            return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf2(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest2(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
            baseEach2(collection, function(value) {
              result2[++index] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator2(function(result2, value, key) {
            baseAssignValue2(result2, key, value);
          });
          function map2(collection, iteratee2) {
            var func = isArray2(collection) ? arrayMap2 : baseMap2;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray2(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray2(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator2(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce2(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduce2 : baseReduce2, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach2);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduceRight : baseReduce2, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject2(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter2 : baseFilter2;
            return func(collection, negate2(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray2(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall2(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger2(n);
            }
            var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray2(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike2(collection)) {
              return isString2(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag2(collection);
            if (tag == mapTag8 || tag == setTag8) {
              return collection.size;
            }
            return baseKeys2(collection).length;
          }
          function some2(collection, predicate, guard) {
            var func = isArray2(collection) ? arraySome2 : baseSome2;
            if (guard && isIterateeCall2(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest2(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten2(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root2.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            n = toInteger2(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            n = toInteger2(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest2(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest2(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            wait = toNumber2(wait) || 0;
            if (isObject2(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax5(toNumber2(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest2(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest2(function(func, wait, args) {
            return baseDelay(func, toNumber2(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize2(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize2.Cache || MapCache2)();
            return memoized;
          }
          memoize2.Cache = MapCache2;
          function negate2(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap2(transforms[0], baseUnary2(getIteratee())) : arrayMap2(baseFlatten2(transforms, 1), baseUnary2(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest2(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply2(func, this, args);
            });
          });
          var partial = baseRest2(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest2(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            start = start === undefined2 ? start : toInteger2(start);
            return baseRest2(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            start = start == null ? 0 : nativeMax5(toInteger2(start), 0);
            return baseRest2(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush2(otherArgs, array);
              }
              return apply2(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            if (isObject2(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap2(value, wrapper) {
            return partial(castFunction2(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray2(value) ? value : [value];
          }
          function clone2(value) {
            return baseClone2(value, CLONE_SYMBOLS_FLAG3);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone2(value, CLONE_SYMBOLS_FLAG3, customizer);
          }
          function cloneDeep(value) {
            return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys2(source));
          }
          function eq2(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments2 = baseIsArguments2(function() {
            return arguments;
          }()) ? baseIsArguments2 : function(value) {
            return isObjectLike2(value) && hasOwnProperty18.call(value, "callee") && !propertyIsEnumerable3.call(value, "callee");
          };
          var isArray2 = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike2(value) {
            return value != null && isLength2(value.length) && !isFunction2(value);
          }
          function isArrayLikeObject2(value) {
            return isObjectLike2(value) && isArrayLike2(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag5;
          }
          var isBuffer2 = nativeIsBuffer2 || stubFalse2;
          var isDate = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty2(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
              return !value.length;
            }
            var tag = getTag2(value);
            if (tag == mapTag8 || tag == setTag8) {
              return !value.size;
            }
            if (isPrototype2(value)) {
              return !baseKeys2(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty18.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual2(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual2(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike2(value)) {
              return false;
            }
            var tag = baseGetTag2(value);
            return tag == errorTag4 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction2(value) {
            if (!isObject2(value)) {
              return false;
            }
            var tag = baseGetTag2(value);
            return tag == funcTag4 || tag == genTag3 || tag == asyncTag2 || tag == proxyTag2;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger2(value);
          }
          function isLength2(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
          }
          function isObject2(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike2(value) {
            return value != null && typeof value == "object";
          }
          var isMap2 = nodeIsMap2 ? baseUnary2(nodeIsMap2) : baseIsMap2;
          function isMatch(object, source) {
            return object === source || baseIsMatch2(object, source, getMatchData2(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch2(object, source, getMatchData2(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative2(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag5;
          }
          function isPlainObject(value) {
            if (!isObjectLike2(value) || baseGetTag2(value) != objectTag5) {
              return false;
            }
            var proto = getPrototype2(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty18.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
          }
          var isRegExp2 = nodeIsRegExp2 ? baseUnary2(nodeIsRegExp2) : baseIsRegExp2;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER3 && value <= MAX_SAFE_INTEGER3;
          }
          var isSet2 = nodeIsSet2 ? baseUnary2(nodeIsSet2) : baseIsSet2;
          function isString2(value) {
            return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag6;
          }
          function isSymbol2(value) {
            return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag5;
          }
          var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
          function isUndefined2(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike2(value) && getTag2(value) == weakMapTag4;
          }
          function isWeakSet(value) {
            return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt2);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike2(value)) {
              return isString2(value) ? stringToArray(value) : copyArray2(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag2(value), func = tag == mapTag8 ? mapToArray2 : tag == setTag8 ? setToArray2 : values2;
            return func(value);
          }
          function toFinite2(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber2(value);
            if (value === INFINITY5 || value === -INFINITY5) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER2;
            }
            return value === value ? value : 0;
          }
          function toInteger2(value) {
            var result2 = toFinite2(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber2(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN2;
            }
            if (isObject2(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject2(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim2(value);
            var isBinary = reIsBinary2.test(value);
            return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
          }
          function toPlainObject(value) {
            return copyObject2(value, keysIn2(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER3, MAX_SAFE_INTEGER3) : value === 0 ? value : 0;
          }
          function toString4(value) {
            return value == null ? "" : baseToString2(value);
          }
          var assign2 = createAssigner2(function(object, source) {
            if (isPrototype2(source) || isArrayLike2(source)) {
              copyObject2(source, keys2(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty18.call(source, key)) {
                assignValue2(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner2(function(object, source) {
            copyObject2(source, keysIn2(source), object);
          });
          var assignInWith = createAssigner2(function(object, source, srcIndex, customizer) {
            copyObject2(source, keysIn2(source), object, customizer);
          });
          var assignWith = createAssigner2(function(object, source, srcIndex, customizer) {
            copyObject2(source, keys2(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate2(prototype);
            return properties == null ? result2 : baseAssign2(result2, properties);
          }
          var defaults2 = baseRest2(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn2(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq2(value, objectProto21[key]) && !hasOwnProperty18.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest2(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply2(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn2);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor2(object, getIteratee(iteratee2, 3), keysIn2);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn2);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn2(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys2(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn2(object));
          }
          function get2(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet2(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has2(object, path) {
            return object != null && hasPath2(object, path, baseHas2);
          }
          function hasIn2(object, path) {
            return object != null && hasPath2(object, path, baseHasIn2);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString3.call(value);
            }
            result2[value] = key;
          }, constant2(identity2));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString3.call(value);
            }
            if (hasOwnProperty18.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest2(baseInvoke);
          function keys2(object) {
            return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
          }
          function keysIn2(object) {
            return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn2(object, function(value, key, object2) {
              baseAssignValue2(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn2(object, function(value, key, object2) {
              baseAssignValue2(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner2(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner2(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap2(paths, function(path) {
              path = castPath2(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject2(object, getAllKeysIn2(object), result2);
            if (isDeep) {
              result2 = baseClone2(result2, CLONE_DEEP_FLAG2 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG3, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy2(object, negate2(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy2(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap2(getAllKeysIn2(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy2(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath2(path, object);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index < length) {
              var value = object == null ? undefined2 : object[toKey2(path[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object = isFunction2(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet2(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet2(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys2);
          var toPairsIn = createToPairs(keysIn2);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject2(object)) {
                accumulator = isFunction2(Ctor) ? baseCreate2(getPrototype2(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach2 : baseForOwn2)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction2(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction2(updater), customizer);
          }
          function values2(object) {
            return object == null ? [] : baseValues2(object, keys2(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues2(object, keysIn2(object));
          }
          function clamp(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber2(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber2(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber2(number), lower, upper);
          }
          function inRange2(number, start, end) {
            start = toFinite2(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite2(end);
            }
            number = toNumber2(number);
            return baseInRange(number, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall2(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite2(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite2(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString4(string).toLowerCase());
          }
          function deburr(string) {
            string = toString4(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString4(string);
            target = baseToString2(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger2(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape(string) {
            string = toString4(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp2(string) {
            string = toString4(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString4(string);
            length = toInteger2(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString4(string);
            length = toInteger2(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString4(string);
            length = toInteger2(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString4(string).replace(reTrimStart2, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall2(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger2(n);
            }
            return baseRepeat(toString4(string), n);
          }
          function replace() {
            var args = arguments, string = toString4(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall2(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString4(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
              separator = baseToString2(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString4(string);
            position = position == null ? 0 : baseClamp(toInteger2(position), 0, string.length);
            target = baseToString2(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall2(string, options, guard)) {
              options = undefined2;
            }
            string = toString4(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues2(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty18.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty18.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString4(value).toLowerCase();
          }
          function toUpper(value) {
            return toString4(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString4(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim2(string);
            }
            if (!string || !(chars = baseToString2(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString4(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex2(string) + 1);
            }
            if (!string || !(chars = baseToString2(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString4(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart2, "");
            }
            if (!string || !(chars = baseToString2(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject2(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger2(options.length) : length;
              omission = "omission" in options ? baseToString2(options.omission) : omission;
            }
            string = toString4(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp2(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString4(reFlags2.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString2(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape(string) {
            string = toString4(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString4(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest2(function(func, args) {
            try {
              return apply2(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach2(methodNames, function(key) {
              key = toKey2(key);
              baseAssignValue2(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap2(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT3);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest2(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply2(pair[0], this, args)) {
                  return apply2(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone2(source, CLONE_DEEP_FLAG2));
          }
          function constant2(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity2(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee2(typeof func == "function" ? func : baseClone2(func, CLONE_DEEP_FLAG2));
          }
          function matches(source) {
            return baseMatches2(baseClone2(source, CLONE_DEEP_FLAG2));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty2(path, baseClone2(srcValue, CLONE_DEEP_FLAG2));
          }
          var method = baseRest2(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest2(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys2(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys2(source));
            }
            var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
            arrayEach2(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray2(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush2([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root2._ === this) {
              root2._ = oldDash;
            }
            return this;
          }
          function noop2() {
          }
          function nthArg(n) {
            n = toInteger2(n);
            return baseRest2(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap2);
          var overEvery = createOver(arrayEvery2);
          var overSome = createOver(arraySome2);
          function property2(path) {
            return isKey2(path) ? baseProperty2(toKey2(path)) : basePropertyDeep2(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet2(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray2() {
            return [];
          }
          function stubFalse2() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger2(n);
            if (n < 1 || n > MAX_SAFE_INTEGER3) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes2(length, iteratee2);
            while (++index < n) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray2(value)) {
              return arrayMap2(value, toKey2);
            }
            return isSymbol2(value) ? [value] : copyArray2(stringToPath2(toString4(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString4(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum2(array, identity2, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum2(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity2);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min2(array) {
            return array && array.length ? baseExtremum2(array, identity2, baseLt2) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum2(array, getIteratee(iteratee2, 2), baseLt2) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity2) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign2;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact2;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant2;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults2;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference2;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop2;
          lodash.dropRight = dropRight2;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter2;
          lodash.flatMap = flatMap3;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten2;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy2;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys2;
          lodash.keysIn = keysIn2;
          lodash.map = map2;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize2;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate2;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy2;
          lodash.property = property2;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject2;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq2;
          lodash.uniqBy = uniqBy2;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values2;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap2;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone2;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq2;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp2;
          lodash.every = every2;
          lodash.find = find2;
          lodash.findIndex = findIndex2;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach2;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get2;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has2;
          lodash.hasIn = hasIn2;
          lodash.head = head2;
          lodash.identity = identity2;
          lodash.includes = includes2;
          lodash.indexOf = indexOf2;
          lodash.inRange = inRange2;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments2;
          lodash.isArray = isArray2;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike2;
          lodash.isArrayLikeObject = isArrayLikeObject2;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer2;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty2;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction2;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength2;
          lodash.isMap = isMap2;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject2;
          lodash.isObjectLike = isObjectLike2;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp2;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet2;
          lodash.isString = isString2;
          lodash.isSymbol = isSymbol2;
          lodash.isTypedArray = isTypedArray2;
          lodash.isUndefined = isUndefined2;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last2;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min2;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray2;
          lodash.stubFalse = stubFalse2;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop2;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce2;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some2;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite2;
          lodash.toInteger = toInteger2;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber2;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString4;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach2;
          lodash.eachRight = forEachRight;
          lodash.first = head2;
          mixin(lodash, function() {
            var source = {};
            baseForOwn2(lodash, function(func, methodName) {
              if (!hasOwnProperty18.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION2;
          arrayEach2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach2(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax5(toInteger2(n), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach2(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach2(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach2(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity2);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest2(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate2(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger2(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger2(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush2([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach2(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray2(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray2(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty18.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _5 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root2._ = _5;
          define(function() {
            return _5;
          });
        } else if (freeModule4) {
          (freeModule4.exports = _5)._ = _5;
          freeExports4._ = _5;
        } else {
          root2._ = _5;
        }
      }).call(exports2);
    }
  });

  // ../node_modules/langium/lib/index.js
  var lib_exports = {};
  __export(lib_exports, {
    AbstractAstReflection: () => AbstractAstReflection,
    AbstractCstNode: () => AbstractCstNode,
    AbstractLangiumParser: () => AbstractLangiumParser,
    AbstractParserErrorMessageProvider: () => AbstractParserErrorMessageProvider,
    AbstractThreadedAsyncParser: () => AbstractThreadedAsyncParser,
    AstUtils: () => ast_utils_exports,
    BiMap: () => BiMap,
    Cancellation: () => cancellation_exports,
    CompositeCstNodeImpl: () => CompositeCstNodeImpl,
    ContextCache: () => ContextCache,
    CstNodeBuilder: () => CstNodeBuilder,
    CstUtils: () => cst_utils_exports,
    DONE_RESULT: () => DONE_RESULT,
    DatatypeSymbol: () => DatatypeSymbol,
    DefaultAstNodeDescriptionProvider: () => DefaultAstNodeDescriptionProvider,
    DefaultAstNodeLocator: () => DefaultAstNodeLocator,
    DefaultAsyncParser: () => DefaultAsyncParser,
    DefaultCommentProvider: () => DefaultCommentProvider,
    DefaultConfigurationProvider: () => DefaultConfigurationProvider,
    DefaultDocumentBuilder: () => DefaultDocumentBuilder,
    DefaultDocumentValidator: () => DefaultDocumentValidator,
    DefaultHydrator: () => DefaultHydrator,
    DefaultIndexManager: () => DefaultIndexManager,
    DefaultJsonSerializer: () => DefaultJsonSerializer,
    DefaultLangiumDocumentFactory: () => DefaultLangiumDocumentFactory,
    DefaultLangiumDocuments: () => DefaultLangiumDocuments,
    DefaultLexer: () => DefaultLexer,
    DefaultLinker: () => DefaultLinker,
    DefaultNameProvider: () => DefaultNameProvider,
    DefaultReferenceDescriptionProvider: () => DefaultReferenceDescriptionProvider,
    DefaultReferences: () => DefaultReferences,
    DefaultScopeComputation: () => DefaultScopeComputation,
    DefaultScopeProvider: () => DefaultScopeProvider,
    DefaultServiceRegistry: () => DefaultServiceRegistry,
    DefaultTokenBuilder: () => DefaultTokenBuilder,
    DefaultValueConverter: () => DefaultValueConverter,
    DefaultWorkspaceLock: () => DefaultWorkspaceLock,
    DefaultWorkspaceManager: () => DefaultWorkspaceManager,
    Deferred: () => Deferred,
    Disposable: () => Disposable,
    DisposableCache: () => DisposableCache,
    DocumentCache: () => DocumentCache,
    DocumentState: () => DocumentState,
    DocumentValidator: () => DocumentValidator,
    EMPTY_SCOPE: () => EMPTY_SCOPE,
    EMPTY_STREAM: () => EMPTY_STREAM,
    EmptyFileSystem: () => EmptyFileSystem,
    EmptyFileSystemProvider: () => EmptyFileSystemProvider,
    ErrorWithLocation: () => ErrorWithLocation,
    GrammarAST: () => ast_exports,
    GrammarUtils: () => grammar_utils_exports,
    JSDocDocumentationProvider: () => JSDocDocumentationProvider,
    LangiumCompletionParser: () => LangiumCompletionParser,
    LangiumParser: () => LangiumParser,
    LangiumParserErrorMessageProvider: () => LangiumParserErrorMessageProvider,
    LeafCstNodeImpl: () => LeafCstNodeImpl,
    MapScope: () => MapScope,
    Module: () => Module,
    MultiMap: () => MultiMap,
    OperationCancelled: () => OperationCancelled,
    ParserWorker: () => ParserWorker,
    Reduction: () => Reduction,
    RegExpUtils: () => regexp_utils_exports,
    RootCstNodeImpl: () => RootCstNodeImpl,
    SimpleCache: () => SimpleCache,
    StreamImpl: () => StreamImpl,
    StreamScope: () => StreamScope,
    TextDocument: () => TextDocument2,
    TreeStreamImpl: () => TreeStreamImpl,
    URI: () => URI2,
    UriUtils: () => UriUtils,
    ValidationCategory: () => ValidationCategory,
    ValidationRegistry: () => ValidationRegistry,
    ValueConverter: () => ValueConverter,
    WorkspaceCache: () => WorkspaceCache,
    assertUnreachable: () => assertUnreachable,
    createCompletionParser: () => createCompletionParser,
    createDefaultCoreModule: () => createDefaultCoreModule,
    createDefaultSharedCoreModule: () => createDefaultSharedCoreModule,
    createGrammarConfig: () => createGrammarConfig,
    createLangiumParser: () => createLangiumParser,
    delayNextTick: () => delayNextTick,
    diagnosticData: () => diagnosticData,
    eagerLoad: () => eagerLoad,
    getDiagnosticRange: () => getDiagnosticRange,
    inject: () => inject,
    interruptAndCheck: () => interruptAndCheck,
    isAstNode: () => isAstNode,
    isAstNodeDescription: () => isAstNodeDescription,
    isAstNodeWithComment: () => isAstNodeWithComment,
    isCompositeCstNode: () => isCompositeCstNode,
    isIMultiModeLexerDefinition: () => isIMultiModeLexerDefinition,
    isJSDoc: () => isJSDoc,
    isLeafCstNode: () => isLeafCstNode,
    isLinkingError: () => isLinkingError,
    isNamed: () => isNamed,
    isOperationCancelled: () => isOperationCancelled,
    isReference: () => isReference,
    isRootCstNode: () => isRootCstNode,
    isTokenTypeArray: () => isTokenTypeArray,
    isTokenTypeDictionary: () => isTokenTypeDictionary,
    loadGrammarFromJson: () => loadGrammarFromJson,
    parseJSDoc: () => parseJSDoc,
    prepareLangiumParser: () => prepareLangiumParser,
    setInterruptionPeriod: () => setInterruptionPeriod,
    startCancelableOperation: () => startCancelableOperation,
    stream: () => stream,
    toDiagnosticSeverity: () => toDiagnosticSeverity
  });

  // ../node_modules/langium/lib/utils/cst-utils.js
  var cst_utils_exports = {};
  __export(cst_utils_exports, {
    DefaultNameRegexp: () => DefaultNameRegexp,
    RangeComparison: () => RangeComparison,
    compareRange: () => compareRange,
    findCommentNode: () => findCommentNode,
    findDeclarationNodeAtOffset: () => findDeclarationNodeAtOffset,
    findLeafNodeAtOffset: () => findLeafNodeAtOffset,
    findLeafNodeBeforeOffset: () => findLeafNodeBeforeOffset,
    flattenCst: () => flattenCst,
    getInteriorNodes: () => getInteriorNodes,
    getNextNode: () => getNextNode,
    getPreviousNode: () => getPreviousNode,
    getStartlineNode: () => getStartlineNode,
    inRange: () => inRange,
    isChildNode: () => isChildNode,
    isCommentNode: () => isCommentNode,
    streamCst: () => streamCst,
    toDocumentSegment: () => toDocumentSegment,
    tokenToRange: () => tokenToRange
  });

  // ../node_modules/langium/lib/syntax-tree.js
  function isAstNode(obj) {
    return typeof obj === "object" && obj !== null && typeof obj.$type === "string";
  }
  function isReference(obj) {
    return typeof obj === "object" && obj !== null && typeof obj.$refText === "string";
  }
  function isAstNodeDescription(obj) {
    return typeof obj === "object" && obj !== null && typeof obj.name === "string" && typeof obj.type === "string" && typeof obj.path === "string";
  }
  function isLinkingError(obj) {
    return typeof obj === "object" && obj !== null && isAstNode(obj.container) && isReference(obj.reference) && typeof obj.message === "string";
  }
  var AbstractAstReflection = class {
    constructor() {
      this.subtypes = {};
      this.allSubtypes = {};
    }
    isInstance(node, type) {
      return isAstNode(node) && this.isSubtype(node.$type, type);
    }
    isSubtype(subtype, supertype) {
      if (subtype === supertype) {
        return true;
      }
      let nested = this.subtypes[subtype];
      if (!nested) {
        nested = this.subtypes[subtype] = {};
      }
      const existing = nested[supertype];
      if (existing !== void 0) {
        return existing;
      } else {
        const result = this.computeIsSubtype(subtype, supertype);
        nested[supertype] = result;
        return result;
      }
    }
    getAllSubTypes(type) {
      const existing = this.allSubtypes[type];
      if (existing) {
        return existing;
      } else {
        const allTypes = this.getAllTypes();
        const types = [];
        for (const possibleSubType of allTypes) {
          if (this.isSubtype(possibleSubType, type)) {
            types.push(possibleSubType);
          }
        }
        this.allSubtypes[type] = types;
        return types;
      }
    }
  };
  function isCompositeCstNode(node) {
    return typeof node === "object" && node !== null && Array.isArray(node.content);
  }
  function isLeafCstNode(node) {
    return typeof node === "object" && node !== null && typeof node.tokenType === "object";
  }
  function isRootCstNode(node) {
    return isCompositeCstNode(node) && typeof node.fullText === "string";
  }

  // ../node_modules/langium/lib/utils/stream.js
  var StreamImpl = class _StreamImpl {
    constructor(startFn, nextFn) {
      this.startFn = startFn;
      this.nextFn = nextFn;
    }
    iterator() {
      const iterator = {
        state: this.startFn(),
        next: () => this.nextFn(iterator.state),
        [Symbol.iterator]: () => iterator
      };
      return iterator;
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    isEmpty() {
      const iterator = this.iterator();
      return Boolean(iterator.next().done);
    }
    count() {
      const iterator = this.iterator();
      let count = 0;
      let next = iterator.next();
      while (!next.done) {
        count++;
        next = iterator.next();
      }
      return count;
    }
    toArray() {
      const result = [];
      const iterator = this.iterator();
      let next;
      do {
        next = iterator.next();
        if (next.value !== void 0) {
          result.push(next.value);
        }
      } while (!next.done);
      return result;
    }
    toSet() {
      return new Set(this);
    }
    toMap(keyFn, valueFn) {
      const entryStream = this.map((element) => [
        keyFn ? keyFn(element) : element,
        valueFn ? valueFn(element) : element
      ]);
      return new Map(entryStream);
    }
    toString() {
      return this.join();
    }
    concat(other) {
      const iterator = other[Symbol.iterator]();
      return new _StreamImpl(() => ({ first: this.startFn(), firstDone: false }), (state) => {
        let result;
        if (!state.firstDone) {
          do {
            result = this.nextFn(state.first);
            if (!result.done) {
              return result;
            }
          } while (!result.done);
          state.firstDone = true;
        }
        do {
          result = iterator.next();
          if (!result.done) {
            return result;
          }
        } while (!result.done);
        return DONE_RESULT;
      });
    }
    join(separator = ",") {
      const iterator = this.iterator();
      let value = "";
      let result;
      let addSeparator = false;
      do {
        result = iterator.next();
        if (!result.done) {
          if (addSeparator) {
            value += separator;
          }
          value += toString(result.value);
        }
        addSeparator = true;
      } while (!result.done);
      return value;
    }
    indexOf(searchElement, fromIndex = 0) {
      const iterator = this.iterator();
      let index = 0;
      let next = iterator.next();
      while (!next.done) {
        if (index >= fromIndex && next.value === searchElement) {
          return index;
        }
        next = iterator.next();
        index++;
      }
      return -1;
    }
    every(predicate) {
      const iterator = this.iterator();
      let next = iterator.next();
      while (!next.done) {
        if (!predicate(next.value)) {
          return false;
        }
        next = iterator.next();
      }
      return true;
    }
    some(predicate) {
      const iterator = this.iterator();
      let next = iterator.next();
      while (!next.done) {
        if (predicate(next.value)) {
          return true;
        }
        next = iterator.next();
      }
      return false;
    }
    forEach(callbackfn) {
      const iterator = this.iterator();
      let index = 0;
      let next = iterator.next();
      while (!next.done) {
        callbackfn(next.value, index);
        next = iterator.next();
        index++;
      }
    }
    map(callbackfn) {
      return new _StreamImpl(this.startFn, (state) => {
        const { done, value } = this.nextFn(state);
        if (done) {
          return DONE_RESULT;
        } else {
          return { done: false, value: callbackfn(value) };
        }
      });
    }
    filter(predicate) {
      return new _StreamImpl(this.startFn, (state) => {
        let result;
        do {
          result = this.nextFn(state);
          if (!result.done && predicate(result.value)) {
            return result;
          }
        } while (!result.done);
        return DONE_RESULT;
      });
    }
    nonNullable() {
      return this.filter((e) => e !== void 0 && e !== null);
    }
    reduce(callbackfn, initialValue) {
      const iterator = this.iterator();
      let previousValue = initialValue;
      let next = iterator.next();
      while (!next.done) {
        if (previousValue === void 0) {
          previousValue = next.value;
        } else {
          previousValue = callbackfn(previousValue, next.value);
        }
        next = iterator.next();
      }
      return previousValue;
    }
    reduceRight(callbackfn, initialValue) {
      return this.recursiveReduce(this.iterator(), callbackfn, initialValue);
    }
    recursiveReduce(iterator, callbackfn, initialValue) {
      const next = iterator.next();
      if (next.done) {
        return initialValue;
      }
      const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);
      if (previousValue === void 0) {
        return next.value;
      }
      return callbackfn(previousValue, next.value);
    }
    find(predicate) {
      const iterator = this.iterator();
      let next = iterator.next();
      while (!next.done) {
        if (predicate(next.value)) {
          return next.value;
        }
        next = iterator.next();
      }
      return void 0;
    }
    findIndex(predicate) {
      const iterator = this.iterator();
      let index = 0;
      let next = iterator.next();
      while (!next.done) {
        if (predicate(next.value)) {
          return index;
        }
        next = iterator.next();
        index++;
      }
      return -1;
    }
    includes(searchElement) {
      const iterator = this.iterator();
      let next = iterator.next();
      while (!next.done) {
        if (next.value === searchElement) {
          return true;
        }
        next = iterator.next();
      }
      return false;
    }
    flatMap(callbackfn) {
      return new _StreamImpl(() => ({ this: this.startFn() }), (state) => {
        do {
          if (state.iterator) {
            const next = state.iterator.next();
            if (next.done) {
              state.iterator = void 0;
            } else {
              return next;
            }
          }
          const { done, value } = this.nextFn(state.this);
          if (!done) {
            const mapped = callbackfn(value);
            if (isIterable(mapped)) {
              state.iterator = mapped[Symbol.iterator]();
            } else {
              return { done: false, value: mapped };
            }
          }
        } while (state.iterator);
        return DONE_RESULT;
      });
    }
    flat(depth) {
      if (depth === void 0) {
        depth = 1;
      }
      if (depth <= 0) {
        return this;
      }
      const stream2 = depth > 1 ? this.flat(depth - 1) : this;
      return new _StreamImpl(() => ({ this: stream2.startFn() }), (state) => {
        do {
          if (state.iterator) {
            const next = state.iterator.next();
            if (next.done) {
              state.iterator = void 0;
            } else {
              return next;
            }
          }
          const { done, value } = stream2.nextFn(state.this);
          if (!done) {
            if (isIterable(value)) {
              state.iterator = value[Symbol.iterator]();
            } else {
              return { done: false, value };
            }
          }
        } while (state.iterator);
        return DONE_RESULT;
      });
    }
    head() {
      const iterator = this.iterator();
      const result = iterator.next();
      if (result.done) {
        return void 0;
      }
      return result.value;
    }
    tail(skipCount = 1) {
      return new _StreamImpl(() => {
        const state = this.startFn();
        for (let i = 0; i < skipCount; i++) {
          const next = this.nextFn(state);
          if (next.done) {
            return state;
          }
        }
        return state;
      }, this.nextFn);
    }
    limit(maxSize) {
      return new _StreamImpl(() => ({ size: 0, state: this.startFn() }), (state) => {
        state.size++;
        if (state.size > maxSize) {
          return DONE_RESULT;
        }
        return this.nextFn(state.state);
      });
    }
    distinct(by) {
      const set = /* @__PURE__ */ new Set();
      return this.filter((e) => {
        const value = by ? by(e) : e;
        if (set.has(value)) {
          return false;
        } else {
          set.add(value);
          return true;
        }
      });
    }
    exclude(other, key) {
      const otherKeySet = /* @__PURE__ */ new Set();
      for (const item of other) {
        const value = key ? key(item) : item;
        otherKeySet.add(value);
      }
      return this.filter((e) => {
        const ownKey = key ? key(e) : e;
        return !otherKeySet.has(ownKey);
      });
    }
  };
  function toString(item) {
    if (typeof item === "string") {
      return item;
    }
    if (typeof item === "undefined") {
      return "undefined";
    }
    if (typeof item.toString === "function") {
      return item.toString();
    }
    return Object.prototype.toString.call(item);
  }
  function isIterable(obj) {
    return !!obj && typeof obj[Symbol.iterator] === "function";
  }
  var EMPTY_STREAM = new StreamImpl(() => void 0, () => DONE_RESULT);
  var DONE_RESULT = Object.freeze({ done: true, value: void 0 });
  function stream(...collections) {
    if (collections.length === 1) {
      const collection = collections[0];
      if (collection instanceof StreamImpl) {
        return collection;
      }
      if (isIterable(collection)) {
        return new StreamImpl(() => collection[Symbol.iterator](), (iterator) => iterator.next());
      }
      if (typeof collection.length === "number") {
        return new StreamImpl(() => ({ index: 0 }), (state) => {
          if (state.index < collection.length) {
            return { done: false, value: collection[state.index++] };
          } else {
            return DONE_RESULT;
          }
        });
      }
    }
    if (collections.length > 1) {
      return new StreamImpl(() => ({ collIndex: 0, arrIndex: 0 }), (state) => {
        do {
          if (state.iterator) {
            const next = state.iterator.next();
            if (!next.done) {
              return next;
            }
            state.iterator = void 0;
          }
          if (state.array) {
            if (state.arrIndex < state.array.length) {
              return { done: false, value: state.array[state.arrIndex++] };
            }
            state.array = void 0;
            state.arrIndex = 0;
          }
          if (state.collIndex < collections.length) {
            const collection = collections[state.collIndex++];
            if (isIterable(collection)) {
              state.iterator = collection[Symbol.iterator]();
            } else if (collection && typeof collection.length === "number") {
              state.array = collection;
            }
          }
        } while (state.iterator || state.array || state.collIndex < collections.length);
        return DONE_RESULT;
      });
    }
    return EMPTY_STREAM;
  }
  var TreeStreamImpl = class extends StreamImpl {
    constructor(root2, children, options) {
      super(() => ({
        iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root2][Symbol.iterator]()] : [children(root2)[Symbol.iterator]()],
        pruned: false
      }), (state) => {
        if (state.pruned) {
          state.iterators.pop();
          state.pruned = false;
        }
        while (state.iterators.length > 0) {
          const iterator = state.iterators[state.iterators.length - 1];
          const next = iterator.next();
          if (next.done) {
            state.iterators.pop();
          } else {
            state.iterators.push(children(next.value)[Symbol.iterator]());
            return next;
          }
        }
        return DONE_RESULT;
      });
    }
    iterator() {
      const iterator = {
        state: this.startFn(),
        next: () => this.nextFn(iterator.state),
        prune: () => {
          iterator.state.pruned = true;
        },
        [Symbol.iterator]: () => iterator
      };
      return iterator;
    }
  };
  var Reduction;
  (function(Reduction2) {
    function sum(stream2) {
      return stream2.reduce((a2, b) => a2 + b, 0);
    }
    Reduction2.sum = sum;
    function product(stream2) {
      return stream2.reduce((a2, b) => a2 * b, 0);
    }
    Reduction2.product = product;
    function min2(stream2) {
      return stream2.reduce((a2, b) => Math.min(a2, b));
    }
    Reduction2.min = min2;
    function max(stream2) {
      return stream2.reduce((a2, b) => Math.max(a2, b));
    }
    Reduction2.max = max;
  })(Reduction || (Reduction = {}));

  // ../node_modules/langium/lib/utils/cst-utils.js
  function streamCst(node) {
    return new TreeStreamImpl(node, (element) => {
      if (isCompositeCstNode(element)) {
        return element.content;
      } else {
        return [];
      }
    }, { includeRoot: true });
  }
  function flattenCst(node) {
    return streamCst(node).filter(isLeafCstNode);
  }
  function isChildNode(child, parent) {
    while (child.container) {
      child = child.container;
      if (child === parent) {
        return true;
      }
    }
    return false;
  }
  function tokenToRange(token) {
    return {
      start: {
        character: token.startColumn - 1,
        line: token.startLine - 1
      },
      end: {
        character: token.endColumn,
        line: token.endLine - 1
      }
    };
  }
  function toDocumentSegment(node) {
    if (!node) {
      return void 0;
    }
    const { offset, end, range } = node;
    return {
      range,
      offset,
      end,
      length: end - offset
    };
  }
  var RangeComparison;
  (function(RangeComparison2) {
    RangeComparison2[RangeComparison2["Before"] = 0] = "Before";
    RangeComparison2[RangeComparison2["After"] = 1] = "After";
    RangeComparison2[RangeComparison2["OverlapFront"] = 2] = "OverlapFront";
    RangeComparison2[RangeComparison2["OverlapBack"] = 3] = "OverlapBack";
    RangeComparison2[RangeComparison2["Inside"] = 4] = "Inside";
  })(RangeComparison || (RangeComparison = {}));
  function compareRange(range, to) {
    if (range.end.line < to.start.line || range.end.line === to.start.line && range.end.character < range.start.character) {
      return RangeComparison.Before;
    } else if (range.start.line > to.end.line || range.start.line === to.end.line && range.start.character > to.end.character) {
      return RangeComparison.After;
    }
    const startInside = range.start.line > to.start.line || range.start.line === to.start.line && range.start.character >= to.start.character;
    const endInside = range.end.line < to.end.line || range.end.line === to.end.line && range.end.character <= to.end.character;
    if (startInside && endInside) {
      return RangeComparison.Inside;
    } else if (startInside) {
      return RangeComparison.OverlapBack;
    } else {
      return RangeComparison.OverlapFront;
    }
  }
  function inRange(range, to) {
    const comparison = compareRange(range, to);
    return comparison > RangeComparison.After;
  }
  var DefaultNameRegexp = /^[\w\p{L}]$/u;
  function findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = DefaultNameRegexp) {
    if (cstNode) {
      if (offset > 0) {
        const localOffset = offset - cstNode.offset;
        const textAtOffset = cstNode.text.charAt(localOffset);
        if (!nameRegexp.test(textAtOffset)) {
          offset--;
        }
      }
      return findLeafNodeAtOffset(cstNode, offset);
    }
    return void 0;
  }
  function findCommentNode(cstNode, commentNames) {
    if (cstNode) {
      const previous = getPreviousNode(cstNode, true);
      if (previous && isCommentNode(previous, commentNames)) {
        return previous;
      }
      if (isRootCstNode(cstNode)) {
        const endIndex = cstNode.content.findIndex((e) => !e.hidden);
        for (let i = endIndex - 1; i >= 0; i--) {
          const child = cstNode.content[i];
          if (isCommentNode(child, commentNames)) {
            return child;
          }
        }
      }
    }
    return void 0;
  }
  function isCommentNode(cstNode, commentNames) {
    return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);
  }
  function findLeafNodeAtOffset(node, offset) {
    if (isLeafCstNode(node)) {
      return node;
    } else if (isCompositeCstNode(node)) {
      const searchResult = binarySearch(node, offset, false);
      if (searchResult) {
        return findLeafNodeAtOffset(searchResult, offset);
      }
    }
    return void 0;
  }
  function findLeafNodeBeforeOffset(node, offset) {
    if (isLeafCstNode(node)) {
      return node;
    } else if (isCompositeCstNode(node)) {
      const searchResult = binarySearch(node, offset, true);
      if (searchResult) {
        return findLeafNodeBeforeOffset(searchResult, offset);
      }
    }
    return void 0;
  }
  function binarySearch(node, offset, closest) {
    let left = 0;
    let right = node.content.length - 1;
    let closestNode = void 0;
    while (left <= right) {
      const middle = Math.floor((left + right) / 2);
      const middleNode = node.content[middle];
      if (middleNode.offset <= offset && middleNode.end > offset) {
        return middleNode;
      }
      if (middleNode.end <= offset) {
        closestNode = closest ? middleNode : void 0;
        left = middle + 1;
      } else {
        right = middle - 1;
      }
    }
    return closestNode;
  }
  function getPreviousNode(node, hidden = true) {
    while (node.container) {
      const parent = node.container;
      let index = parent.content.indexOf(node);
      while (index > 0) {
        index--;
        const previous = parent.content[index];
        if (hidden || !previous.hidden) {
          return previous;
        }
      }
      node = parent;
    }
    return void 0;
  }
  function getNextNode(node, hidden = true) {
    while (node.container) {
      const parent = node.container;
      let index = parent.content.indexOf(node);
      const last2 = parent.content.length - 1;
      while (index < last2) {
        index++;
        const next = parent.content[index];
        if (hidden || !next.hidden) {
          return next;
        }
      }
      node = parent;
    }
    return void 0;
  }
  function getStartlineNode(node) {
    if (node.range.start.character === 0) {
      return node;
    }
    const line = node.range.start.line;
    let last2 = node;
    let index;
    while (node.container) {
      const parent = node.container;
      const selfIndex = index !== null && index !== void 0 ? index : parent.content.indexOf(node);
      if (selfIndex === 0) {
        node = parent;
        index = void 0;
      } else {
        index = selfIndex - 1;
        node = parent.content[index];
      }
      if (node.range.start.line !== line) {
        break;
      }
      last2 = node;
    }
    return last2;
  }
  function getInteriorNodes(start, end) {
    const commonParent = getCommonParent(start, end);
    if (!commonParent) {
      return [];
    }
    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);
  }
  function getCommonParent(a2, b) {
    const aParents = getParentChain(a2);
    const bParents = getParentChain(b);
    let current;
    for (let i = 0; i < aParents.length && i < bParents.length; i++) {
      const aParent = aParents[i];
      const bParent = bParents[i];
      if (aParent.parent === bParent.parent) {
        current = {
          parent: aParent.parent,
          a: aParent.index,
          b: bParent.index
        };
      } else {
        break;
      }
    }
    return current;
  }
  function getParentChain(node) {
    const chain = [];
    while (node.container) {
      const parent = node.container;
      const index = parent.content.indexOf(node);
      chain.push({
        parent,
        index
      });
      node = parent;
    }
    return chain.reverse();
  }

  // ../node_modules/langium/lib/utils/grammar-utils.js
  var grammar_utils_exports = {};
  __export(grammar_utils_exports, {
    findAssignment: () => findAssignment,
    findNameAssignment: () => findNameAssignment,
    findNodeForKeyword: () => findNodeForKeyword,
    findNodeForProperty: () => findNodeForProperty,
    findNodesForKeyword: () => findNodesForKeyword,
    findNodesForKeywordInternal: () => findNodesForKeywordInternal,
    findNodesForProperty: () => findNodesForProperty,
    getActionAtElement: () => getActionAtElement,
    getActionType: () => getActionType,
    getAllReachableRules: () => getAllReachableRules,
    getCrossReferenceTerminal: () => getCrossReferenceTerminal,
    getEntryRule: () => getEntryRule,
    getExplicitRuleType: () => getExplicitRuleType,
    getHiddenRules: () => getHiddenRules,
    getRuleType: () => getRuleType,
    getTypeName: () => getTypeName,
    isArrayCardinality: () => isArrayCardinality,
    isArrayOperator: () => isArrayOperator,
    isCommentTerminal: () => isCommentTerminal,
    isDataType: () => isDataType,
    isDataTypeRule: () => isDataTypeRule,
    isOptionalCardinality: () => isOptionalCardinality,
    terminalRegex: () => terminalRegex
  });

  // ../node_modules/langium/lib/utils/errors.js
  var ErrorWithLocation = class extends Error {
    constructor(node, message) {
      super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);
    }
  };
  function assertUnreachable(_5) {
    throw new Error("Error! The input value was not handled.");
  }

  // ../node_modules/langium/lib/languages/generated/ast.js
  var ast_exports = {};
  __export(ast_exports, {
    AbstractElement: () => AbstractElement,
    AbstractRule: () => AbstractRule,
    AbstractType: () => AbstractType,
    Action: () => Action,
    Alternatives: () => Alternatives,
    ArrayLiteral: () => ArrayLiteral,
    ArrayType: () => ArrayType,
    Assignment: () => Assignment,
    BooleanLiteral: () => BooleanLiteral,
    CharacterRange: () => CharacterRange,
    Condition: () => Condition,
    Conjunction: () => Conjunction,
    CrossReference: () => CrossReference,
    Disjunction: () => Disjunction,
    EndOfFile: () => EndOfFile,
    Grammar: () => Grammar,
    GrammarImport: () => GrammarImport,
    Group: () => Group,
    InferredType: () => InferredType,
    Interface: () => Interface,
    Keyword: () => Keyword,
    LangiumGrammarAstReflection: () => LangiumGrammarAstReflection,
    LangiumGrammarTerminals: () => LangiumGrammarTerminals,
    NamedArgument: () => NamedArgument,
    NegatedToken: () => NegatedToken,
    Negation: () => Negation,
    NumberLiteral: () => NumberLiteral,
    Parameter: () => Parameter,
    ParameterReference: () => ParameterReference,
    ParserRule: () => ParserRule,
    ReferenceType: () => ReferenceType,
    RegexToken: () => RegexToken,
    ReturnType: () => ReturnType,
    RuleCall: () => RuleCall,
    SimpleType: () => SimpleType,
    StringLiteral: () => StringLiteral,
    TerminalAlternatives: () => TerminalAlternatives,
    TerminalGroup: () => TerminalGroup,
    TerminalRule: () => TerminalRule,
    TerminalRuleCall: () => TerminalRuleCall,
    Type: () => Type,
    TypeAttribute: () => TypeAttribute,
    TypeDefinition: () => TypeDefinition,
    UnionType: () => UnionType,
    UnorderedGroup: () => UnorderedGroup,
    UntilToken: () => UntilToken,
    ValueLiteral: () => ValueLiteral,
    Wildcard: () => Wildcard,
    isAbstractElement: () => isAbstractElement,
    isAbstractRule: () => isAbstractRule,
    isAbstractType: () => isAbstractType,
    isAction: () => isAction,
    isAlternatives: () => isAlternatives,
    isArrayLiteral: () => isArrayLiteral,
    isArrayType: () => isArrayType,
    isAssignment: () => isAssignment,
    isBooleanLiteral: () => isBooleanLiteral,
    isCharacterRange: () => isCharacterRange,
    isCondition: () => isCondition,
    isConjunction: () => isConjunction,
    isCrossReference: () => isCrossReference,
    isDisjunction: () => isDisjunction,
    isEndOfFile: () => isEndOfFile,
    isFeatureName: () => isFeatureName,
    isGrammar: () => isGrammar,
    isGrammarImport: () => isGrammarImport,
    isGroup: () => isGroup,
    isInferredType: () => isInferredType,
    isInterface: () => isInterface,
    isKeyword: () => isKeyword,
    isNamedArgument: () => isNamedArgument,
    isNegatedToken: () => isNegatedToken,
    isNegation: () => isNegation,
    isNumberLiteral: () => isNumberLiteral,
    isParameter: () => isParameter,
    isParameterReference: () => isParameterReference,
    isParserRule: () => isParserRule,
    isPrimitiveType: () => isPrimitiveType,
    isReferenceType: () => isReferenceType,
    isRegexToken: () => isRegexToken,
    isReturnType: () => isReturnType,
    isRuleCall: () => isRuleCall,
    isSimpleType: () => isSimpleType,
    isStringLiteral: () => isStringLiteral,
    isTerminalAlternatives: () => isTerminalAlternatives,
    isTerminalGroup: () => isTerminalGroup,
    isTerminalRule: () => isTerminalRule,
    isTerminalRuleCall: () => isTerminalRuleCall,
    isType: () => isType,
    isTypeAttribute: () => isTypeAttribute,
    isTypeDefinition: () => isTypeDefinition,
    isUnionType: () => isUnionType,
    isUnorderedGroup: () => isUnorderedGroup,
    isUntilToken: () => isUntilToken,
    isValueLiteral: () => isValueLiteral,
    isWildcard: () => isWildcard,
    reflection: () => reflection
  });
  var LangiumGrammarTerminals = {
    ID: /\^?[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    NUMBER: /NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity)/,
    RegexLiteral: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/
  };
  var AbstractRule = "AbstractRule";
  function isAbstractRule(item) {
    return reflection.isInstance(item, AbstractRule);
  }
  var AbstractType = "AbstractType";
  function isAbstractType(item) {
    return reflection.isInstance(item, AbstractType);
  }
  var Condition = "Condition";
  function isCondition(item) {
    return reflection.isInstance(item, Condition);
  }
  function isFeatureName(item) {
    return isPrimitiveType(item) || item === "current" || item === "entry" || item === "extends" || item === "false" || item === "fragment" || item === "grammar" || item === "hidden" || item === "import" || item === "interface" || item === "returns" || item === "terminal" || item === "true" || item === "type" || item === "infer" || item === "infers" || item === "with" || typeof item === "string" && /\^?[_a-zA-Z][\w_]*/.test(item);
  }
  function isPrimitiveType(item) {
    return item === "string" || item === "number" || item === "boolean" || item === "Date" || item === "bigint";
  }
  var TypeDefinition = "TypeDefinition";
  function isTypeDefinition(item) {
    return reflection.isInstance(item, TypeDefinition);
  }
  var ValueLiteral = "ValueLiteral";
  function isValueLiteral(item) {
    return reflection.isInstance(item, ValueLiteral);
  }
  var AbstractElement = "AbstractElement";
  function isAbstractElement(item) {
    return reflection.isInstance(item, AbstractElement);
  }
  var ArrayLiteral = "ArrayLiteral";
  function isArrayLiteral(item) {
    return reflection.isInstance(item, ArrayLiteral);
  }
  var ArrayType = "ArrayType";
  function isArrayType(item) {
    return reflection.isInstance(item, ArrayType);
  }
  var BooleanLiteral = "BooleanLiteral";
  function isBooleanLiteral(item) {
    return reflection.isInstance(item, BooleanLiteral);
  }
  var Conjunction = "Conjunction";
  function isConjunction(item) {
    return reflection.isInstance(item, Conjunction);
  }
  var Disjunction = "Disjunction";
  function isDisjunction(item) {
    return reflection.isInstance(item, Disjunction);
  }
  var Grammar = "Grammar";
  function isGrammar(item) {
    return reflection.isInstance(item, Grammar);
  }
  var GrammarImport = "GrammarImport";
  function isGrammarImport(item) {
    return reflection.isInstance(item, GrammarImport);
  }
  var InferredType = "InferredType";
  function isInferredType(item) {
    return reflection.isInstance(item, InferredType);
  }
  var Interface = "Interface";
  function isInterface(item) {
    return reflection.isInstance(item, Interface);
  }
  var NamedArgument = "NamedArgument";
  function isNamedArgument(item) {
    return reflection.isInstance(item, NamedArgument);
  }
  var Negation = "Negation";
  function isNegation(item) {
    return reflection.isInstance(item, Negation);
  }
  var NumberLiteral = "NumberLiteral";
  function isNumberLiteral(item) {
    return reflection.isInstance(item, NumberLiteral);
  }
  var Parameter = "Parameter";
  function isParameter(item) {
    return reflection.isInstance(item, Parameter);
  }
  var ParameterReference = "ParameterReference";
  function isParameterReference(item) {
    return reflection.isInstance(item, ParameterReference);
  }
  var ParserRule = "ParserRule";
  function isParserRule(item) {
    return reflection.isInstance(item, ParserRule);
  }
  var ReferenceType = "ReferenceType";
  function isReferenceType(item) {
    return reflection.isInstance(item, ReferenceType);
  }
  var ReturnType = "ReturnType";
  function isReturnType(item) {
    return reflection.isInstance(item, ReturnType);
  }
  var SimpleType = "SimpleType";
  function isSimpleType(item) {
    return reflection.isInstance(item, SimpleType);
  }
  var StringLiteral = "StringLiteral";
  function isStringLiteral(item) {
    return reflection.isInstance(item, StringLiteral);
  }
  var TerminalRule = "TerminalRule";
  function isTerminalRule(item) {
    return reflection.isInstance(item, TerminalRule);
  }
  var Type = "Type";
  function isType(item) {
    return reflection.isInstance(item, Type);
  }
  var TypeAttribute = "TypeAttribute";
  function isTypeAttribute(item) {
    return reflection.isInstance(item, TypeAttribute);
  }
  var UnionType = "UnionType";
  function isUnionType(item) {
    return reflection.isInstance(item, UnionType);
  }
  var Action = "Action";
  function isAction(item) {
    return reflection.isInstance(item, Action);
  }
  var Alternatives = "Alternatives";
  function isAlternatives(item) {
    return reflection.isInstance(item, Alternatives);
  }
  var Assignment = "Assignment";
  function isAssignment(item) {
    return reflection.isInstance(item, Assignment);
  }
  var CharacterRange = "CharacterRange";
  function isCharacterRange(item) {
    return reflection.isInstance(item, CharacterRange);
  }
  var CrossReference = "CrossReference";
  function isCrossReference(item) {
    return reflection.isInstance(item, CrossReference);
  }
  var EndOfFile = "EndOfFile";
  function isEndOfFile(item) {
    return reflection.isInstance(item, EndOfFile);
  }
  var Group = "Group";
  function isGroup(item) {
    return reflection.isInstance(item, Group);
  }
  var Keyword = "Keyword";
  function isKeyword(item) {
    return reflection.isInstance(item, Keyword);
  }
  var NegatedToken = "NegatedToken";
  function isNegatedToken(item) {
    return reflection.isInstance(item, NegatedToken);
  }
  var RegexToken = "RegexToken";
  function isRegexToken(item) {
    return reflection.isInstance(item, RegexToken);
  }
  var RuleCall = "RuleCall";
  function isRuleCall(item) {
    return reflection.isInstance(item, RuleCall);
  }
  var TerminalAlternatives = "TerminalAlternatives";
  function isTerminalAlternatives(item) {
    return reflection.isInstance(item, TerminalAlternatives);
  }
  var TerminalGroup = "TerminalGroup";
  function isTerminalGroup(item) {
    return reflection.isInstance(item, TerminalGroup);
  }
  var TerminalRuleCall = "TerminalRuleCall";
  function isTerminalRuleCall(item) {
    return reflection.isInstance(item, TerminalRuleCall);
  }
  var UnorderedGroup = "UnorderedGroup";
  function isUnorderedGroup(item) {
    return reflection.isInstance(item, UnorderedGroup);
  }
  var UntilToken = "UntilToken";
  function isUntilToken(item) {
    return reflection.isInstance(item, UntilToken);
  }
  var Wildcard = "Wildcard";
  function isWildcard(item) {
    return reflection.isInstance(item, Wildcard);
  }
  var LangiumGrammarAstReflection = class extends AbstractAstReflection {
    getAllTypes() {
      return ["AbstractElement", "AbstractRule", "AbstractType", "Action", "Alternatives", "ArrayLiteral", "ArrayType", "Assignment", "BooleanLiteral", "CharacterRange", "Condition", "Conjunction", "CrossReference", "Disjunction", "EndOfFile", "Grammar", "GrammarImport", "Group", "InferredType", "Interface", "Keyword", "NamedArgument", "NegatedToken", "Negation", "NumberLiteral", "Parameter", "ParameterReference", "ParserRule", "ReferenceType", "RegexToken", "ReturnType", "RuleCall", "SimpleType", "StringLiteral", "TerminalAlternatives", "TerminalGroup", "TerminalRule", "TerminalRuleCall", "Type", "TypeAttribute", "TypeDefinition", "UnionType", "UnorderedGroup", "UntilToken", "ValueLiteral", "Wildcard"];
    }
    computeIsSubtype(subtype, supertype) {
      switch (subtype) {
        case Action:
        case Alternatives:
        case Assignment:
        case CharacterRange:
        case CrossReference:
        case EndOfFile:
        case Group:
        case Keyword:
        case NegatedToken:
        case RegexToken:
        case RuleCall:
        case TerminalAlternatives:
        case TerminalGroup:
        case TerminalRuleCall:
        case UnorderedGroup:
        case UntilToken:
        case Wildcard: {
          return this.isSubtype(AbstractElement, supertype);
        }
        case ArrayLiteral:
        case NumberLiteral:
        case StringLiteral: {
          return this.isSubtype(ValueLiteral, supertype);
        }
        case ArrayType:
        case ReferenceType:
        case SimpleType:
        case UnionType: {
          return this.isSubtype(TypeDefinition, supertype);
        }
        case BooleanLiteral: {
          return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);
        }
        case Conjunction:
        case Disjunction:
        case Negation:
        case ParameterReference: {
          return this.isSubtype(Condition, supertype);
        }
        case InferredType:
        case Interface:
        case Type: {
          return this.isSubtype(AbstractType, supertype);
        }
        case ParserRule: {
          return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);
        }
        case TerminalRule: {
          return this.isSubtype(AbstractRule, supertype);
        }
        default: {
          return false;
        }
      }
    }
    getReferenceType(refInfo) {
      const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
      switch (referenceId) {
        case "Action:type":
        case "CrossReference:type":
        case "Interface:superTypes":
        case "ParserRule:returnType":
        case "SimpleType:typeRef": {
          return AbstractType;
        }
        case "Grammar:hiddenTokens":
        case "ParserRule:hiddenTokens":
        case "RuleCall:rule": {
          return AbstractRule;
        }
        case "Grammar:usedGrammars": {
          return Grammar;
        }
        case "NamedArgument:parameter":
        case "ParameterReference:parameter": {
          return Parameter;
        }
        case "TerminalRuleCall:rule": {
          return TerminalRule;
        }
        default: {
          throw new Error(`${referenceId} is not a valid reference id.`);
        }
      }
    }
    getTypeMetaData(type) {
      switch (type) {
        case "AbstractElement": {
          return {
            name: "AbstractElement",
            properties: [
              { name: "cardinality" },
              { name: "lookahead" }
            ]
          };
        }
        case "ArrayLiteral": {
          return {
            name: "ArrayLiteral",
            properties: [
              { name: "elements", defaultValue: [] }
            ]
          };
        }
        case "ArrayType": {
          return {
            name: "ArrayType",
            properties: [
              { name: "elementType" }
            ]
          };
        }
        case "BooleanLiteral": {
          return {
            name: "BooleanLiteral",
            properties: [
              { name: "true", defaultValue: false }
            ]
          };
        }
        case "Conjunction": {
          return {
            name: "Conjunction",
            properties: [
              { name: "left" },
              { name: "right" }
            ]
          };
        }
        case "Disjunction": {
          return {
            name: "Disjunction",
            properties: [
              { name: "left" },
              { name: "right" }
            ]
          };
        }
        case "Grammar": {
          return {
            name: "Grammar",
            properties: [
              { name: "definesHiddenTokens", defaultValue: false },
              { name: "hiddenTokens", defaultValue: [] },
              { name: "imports", defaultValue: [] },
              { name: "interfaces", defaultValue: [] },
              { name: "isDeclared", defaultValue: false },
              { name: "name" },
              { name: "rules", defaultValue: [] },
              { name: "types", defaultValue: [] },
              { name: "usedGrammars", defaultValue: [] }
            ]
          };
        }
        case "GrammarImport": {
          return {
            name: "GrammarImport",
            properties: [
              { name: "path" }
            ]
          };
        }
        case "InferredType": {
          return {
            name: "InferredType",
            properties: [
              { name: "name" }
            ]
          };
        }
        case "Interface": {
          return {
            name: "Interface",
            properties: [
              { name: "attributes", defaultValue: [] },
              { name: "name" },
              { name: "superTypes", defaultValue: [] }
            ]
          };
        }
        case "NamedArgument": {
          return {
            name: "NamedArgument",
            properties: [
              { name: "calledByName", defaultValue: false },
              { name: "parameter" },
              { name: "value" }
            ]
          };
        }
        case "Negation": {
          return {
            name: "Negation",
            properties: [
              { name: "value" }
            ]
          };
        }
        case "NumberLiteral": {
          return {
            name: "NumberLiteral",
            properties: [
              { name: "value" }
            ]
          };
        }
        case "Parameter": {
          return {
            name: "Parameter",
            properties: [
              { name: "name" }
            ]
          };
        }
        case "ParameterReference": {
          return {
            name: "ParameterReference",
            properties: [
              { name: "parameter" }
            ]
          };
        }
        case "ParserRule": {
          return {
            name: "ParserRule",
            properties: [
              { name: "dataType" },
              { name: "definesHiddenTokens", defaultValue: false },
              { name: "definition" },
              { name: "entry", defaultValue: false },
              { name: "fragment", defaultValue: false },
              { name: "hiddenTokens", defaultValue: [] },
              { name: "inferredType" },
              { name: "name" },
              { name: "parameters", defaultValue: [] },
              { name: "returnType" },
              { name: "wildcard", defaultValue: false }
            ]
          };
        }
        case "ReferenceType": {
          return {
            name: "ReferenceType",
            properties: [
              { name: "referenceType" }
            ]
          };
        }
        case "ReturnType": {
          return {
            name: "ReturnType",
            properties: [
              { name: "name" }
            ]
          };
        }
        case "SimpleType": {
          return {
            name: "SimpleType",
            properties: [
              { name: "primitiveType" },
              { name: "stringType" },
              { name: "typeRef" }
            ]
          };
        }
        case "StringLiteral": {
          return {
            name: "StringLiteral",
            properties: [
              { name: "value" }
            ]
          };
        }
        case "TerminalRule": {
          return {
            name: "TerminalRule",
            properties: [
              { name: "definition" },
              { name: "fragment", defaultValue: false },
              { name: "hidden", defaultValue: false },
              { name: "name" },
              { name: "type" }
            ]
          };
        }
        case "Type": {
          return {
            name: "Type",
            properties: [
              { name: "name" },
              { name: "type" }
            ]
          };
        }
        case "TypeAttribute": {
          return {
            name: "TypeAttribute",
            properties: [
              { name: "defaultValue" },
              { name: "isOptional", defaultValue: false },
              { name: "name" },
              { name: "type" }
            ]
          };
        }
        case "UnionType": {
          return {
            name: "UnionType",
            properties: [
              { name: "types", defaultValue: [] }
            ]
          };
        }
        case "Action": {
          return {
            name: "Action",
            properties: [
              { name: "cardinality" },
              { name: "feature" },
              { name: "inferredType" },
              { name: "lookahead" },
              { name: "operator" },
              { name: "type" }
            ]
          };
        }
        case "Alternatives": {
          return {
            name: "Alternatives",
            properties: [
              { name: "cardinality" },
              { name: "elements", defaultValue: [] },
              { name: "lookahead" }
            ]
          };
        }
        case "Assignment": {
          return {
            name: "Assignment",
            properties: [
              { name: "cardinality" },
              { name: "feature" },
              { name: "lookahead" },
              { name: "operator" },
              { name: "terminal" }
            ]
          };
        }
        case "CharacterRange": {
          return {
            name: "CharacterRange",
            properties: [
              { name: "cardinality" },
              { name: "left" },
              { name: "lookahead" },
              { name: "right" }
            ]
          };
        }
        case "CrossReference": {
          return {
            name: "CrossReference",
            properties: [
              { name: "cardinality" },
              { name: "deprecatedSyntax", defaultValue: false },
              { name: "lookahead" },
              { name: "terminal" },
              { name: "type" }
            ]
          };
        }
        case "EndOfFile": {
          return {
            name: "EndOfFile",
            properties: [
              { name: "cardinality" },
              { name: "lookahead" }
            ]
          };
        }
        case "Group": {
          return {
            name: "Group",
            properties: [
              { name: "cardinality" },
              { name: "elements", defaultValue: [] },
              { name: "guardCondition" },
              { name: "lookahead" }
            ]
          };
        }
        case "Keyword": {
          return {
            name: "Keyword",
            properties: [
              { name: "cardinality" },
              { name: "lookahead" },
              { name: "value" }
            ]
          };
        }
        case "NegatedToken": {
          return {
            name: "NegatedToken",
            properties: [
              { name: "cardinality" },
              { name: "lookahead" },
              { name: "terminal" }
            ]
          };
        }
        case "RegexToken": {
          return {
            name: "RegexToken",
            properties: [
              { name: "cardinality" },
              { name: "lookahead" },
              { name: "regex" }
            ]
          };
        }
        case "RuleCall": {
          return {
            name: "RuleCall",
            properties: [
              { name: "arguments", defaultValue: [] },
              { name: "cardinality" },
              { name: "lookahead" },
              { name: "rule" }
            ]
          };
        }
        case "TerminalAlternatives": {
          return {
            name: "TerminalAlternatives",
            properties: [
              { name: "cardinality" },
              { name: "elements", defaultValue: [] },
              { name: "lookahead" }
            ]
          };
        }
        case "TerminalGroup": {
          return {
            name: "TerminalGroup",
            properties: [
              { name: "cardinality" },
              { name: "elements", defaultValue: [] },
              { name: "lookahead" }
            ]
          };
        }
        case "TerminalRuleCall": {
          return {
            name: "TerminalRuleCall",
            properties: [
              { name: "cardinality" },
              { name: "lookahead" },
              { name: "rule" }
            ]
          };
        }
        case "UnorderedGroup": {
          return {
            name: "UnorderedGroup",
            properties: [
              { name: "cardinality" },
              { name: "elements", defaultValue: [] },
              { name: "lookahead" }
            ]
          };
        }
        case "UntilToken": {
          return {
            name: "UntilToken",
            properties: [
              { name: "cardinality" },
              { name: "lookahead" },
              { name: "terminal" }
            ]
          };
        }
        case "Wildcard": {
          return {
            name: "Wildcard",
            properties: [
              { name: "cardinality" },
              { name: "lookahead" }
            ]
          };
        }
        default: {
          return {
            name: type,
            properties: []
          };
        }
      }
    }
  };
  var reflection = new LangiumGrammarAstReflection();

  // ../node_modules/langium/lib/utils/ast-utils.js
  var ast_utils_exports = {};
  __export(ast_utils_exports, {
    assignMandatoryProperties: () => assignMandatoryProperties,
    copyAstNode: () => copyAstNode,
    findLocalReferences: () => findLocalReferences,
    findRootNode: () => findRootNode,
    getContainerOfType: () => getContainerOfType,
    getDocument: () => getDocument,
    hasContainerOfType: () => hasContainerOfType,
    linkContentToContainer: () => linkContentToContainer,
    streamAllContents: () => streamAllContents,
    streamAst: () => streamAst,
    streamContents: () => streamContents,
    streamReferences: () => streamReferences
  });
  function linkContentToContainer(node) {
    for (const [name, value] of Object.entries(node)) {
      if (!name.startsWith("$")) {
        if (Array.isArray(value)) {
          value.forEach((item, index) => {
            if (isAstNode(item)) {
              item.$container = node;
              item.$containerProperty = name;
              item.$containerIndex = index;
            }
          });
        } else if (isAstNode(value)) {
          value.$container = node;
          value.$containerProperty = name;
        }
      }
    }
  }
  function getContainerOfType(node, typePredicate) {
    let item = node;
    while (item) {
      if (typePredicate(item)) {
        return item;
      }
      item = item.$container;
    }
    return void 0;
  }
  function hasContainerOfType(node, predicate) {
    let item = node;
    while (item) {
      if (predicate(item)) {
        return true;
      }
      item = item.$container;
    }
    return false;
  }
  function getDocument(node) {
    const rootNode = findRootNode(node);
    const result = rootNode.$document;
    if (!result) {
      throw new Error("AST node has no document.");
    }
    return result;
  }
  function findRootNode(node) {
    while (node.$container) {
      node = node.$container;
    }
    return node;
  }
  function streamContents(node, options) {
    if (!node) {
      throw new Error("Node must be an AstNode.");
    }
    const range = options === null || options === void 0 ? void 0 : options.range;
    return new StreamImpl(() => ({
      keys: Object.keys(node),
      keyIndex: 0,
      arrayIndex: 0
    }), (state) => {
      while (state.keyIndex < state.keys.length) {
        const property2 = state.keys[state.keyIndex];
        if (!property2.startsWith("$")) {
          const value = node[property2];
          if (isAstNode(value)) {
            state.keyIndex++;
            if (isAstNodeInRange(value, range)) {
              return { done: false, value };
            }
          } else if (Array.isArray(value)) {
            while (state.arrayIndex < value.length) {
              const index = state.arrayIndex++;
              const element = value[index];
              if (isAstNode(element) && isAstNodeInRange(element, range)) {
                return { done: false, value: element };
              }
            }
            state.arrayIndex = 0;
          }
        }
        state.keyIndex++;
      }
      return DONE_RESULT;
    });
  }
  function streamAllContents(root2, options) {
    if (!root2) {
      throw new Error("Root node must be an AstNode.");
    }
    return new TreeStreamImpl(root2, (node) => streamContents(node, options));
  }
  function streamAst(root2, options) {
    if (!root2) {
      throw new Error("Root node must be an AstNode.");
    } else if ((options === null || options === void 0 ? void 0 : options.range) && !isAstNodeInRange(root2, options.range)) {
      return new TreeStreamImpl(root2, () => []);
    }
    return new TreeStreamImpl(root2, (node) => streamContents(node, options), { includeRoot: true });
  }
  function isAstNodeInRange(astNode, range) {
    var _a;
    if (!range) {
      return true;
    }
    const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;
    if (!nodeRange) {
      return false;
    }
    return inRange(nodeRange, range);
  }
  function streamReferences(node) {
    return new StreamImpl(() => ({
      keys: Object.keys(node),
      keyIndex: 0,
      arrayIndex: 0
    }), (state) => {
      while (state.keyIndex < state.keys.length) {
        const property2 = state.keys[state.keyIndex];
        if (!property2.startsWith("$")) {
          const value = node[property2];
          if (isReference(value)) {
            state.keyIndex++;
            return { done: false, value: { reference: value, container: node, property: property2 } };
          } else if (Array.isArray(value)) {
            while (state.arrayIndex < value.length) {
              const index = state.arrayIndex++;
              const element = value[index];
              if (isReference(element)) {
                return { done: false, value: { reference: element, container: node, property: property2, index } };
              }
            }
            state.arrayIndex = 0;
          }
        }
        state.keyIndex++;
      }
      return DONE_RESULT;
    });
  }
  function findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {
    const refs = [];
    streamAst(lookup).forEach((node) => {
      streamReferences(node).forEach((refInfo) => {
        if (refInfo.reference.ref === targetNode) {
          refs.push(refInfo.reference);
        }
      });
    });
    return stream(refs);
  }
  function assignMandatoryProperties(reflection3, node) {
    const typeMetaData = reflection3.getTypeMetaData(node.$type);
    const genericNode = node;
    for (const property2 of typeMetaData.properties) {
      if (property2.defaultValue !== void 0 && genericNode[property2.name] === void 0) {
        genericNode[property2.name] = copyDefaultValue(property2.defaultValue);
      }
    }
  }
  function copyDefaultValue(propertyType) {
    if (Array.isArray(propertyType)) {
      return [...propertyType.map(copyDefaultValue)];
    } else {
      return propertyType;
    }
  }
  function copyAstNode(node, buildReference) {
    const copy = { $type: node.$type };
    for (const [name, value] of Object.entries(node)) {
      if (!name.startsWith("$")) {
        if (isAstNode(value)) {
          copy[name] = copyAstNode(value, buildReference);
        } else if (isReference(value)) {
          copy[name] = buildReference(copy, name, value.$refNode, value.$refText);
        } else if (Array.isArray(value)) {
          const copiedArray = [];
          for (const element of value) {
            if (isAstNode(element)) {
              copiedArray.push(copyAstNode(element, buildReference));
            } else if (isReference(element)) {
              copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));
            } else {
              copiedArray.push(element);
            }
          }
          copy[name] = copiedArray;
        } else {
          copy[name] = value;
        }
      }
    }
    linkContentToContainer(copy);
    return copy;
  }

  // ../node_modules/langium/lib/utils/regexp-utils.js
  var regexp_utils_exports = {};
  __export(regexp_utils_exports, {
    NEWLINE_REGEXP: () => NEWLINE_REGEXP,
    escapeRegExp: () => escapeRegExp,
    getCaseInsensitivePattern: () => getCaseInsensitivePattern,
    getTerminalParts: () => getTerminalParts,
    isMultilineComment: () => isMultilineComment,
    isWhitespace: () => isWhitespace,
    partialMatches: () => partialMatches,
    partialRegExp: () => partialRegExp
  });

  // ../node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js
  function cc(char) {
    return char.charCodeAt(0);
  }
  function insertToSet(item, set) {
    if (Array.isArray(item)) {
      item.forEach(function(subItem) {
        set.push(subItem);
      });
    } else {
      set.push(item);
    }
  }
  function addFlag(flagObj, flagKey) {
    if (flagObj[flagKey] === true) {
      throw "duplicate flag " + flagKey;
    }
    const x = flagObj[flagKey];
    flagObj[flagKey] = true;
  }
  function ASSERT_EXISTS(obj) {
    if (obj === void 0) {
      throw Error("Internal Error - Should never get here!");
    }
    return true;
  }
  function ASSERT_NEVER_REACH_HERE() {
    throw Error("Internal Error - Should never get here!");
  }
  function isCharacter(obj) {
    return obj["type"] === "Character";
  }

  // ../node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js
  var digitsCharCodes = [];
  for (let i = cc("0"); i <= cc("9"); i++) {
    digitsCharCodes.push(i);
  }
  var wordCharCodes = [cc("_")].concat(digitsCharCodes);
  for (let i = cc("a"); i <= cc("z"); i++) {
    wordCharCodes.push(i);
  }
  for (let i = cc("A"); i <= cc("Z"); i++) {
    wordCharCodes.push(i);
  }
  var whitespaceCodes = [
    cc(" "),
    cc("\f"),
    cc("\n"),
    cc("\r"),
    cc("	"),
    cc("\v"),
    cc("	"),
    cc("\xA0"),
    cc("\u1680"),
    cc("\u2000"),
    cc("\u2001"),
    cc("\u2002"),
    cc("\u2003"),
    cc("\u2004"),
    cc("\u2005"),
    cc("\u2006"),
    cc("\u2007"),
    cc("\u2008"),
    cc("\u2009"),
    cc("\u200A"),
    cc("\u2028"),
    cc("\u2029"),
    cc("\u202F"),
    cc("\u205F"),
    cc("\u3000"),
    cc("\uFEFF")
  ];

  // ../node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js
  var hexDigitPattern = /[0-9a-fA-F]/;
  var decimalPattern = /[0-9]/;
  var decimalPatternNoZero = /[1-9]/;
  var RegExpParser = class {
    constructor() {
      this.idx = 0;
      this.input = "";
      this.groupIdx = 0;
    }
    saveState() {
      return {
        idx: this.idx,
        input: this.input,
        groupIdx: this.groupIdx
      };
    }
    restoreState(newState2) {
      this.idx = newState2.idx;
      this.input = newState2.input;
      this.groupIdx = newState2.groupIdx;
    }
    pattern(input) {
      this.idx = 0;
      this.input = input;
      this.groupIdx = 0;
      this.consumeChar("/");
      const value = this.disjunction();
      this.consumeChar("/");
      const flags = {
        type: "Flags",
        loc: { begin: this.idx, end: input.length },
        global: false,
        ignoreCase: false,
        multiLine: false,
        unicode: false,
        sticky: false
      };
      while (this.isRegExpFlag()) {
        switch (this.popChar()) {
          case "g":
            addFlag(flags, "global");
            break;
          case "i":
            addFlag(flags, "ignoreCase");
            break;
          case "m":
            addFlag(flags, "multiLine");
            break;
          case "u":
            addFlag(flags, "unicode");
            break;
          case "y":
            addFlag(flags, "sticky");
            break;
        }
      }
      if (this.idx !== this.input.length) {
        throw Error("Redundant input: " + this.input.substring(this.idx));
      }
      return {
        type: "Pattern",
        flags,
        value,
        loc: this.loc(0)
      };
    }
    disjunction() {
      const alts = [];
      const begin = this.idx;
      alts.push(this.alternative());
      while (this.peekChar() === "|") {
        this.consumeChar("|");
        alts.push(this.alternative());
      }
      return { type: "Disjunction", value: alts, loc: this.loc(begin) };
    }
    alternative() {
      const terms = [];
      const begin = this.idx;
      while (this.isTerm()) {
        terms.push(this.term());
      }
      return { type: "Alternative", value: terms, loc: this.loc(begin) };
    }
    term() {
      if (this.isAssertion()) {
        return this.assertion();
      } else {
        return this.atom();
      }
    }
    assertion() {
      const begin = this.idx;
      switch (this.popChar()) {
        case "^":
          return {
            type: "StartAnchor",
            loc: this.loc(begin)
          };
        case "$":
          return { type: "EndAnchor", loc: this.loc(begin) };
        case "\\":
          switch (this.popChar()) {
            case "b":
              return {
                type: "WordBoundary",
                loc: this.loc(begin)
              };
            case "B":
              return {
                type: "NonWordBoundary",
                loc: this.loc(begin)
              };
          }
          throw Error("Invalid Assertion Escape");
        case "(":
          this.consumeChar("?");
          let type;
          switch (this.popChar()) {
            case "=":
              type = "Lookahead";
              break;
            case "!":
              type = "NegativeLookahead";
              break;
          }
          ASSERT_EXISTS(type);
          const disjunction = this.disjunction();
          this.consumeChar(")");
          return {
            type,
            value: disjunction,
            loc: this.loc(begin)
          };
      }
      return ASSERT_NEVER_REACH_HERE();
    }
    quantifier(isBacktracking = false) {
      let range = void 0;
      const begin = this.idx;
      switch (this.popChar()) {
        case "*":
          range = {
            atLeast: 0,
            atMost: Infinity
          };
          break;
        case "+":
          range = {
            atLeast: 1,
            atMost: Infinity
          };
          break;
        case "?":
          range = {
            atLeast: 0,
            atMost: 1
          };
          break;
        case "{":
          const atLeast = this.integerIncludingZero();
          switch (this.popChar()) {
            case "}":
              range = {
                atLeast,
                atMost: atLeast
              };
              break;
            case ",":
              let atMost;
              if (this.isDigit()) {
                atMost = this.integerIncludingZero();
                range = {
                  atLeast,
                  atMost
                };
              } else {
                range = {
                  atLeast,
                  atMost: Infinity
                };
              }
              this.consumeChar("}");
              break;
          }
          if (isBacktracking === true && range === void 0) {
            return void 0;
          }
          ASSERT_EXISTS(range);
          break;
      }
      if (isBacktracking === true && range === void 0) {
        return void 0;
      }
      if (ASSERT_EXISTS(range)) {
        if (this.peekChar(0) === "?") {
          this.consumeChar("?");
          range.greedy = false;
        } else {
          range.greedy = true;
        }
        range.type = "Quantifier";
        range.loc = this.loc(begin);
        return range;
      }
    }
    atom() {
      let atom2;
      const begin = this.idx;
      switch (this.peekChar()) {
        case ".":
          atom2 = this.dotAll();
          break;
        case "\\":
          atom2 = this.atomEscape();
          break;
        case "[":
          atom2 = this.characterClass();
          break;
        case "(":
          atom2 = this.group();
          break;
      }
      if (atom2 === void 0 && this.isPatternCharacter()) {
        atom2 = this.patternCharacter();
      }
      if (ASSERT_EXISTS(atom2)) {
        atom2.loc = this.loc(begin);
        if (this.isQuantifier()) {
          atom2.quantifier = this.quantifier();
        }
        return atom2;
      }
      return ASSERT_NEVER_REACH_HERE();
    }
    dotAll() {
      this.consumeChar(".");
      return {
        type: "Set",
        complement: true,
        value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
      };
    }
    atomEscape() {
      this.consumeChar("\\");
      switch (this.peekChar()) {
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          return this.decimalEscapeAtom();
        case "d":
        case "D":
        case "s":
        case "S":
        case "w":
        case "W":
          return this.characterClassEscape();
        case "f":
        case "n":
        case "r":
        case "t":
        case "v":
          return this.controlEscapeAtom();
        case "c":
          return this.controlLetterEscapeAtom();
        case "0":
          return this.nulCharacterAtom();
        case "x":
          return this.hexEscapeSequenceAtom();
        case "u":
          return this.regExpUnicodeEscapeSequenceAtom();
        default:
          return this.identityEscapeAtom();
      }
    }
    decimalEscapeAtom() {
      const value = this.positiveInteger();
      return { type: "GroupBackReference", value };
    }
    characterClassEscape() {
      let set;
      let complement = false;
      switch (this.popChar()) {
        case "d":
          set = digitsCharCodes;
          break;
        case "D":
          set = digitsCharCodes;
          complement = true;
          break;
        case "s":
          set = whitespaceCodes;
          break;
        case "S":
          set = whitespaceCodes;
          complement = true;
          break;
        case "w":
          set = wordCharCodes;
          break;
        case "W":
          set = wordCharCodes;
          complement = true;
          break;
      }
      if (ASSERT_EXISTS(set)) {
        return { type: "Set", value: set, complement };
      }
      return ASSERT_NEVER_REACH_HERE();
    }
    controlEscapeAtom() {
      let escapeCode;
      switch (this.popChar()) {
        case "f":
          escapeCode = cc("\f");
          break;
        case "n":
          escapeCode = cc("\n");
          break;
        case "r":
          escapeCode = cc("\r");
          break;
        case "t":
          escapeCode = cc("	");
          break;
        case "v":
          escapeCode = cc("\v");
          break;
      }
      if (ASSERT_EXISTS(escapeCode)) {
        return { type: "Character", value: escapeCode };
      }
      return ASSERT_NEVER_REACH_HERE();
    }
    controlLetterEscapeAtom() {
      this.consumeChar("c");
      const letter = this.popChar();
      if (/[a-zA-Z]/.test(letter) === false) {
        throw Error("Invalid ");
      }
      const letterCode = letter.toUpperCase().charCodeAt(0) - 64;
      return { type: "Character", value: letterCode };
    }
    nulCharacterAtom() {
      this.consumeChar("0");
      return { type: "Character", value: cc("\0") };
    }
    hexEscapeSequenceAtom() {
      this.consumeChar("x");
      return this.parseHexDigits(2);
    }
    regExpUnicodeEscapeSequenceAtom() {
      this.consumeChar("u");
      return this.parseHexDigits(4);
    }
    identityEscapeAtom() {
      const escapedChar = this.popChar();
      return { type: "Character", value: cc(escapedChar) };
    }
    classPatternCharacterAtom() {
      switch (this.peekChar()) {
        case "\n":
        case "\r":
        case "\u2028":
        case "\u2029":
        case "\\":
        case "]":
          throw Error("TBD");
        default:
          const nextChar = this.popChar();
          return { type: "Character", value: cc(nextChar) };
      }
    }
    characterClass() {
      const set = [];
      let complement = false;
      this.consumeChar("[");
      if (this.peekChar(0) === "^") {
        this.consumeChar("^");
        complement = true;
      }
      while (this.isClassAtom()) {
        const from = this.classAtom();
        const isFromSingleChar = from.type === "Character";
        if (isCharacter(from) && this.isRangeDash()) {
          this.consumeChar("-");
          const to = this.classAtom();
          const isToSingleChar = to.type === "Character";
          if (isCharacter(to)) {
            if (to.value < from.value) {
              throw Error("Range out of order in character class");
            }
            set.push({ from: from.value, to: to.value });
          } else {
            insertToSet(from.value, set);
            set.push(cc("-"));
            insertToSet(to.value, set);
          }
        } else {
          insertToSet(from.value, set);
        }
      }
      this.consumeChar("]");
      return { type: "Set", complement, value: set };
    }
    classAtom() {
      switch (this.peekChar()) {
        case "]":
        case "\n":
        case "\r":
        case "\u2028":
        case "\u2029":
          throw Error("TBD");
        case "\\":
          return this.classEscape();
        default:
          return this.classPatternCharacterAtom();
      }
    }
    classEscape() {
      this.consumeChar("\\");
      switch (this.peekChar()) {
        case "b":
          this.consumeChar("b");
          return { type: "Character", value: cc("\b") };
        case "d":
        case "D":
        case "s":
        case "S":
        case "w":
        case "W":
          return this.characterClassEscape();
        case "f":
        case "n":
        case "r":
        case "t":
        case "v":
          return this.controlEscapeAtom();
        case "c":
          return this.controlLetterEscapeAtom();
        case "0":
          return this.nulCharacterAtom();
        case "x":
          return this.hexEscapeSequenceAtom();
        case "u":
          return this.regExpUnicodeEscapeSequenceAtom();
        default:
          return this.identityEscapeAtom();
      }
    }
    group() {
      let capturing = true;
      this.consumeChar("(");
      switch (this.peekChar(0)) {
        case "?":
          this.consumeChar("?");
          this.consumeChar(":");
          capturing = false;
          break;
        default:
          this.groupIdx++;
          break;
      }
      const value = this.disjunction();
      this.consumeChar(")");
      const groupAst = {
        type: "Group",
        capturing,
        value
      };
      if (capturing) {
        groupAst["idx"] = this.groupIdx;
      }
      return groupAst;
    }
    positiveInteger() {
      let number = this.popChar();
      if (decimalPatternNoZero.test(number) === false) {
        throw Error("Expecting a positive integer");
      }
      while (decimalPattern.test(this.peekChar(0))) {
        number += this.popChar();
      }
      return parseInt(number, 10);
    }
    integerIncludingZero() {
      let number = this.popChar();
      if (decimalPattern.test(number) === false) {
        throw Error("Expecting an integer");
      }
      while (decimalPattern.test(this.peekChar(0))) {
        number += this.popChar();
      }
      return parseInt(number, 10);
    }
    patternCharacter() {
      const nextChar = this.popChar();
      switch (nextChar) {
        case "\n":
        case "\r":
        case "\u2028":
        case "\u2029":
        case "^":
        case "$":
        case "\\":
        case ".":
        case "*":
        case "+":
        case "?":
        case "(":
        case ")":
        case "[":
        case "|":
          throw Error("TBD");
        default:
          return { type: "Character", value: cc(nextChar) };
      }
    }
    isRegExpFlag() {
      switch (this.peekChar(0)) {
        case "g":
        case "i":
        case "m":
        case "u":
        case "y":
          return true;
        default:
          return false;
      }
    }
    isRangeDash() {
      return this.peekChar() === "-" && this.isClassAtom(1);
    }
    isDigit() {
      return decimalPattern.test(this.peekChar(0));
    }
    isClassAtom(howMuch = 0) {
      switch (this.peekChar(howMuch)) {
        case "]":
        case "\n":
        case "\r":
        case "\u2028":
        case "\u2029":
          return false;
        default:
          return true;
      }
    }
    isTerm() {
      return this.isAtom() || this.isAssertion();
    }
    isAtom() {
      if (this.isPatternCharacter()) {
        return true;
      }
      switch (this.peekChar(0)) {
        case ".":
        case "\\":
        case "[":
        case "(":
          return true;
        default:
          return false;
      }
    }
    isAssertion() {
      switch (this.peekChar(0)) {
        case "^":
        case "$":
          return true;
        case "\\":
          switch (this.peekChar(1)) {
            case "b":
            case "B":
              return true;
            default:
              return false;
          }
        case "(":
          return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
        default:
          return false;
      }
    }
    isQuantifier() {
      const prevState = this.saveState();
      try {
        return this.quantifier(true) !== void 0;
      } catch (e) {
        return false;
      } finally {
        this.restoreState(prevState);
      }
    }
    isPatternCharacter() {
      switch (this.peekChar()) {
        case "^":
        case "$":
        case "\\":
        case ".":
        case "*":
        case "+":
        case "?":
        case "(":
        case ")":
        case "[":
        case "|":
        case "/":
        case "\n":
        case "\r":
        case "\u2028":
        case "\u2029":
          return false;
        default:
          return true;
      }
    }
    parseHexDigits(howMany) {
      let hexString = "";
      for (let i = 0; i < howMany; i++) {
        const hexChar = this.popChar();
        if (hexDigitPattern.test(hexChar) === false) {
          throw Error("Expecting a HexDecimal digits");
        }
        hexString += hexChar;
      }
      const charCode = parseInt(hexString, 16);
      return { type: "Character", value: charCode };
    }
    peekChar(howMuch = 0) {
      return this.input[this.idx + howMuch];
    }
    popChar() {
      const nextChar = this.peekChar(0);
      this.consumeChar(void 0);
      return nextChar;
    }
    consumeChar(char) {
      if (char !== void 0 && this.input[this.idx] !== char) {
        throw Error("Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
      }
      if (this.idx >= this.input.length) {
        throw Error("Unexpected end of input");
      }
      this.idx++;
    }
    loc(begin) {
      return { begin, end: this.idx };
    }
  };

  // ../node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js
  var BaseRegExpVisitor = class {
    visitChildren(node) {
      for (const key in node) {
        const child = node[key];
        if (node.hasOwnProperty(key)) {
          if (child.type !== void 0) {
            this.visit(child);
          } else if (Array.isArray(child)) {
            child.forEach((subChild) => {
              this.visit(subChild);
            }, this);
          }
        }
      }
    }
    visit(node) {
      switch (node.type) {
        case "Pattern":
          this.visitPattern(node);
          break;
        case "Flags":
          this.visitFlags(node);
          break;
        case "Disjunction":
          this.visitDisjunction(node);
          break;
        case "Alternative":
          this.visitAlternative(node);
          break;
        case "StartAnchor":
          this.visitStartAnchor(node);
          break;
        case "EndAnchor":
          this.visitEndAnchor(node);
          break;
        case "WordBoundary":
          this.visitWordBoundary(node);
          break;
        case "NonWordBoundary":
          this.visitNonWordBoundary(node);
          break;
        case "Lookahead":
          this.visitLookahead(node);
          break;
        case "NegativeLookahead":
          this.visitNegativeLookahead(node);
          break;
        case "Character":
          this.visitCharacter(node);
          break;
        case "Set":
          this.visitSet(node);
          break;
        case "Group":
          this.visitGroup(node);
          break;
        case "GroupBackReference":
          this.visitGroupBackReference(node);
          break;
        case "Quantifier":
          this.visitQuantifier(node);
          break;
      }
      this.visitChildren(node);
    }
    visitPattern(node) {
    }
    visitFlags(node) {
    }
    visitDisjunction(node) {
    }
    visitAlternative(node) {
    }
    // Assertion
    visitStartAnchor(node) {
    }
    visitEndAnchor(node) {
    }
    visitWordBoundary(node) {
    }
    visitNonWordBoundary(node) {
    }
    visitLookahead(node) {
    }
    visitNegativeLookahead(node) {
    }
    // atoms
    visitCharacter(node) {
    }
    visitSet(node) {
    }
    visitGroup(node) {
    }
    visitGroupBackReference(node) {
    }
    visitQuantifier(node) {
    }
  };

  // ../node_modules/langium/lib/utils/regexp-utils.js
  var NEWLINE_REGEXP = /\r?\n/gm;
  var regexpParser = new RegExpParser();
  var TerminalRegExpVisitor = class extends BaseRegExpVisitor {
    constructor() {
      super(...arguments);
      this.isStarting = true;
      this.endRegexpStack = [];
      this.multiline = false;
    }
    get endRegex() {
      return this.endRegexpStack.join("");
    }
    reset(regex) {
      this.multiline = false;
      this.regex = regex;
      this.startRegexp = "";
      this.isStarting = true;
      this.endRegexpStack = [];
    }
    visitGroup(node) {
      if (node.quantifier) {
        this.isStarting = false;
        this.endRegexpStack = [];
      }
    }
    visitCharacter(node) {
      const char = String.fromCharCode(node.value);
      if (!this.multiline && char === "\n") {
        this.multiline = true;
      }
      if (node.quantifier) {
        this.isStarting = false;
        this.endRegexpStack = [];
      } else {
        const escapedChar = escapeRegExp(char);
        this.endRegexpStack.push(escapedChar);
        if (this.isStarting) {
          this.startRegexp += escapedChar;
        }
      }
    }
    visitSet(node) {
      if (!this.multiline) {
        const set = this.regex.substring(node.loc.begin, node.loc.end);
        const regex = new RegExp(set);
        this.multiline = Boolean("\n".match(regex));
      }
      if (node.quantifier) {
        this.isStarting = false;
        this.endRegexpStack = [];
      } else {
        const set = this.regex.substring(node.loc.begin, node.loc.end);
        this.endRegexpStack.push(set);
        if (this.isStarting) {
          this.startRegexp += set;
        }
      }
    }
    visitChildren(node) {
      if (node.type === "Group") {
        const group = node;
        if (group.quantifier) {
          return;
        }
      }
      super.visitChildren(node);
    }
  };
  var visitor = new TerminalRegExpVisitor();
  function getTerminalParts(regexp) {
    try {
      if (typeof regexp !== "string") {
        regexp = regexp.source;
      }
      regexp = `/${regexp}/`;
      const pattern = regexpParser.pattern(regexp);
      const parts = [];
      for (const alternative of pattern.value.value) {
        visitor.reset(regexp);
        visitor.visit(alternative);
        parts.push({
          start: visitor.startRegexp,
          end: visitor.endRegex
        });
      }
      return parts;
    } catch (_a) {
      return [];
    }
  }
  function isMultilineComment(regexp) {
    try {
      if (typeof regexp === "string") {
        regexp = new RegExp(regexp);
      }
      regexp = regexp.toString();
      visitor.reset(regexp);
      visitor.visit(regexpParser.pattern(regexp));
      return visitor.multiline;
    } catch (_a) {
      return false;
    }
  }
  function isWhitespace(value) {
    const regexp = typeof value === "string" ? new RegExp(value) : value;
    return regexp.test(" ");
  }
  function escapeRegExp(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function getCaseInsensitivePattern(keyword) {
    return Array.prototype.map.call(keyword, (letter) => /\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join("");
  }
  function partialMatches(regex, input) {
    const partial = partialRegExp(regex);
    const match = input.match(partial);
    return !!match && match[0].length > 0;
  }
  function partialRegExp(regex) {
    if (typeof regex === "string") {
      regex = new RegExp(regex);
    }
    const re = regex, source = regex.source;
    let i = 0;
    function process2() {
      let result = "", tmp;
      function appendRaw(nbChars) {
        result += source.substr(i, nbChars);
        i += nbChars;
      }
      function appendOptional(nbChars) {
        result += "(?:" + source.substr(i, nbChars) + "|$)";
        i += nbChars;
      }
      while (i < source.length) {
        switch (source[i]) {
          case "\\":
            switch (source[i + 1]) {
              case "c":
                appendOptional(3);
                break;
              case "x":
                appendOptional(4);
                break;
              case "u":
                if (re.unicode) {
                  if (source[i + 2] === "{") {
                    appendOptional(source.indexOf("}", i) - i + 1);
                  } else {
                    appendOptional(6);
                  }
                } else {
                  appendOptional(2);
                }
                break;
              case "p":
              case "P":
                if (re.unicode) {
                  appendOptional(source.indexOf("}", i) - i + 1);
                } else {
                  appendOptional(2);
                }
                break;
              case "k":
                appendOptional(source.indexOf(">", i) - i + 1);
                break;
              default:
                appendOptional(2);
                break;
            }
            break;
          case "[":
            tmp = /\[(?:\\.|.)*?\]/g;
            tmp.lastIndex = i;
            tmp = tmp.exec(source) || [];
            appendOptional(tmp[0].length);
            break;
          case "|":
          case "^":
          case "$":
          case "*":
          case "+":
          case "?":
            appendRaw(1);
            break;
          case "{":
            tmp = /\{\d+,?\d*\}/g;
            tmp.lastIndex = i;
            tmp = tmp.exec(source);
            if (tmp) {
              appendRaw(tmp[0].length);
            } else {
              appendOptional(1);
            }
            break;
          case "(":
            if (source[i + 1] === "?") {
              switch (source[i + 2]) {
                case ":":
                  result += "(?:";
                  i += 3;
                  result += process2() + "|$)";
                  break;
                case "=":
                  result += "(?=";
                  i += 3;
                  result += process2() + ")";
                  break;
                case "!":
                  tmp = i;
                  i += 3;
                  process2();
                  result += source.substr(tmp, i - tmp);
                  break;
                case "<":
                  switch (source[i + 3]) {
                    case "=":
                    case "!":
                      tmp = i;
                      i += 4;
                      process2();
                      result += source.substr(tmp, i - tmp);
                      break;
                    default:
                      appendRaw(source.indexOf(">", i) - i + 1);
                      result += process2() + "|$)";
                      break;
                  }
                  break;
              }
            } else {
              appendRaw(1);
              result += process2() + "|$)";
            }
            break;
          case ")":
            ++i;
            return result;
          default:
            appendOptional(1);
            break;
        }
      }
      return result;
    }
    return new RegExp(process2(), regex.flags);
  }

  // ../node_modules/langium/lib/utils/grammar-utils.js
  function getEntryRule(grammar) {
    return grammar.rules.find((e) => isParserRule(e) && e.entry);
  }
  function getHiddenRules(grammar) {
    return grammar.rules.filter((e) => isTerminalRule(e) && e.hidden);
  }
  function getAllReachableRules(grammar, allTerminals) {
    const ruleNames = /* @__PURE__ */ new Set();
    const entryRule = getEntryRule(grammar);
    if (!entryRule) {
      return new Set(grammar.rules);
    }
    const topMostRules = [entryRule].concat(getHiddenRules(grammar));
    for (const rule of topMostRules) {
      ruleDfs(rule, ruleNames, allTerminals);
    }
    const rules = /* @__PURE__ */ new Set();
    for (const rule of grammar.rules) {
      if (ruleNames.has(rule.name) || isTerminalRule(rule) && rule.hidden) {
        rules.add(rule);
      }
    }
    return rules;
  }
  function ruleDfs(rule, visitedSet, allTerminals) {
    visitedSet.add(rule.name);
    streamAllContents(rule).forEach((node) => {
      if (isRuleCall(node) || allTerminals && isTerminalRuleCall(node)) {
        const refRule = node.rule.ref;
        if (refRule && !visitedSet.has(refRule.name)) {
          ruleDfs(refRule, visitedSet, allTerminals);
        }
      }
    });
  }
  function getCrossReferenceTerminal(crossRef) {
    if (crossRef.terminal) {
      return crossRef.terminal;
    } else if (crossRef.type.ref) {
      const nameAssigment = findNameAssignment(crossRef.type.ref);
      return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;
    }
    return void 0;
  }
  function isCommentTerminal(terminalRule) {
    return terminalRule.hidden && !terminalRegex(terminalRule).test(" ");
  }
  function findNodesForProperty(node, property2) {
    if (!node || !property2) {
      return [];
    }
    return findNodesForPropertyInternal(node, property2, node.astNode, true);
  }
  function findNodeForProperty(node, property2, index) {
    if (!node || !property2) {
      return void 0;
    }
    const nodes = findNodesForPropertyInternal(node, property2, node.astNode, true);
    if (nodes.length === 0) {
      return void 0;
    }
    if (index !== void 0) {
      index = Math.max(0, Math.min(index, nodes.length - 1));
    } else {
      index = 0;
    }
    return nodes[index];
  }
  function findNodesForPropertyInternal(node, property2, element, first2) {
    if (!first2) {
      const nodeFeature = getContainerOfType(node.grammarSource, isAssignment);
      if (nodeFeature && nodeFeature.feature === property2) {
        return [node];
      }
    }
    if (isCompositeCstNode(node) && node.astNode === element) {
      return node.content.flatMap((e) => findNodesForPropertyInternal(e, property2, element, false));
    }
    return [];
  }
  function findNodesForKeyword(node, keyword) {
    if (!node) {
      return [];
    }
    return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);
  }
  function findNodeForKeyword(node, keyword, index) {
    if (!node) {
      return void 0;
    }
    const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);
    if (nodes.length === 0) {
      return void 0;
    }
    if (index !== void 0) {
      index = Math.max(0, Math.min(index, nodes.length - 1));
    } else {
      index = 0;
    }
    return nodes[index];
  }
  function findNodesForKeywordInternal(node, keyword, element) {
    if (node.astNode !== element) {
      return [];
    }
    if (isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {
      return [node];
    }
    const treeIterator = streamCst(node).iterator();
    let result;
    const keywordNodes = [];
    do {
      result = treeIterator.next();
      if (!result.done) {
        const childNode = result.value;
        if (childNode.astNode === element) {
          if (isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {
            keywordNodes.push(childNode);
          }
        } else {
          treeIterator.prune();
        }
      }
    } while (!result.done);
    return keywordNodes;
  }
  function findAssignment(cstNode) {
    var _a;
    const astNode = cstNode.astNode;
    while (astNode === ((_a = cstNode.container) === null || _a === void 0 ? void 0 : _a.astNode)) {
      const assignment = getContainerOfType(cstNode.grammarSource, isAssignment);
      if (assignment) {
        return assignment;
      }
      cstNode = cstNode.container;
    }
    return void 0;
  }
  function findNameAssignment(type) {
    let startNode = type;
    if (isInferredType(startNode)) {
      if (isAction(startNode.$container)) {
        startNode = startNode.$container.$container;
      } else if (isParserRule(startNode.$container)) {
        startNode = startNode.$container;
      } else {
        assertUnreachable(startNode.$container);
      }
    }
    return findNameAssignmentInternal(type, startNode, /* @__PURE__ */ new Map());
  }
  function findNameAssignmentInternal(type, startNode, cache) {
    var _a;
    function go(node, refType) {
      let childAssignment = void 0;
      const parentAssignment = getContainerOfType(node, isAssignment);
      if (!parentAssignment) {
        childAssignment = findNameAssignmentInternal(refType, refType, cache);
      }
      cache.set(type, childAssignment);
      return childAssignment;
    }
    if (cache.has(type)) {
      return cache.get(type);
    }
    cache.set(type, void 0);
    for (const node of streamAllContents(startNode)) {
      if (isAssignment(node) && node.feature.toLowerCase() === "name") {
        cache.set(type, node);
        return node;
      } else if (isRuleCall(node) && isParserRule(node.rule.ref)) {
        return go(node, node.rule.ref);
      } else if (isSimpleType(node) && ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) {
        return go(node, node.typeRef.ref);
      }
    }
    return void 0;
  }
  function getActionAtElement(element) {
    const parent = element.$container;
    if (isGroup(parent)) {
      const elements = parent.elements;
      const index = elements.indexOf(element);
      for (let i = index - 1; i >= 0; i--) {
        const item = elements[i];
        if (isAction(item)) {
          return item;
        } else {
          const action = streamAllContents(elements[i]).find(isAction);
          if (action) {
            return action;
          }
        }
      }
    }
    if (isAbstractElement(parent)) {
      return getActionAtElement(parent);
    } else {
      return void 0;
    }
  }
  function isOptionalCardinality(cardinality, element) {
    return cardinality === "?" || cardinality === "*" || isGroup(element) && Boolean(element.guardCondition);
  }
  function isArrayCardinality(cardinality) {
    return cardinality === "*" || cardinality === "+";
  }
  function isArrayOperator(operator) {
    return operator === "+=";
  }
  function isDataTypeRule(rule) {
    return isDataTypeRuleInternal(rule, /* @__PURE__ */ new Set());
  }
  function isDataTypeRuleInternal(rule, visited) {
    if (visited.has(rule)) {
      return true;
    } else {
      visited.add(rule);
    }
    for (const node of streamAllContents(rule)) {
      if (isRuleCall(node)) {
        if (!node.rule.ref) {
          return false;
        }
        if (isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {
          return false;
        }
      } else if (isAssignment(node)) {
        return false;
      } else if (isAction(node)) {
        return false;
      }
    }
    return Boolean(rule.definition);
  }
  function isDataType(type) {
    return isDataTypeInternal(type.type, /* @__PURE__ */ new Set());
  }
  function isDataTypeInternal(type, visited) {
    if (visited.has(type)) {
      return true;
    } else {
      visited.add(type);
    }
    if (isArrayType(type)) {
      return false;
    } else if (isReferenceType(type)) {
      return false;
    } else if (isUnionType(type)) {
      return type.types.every((e) => isDataTypeInternal(e, visited));
    } else if (isSimpleType(type)) {
      if (type.primitiveType !== void 0) {
        return true;
      } else if (type.stringType !== void 0) {
        return true;
      } else if (type.typeRef !== void 0) {
        const ref = type.typeRef.ref;
        if (isType(ref)) {
          return isDataTypeInternal(ref.type, visited);
        } else {
          return false;
        }
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
  function getExplicitRuleType(rule) {
    if (rule.inferredType) {
      return rule.inferredType.name;
    } else if (rule.dataType) {
      return rule.dataType;
    } else if (rule.returnType) {
      const refType = rule.returnType.ref;
      if (refType) {
        if (isParserRule(refType)) {
          return refType.name;
        } else if (isInterface(refType) || isType(refType)) {
          return refType.name;
        }
      }
    }
    return void 0;
  }
  function getTypeName(type) {
    var _a;
    if (isParserRule(type)) {
      return isDataTypeRule(type) ? type.name : (_a = getExplicitRuleType(type)) !== null && _a !== void 0 ? _a : type.name;
    } else if (isInterface(type) || isType(type) || isReturnType(type)) {
      return type.name;
    } else if (isAction(type)) {
      const actionType = getActionType(type);
      if (actionType) {
        return actionType;
      }
    } else if (isInferredType(type)) {
      return type.name;
    }
    throw new Error("Cannot get name of Unknown Type");
  }
  function getActionType(action) {
    var _a;
    if (action.inferredType) {
      return action.inferredType.name;
    } else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {
      return getTypeName(action.type.ref);
    }
    return void 0;
  }
  function getRuleType(rule) {
    var _a, _b, _c;
    if (isTerminalRule(rule)) {
      return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "string";
    } else {
      return isDataTypeRule(rule) ? rule.name : (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;
    }
  }
  function terminalRegex(terminalRule) {
    const flags = {
      s: false,
      i: false,
      u: false
    };
    const source = abstractElementToRegex(terminalRule.definition, flags);
    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join("");
    return new RegExp(source, flagText);
  }
  var WILDCARD = /[\s\S]/.source;
  function abstractElementToRegex(element, flags) {
    if (isTerminalAlternatives(element)) {
      return terminalAlternativesToRegex(element);
    } else if (isTerminalGroup(element)) {
      return terminalGroupToRegex(element);
    } else if (isCharacterRange(element)) {
      return characterRangeToRegex(element);
    } else if (isTerminalRuleCall(element)) {
      const rule = element.rule.ref;
      if (!rule) {
        throw new Error("Missing rule reference.");
      }
      return withCardinality(abstractElementToRegex(rule.definition), {
        cardinality: element.cardinality,
        lookahead: element.lookahead
      });
    } else if (isNegatedToken(element)) {
      return negateTokenToRegex(element);
    } else if (isUntilToken(element)) {
      return untilTokenToRegex(element);
    } else if (isRegexToken(element)) {
      const lastSlash = element.regex.lastIndexOf("/");
      const source = element.regex.substring(1, lastSlash);
      const regexFlags = element.regex.substring(lastSlash + 1);
      if (flags) {
        flags.i = regexFlags.includes("i");
        flags.s = regexFlags.includes("s");
        flags.u = regexFlags.includes("u");
      }
      return withCardinality(source, {
        cardinality: element.cardinality,
        lookahead: element.lookahead,
        wrap: false
      });
    } else if (isWildcard(element)) {
      return withCardinality(WILDCARD, {
        cardinality: element.cardinality,
        lookahead: element.lookahead
      });
    } else {
      throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);
    }
  }
  function terminalAlternativesToRegex(alternatives) {
    return withCardinality(alternatives.elements.map((e) => abstractElementToRegex(e)).join("|"), {
      cardinality: alternatives.cardinality,
      lookahead: alternatives.lookahead
    });
  }
  function terminalGroupToRegex(group) {
    return withCardinality(group.elements.map((e) => abstractElementToRegex(e)).join(""), {
      cardinality: group.cardinality,
      lookahead: group.lookahead
    });
  }
  function untilTokenToRegex(until) {
    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {
      cardinality: until.cardinality,
      lookahead: until.lookahead
    });
  }
  function negateTokenToRegex(negate2) {
    return withCardinality(`(?!${abstractElementToRegex(negate2.terminal)})${WILDCARD}*?`, {
      cardinality: negate2.cardinality,
      lookahead: negate2.lookahead
    });
  }
  function characterRangeToRegex(range) {
    if (range.right) {
      return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {
        cardinality: range.cardinality,
        lookahead: range.lookahead,
        wrap: false
      });
    }
    return withCardinality(keywordToRegex(range.left), {
      cardinality: range.cardinality,
      lookahead: range.lookahead,
      wrap: false
    });
  }
  function keywordToRegex(keyword) {
    return escapeRegExp(keyword.value);
  }
  function withCardinality(regex, options) {
    var _a;
    if (options.wrap !== false || options.lookahead) {
      regex = `(${(_a = options.lookahead) !== null && _a !== void 0 ? _a : ""}${regex})`;
    }
    if (options.cardinality) {
      return `${regex}${options.cardinality}`;
    }
    return regex;
  }

  // ../node_modules/langium/lib/languages/grammar-config.js
  function createGrammarConfig(services) {
    const rules = [];
    const grammar = services.Grammar;
    for (const rule of grammar.rules) {
      if (isTerminalRule(rule) && isCommentTerminal(rule) && isMultilineComment(terminalRegex(rule))) {
        rules.push(rule.name);
      }
    }
    return {
      multilineCommentRules: rules,
      nameRegexp: DefaultNameRegexp
    };
  }

  // ../node_modules/lodash-es/_freeGlobal.js
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeGlobal_default = freeGlobal;

  // ../node_modules/lodash-es/_root.js
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal_default || freeSelf || Function("return this")();
  var root_default = root;

  // ../node_modules/lodash-es/_Symbol.js
  var Symbol2 = root_default.Symbol;
  var Symbol_default = Symbol2;

  // ../node_modules/lodash-es/_getRawTag.js
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getRawTag_default = getRawTag;

  // ../node_modules/lodash-es/_objectToString.js
  var objectProto2 = Object.prototype;
  var nativeObjectToString2 = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString2.call(value);
  }
  var objectToString_default = objectToString;

  // ../node_modules/lodash-es/_baseGetTag.js
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
  }
  var baseGetTag_default = baseGetTag;

  // ../node_modules/lodash-es/isObjectLike.js
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var isObjectLike_default = isObjectLike;

  // ../node_modules/lodash-es/isSymbol.js
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
  }
  var isSymbol_default = isSymbol;

  // ../node_modules/lodash-es/_arrayMap.js
  function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  var arrayMap_default = arrayMap;

  // ../node_modules/lodash-es/isArray.js
  var isArray = Array.isArray;
  var isArray_default = isArray;

  // ../node_modules/lodash-es/_baseToString.js
  var INFINITY = 1 / 0;
  var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray_default(value)) {
      return arrayMap_default(value, baseToString) + "";
    }
    if (isSymbol_default(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  var baseToString_default = baseToString;

  // ../node_modules/lodash-es/_trimmedEndIndex.js
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {
    }
    return index;
  }
  var trimmedEndIndex_default = trimmedEndIndex;

  // ../node_modules/lodash-es/_baseTrim.js
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
  }
  var baseTrim_default = baseTrim;

  // ../node_modules/lodash-es/isObject.js
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var isObject_default = isObject;

  // ../node_modules/lodash-es/toNumber.js
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol_default(value)) {
      return NAN;
    }
    if (isObject_default(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject_default(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim_default(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var toNumber_default = toNumber;

  // ../node_modules/lodash-es/toFinite.js
  var INFINITY2 = 1 / 0;
  var MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber_default(value);
    if (value === INFINITY2 || value === -INFINITY2) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  var toFinite_default = toFinite;

  // ../node_modules/lodash-es/toInteger.js
  function toInteger(value) {
    var result = toFinite_default(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  var toInteger_default = toInteger;

  // ../node_modules/lodash-es/identity.js
  function identity(value) {
    return value;
  }
  var identity_default = identity;

  // ../node_modules/lodash-es/isFunction.js
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject_default(value)) {
      return false;
    }
    var tag = baseGetTag_default(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var isFunction_default = isFunction;

  // ../node_modules/lodash-es/_coreJsData.js
  var coreJsData = root_default["__core-js_shared__"];
  var coreJsData_default = coreJsData;

  // ../node_modules/lodash-es/_isMasked.js
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var isMasked_default = isMasked;

  // ../node_modules/lodash-es/_toSource.js
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var toSource_default = toSource;

  // ../node_modules/lodash-es/_baseIsNative.js
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto2 = Function.prototype;
  var objectProto3 = Object.prototype;
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto3.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject_default(value) || isMasked_default(value)) {
      return false;
    }
    var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource_default(value));
  }
  var baseIsNative_default = baseIsNative;

  // ../node_modules/lodash-es/_getValue.js
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  var getValue_default = getValue;

  // ../node_modules/lodash-es/_getNative.js
  function getNative(object, key) {
    var value = getValue_default(object, key);
    return baseIsNative_default(value) ? value : void 0;
  }
  var getNative_default = getNative;

  // ../node_modules/lodash-es/_WeakMap.js
  var WeakMap = getNative_default(root_default, "WeakMap");
  var WeakMap_default = WeakMap;

  // ../node_modules/lodash-es/_baseCreate.js
  var objectCreate = Object.create;
  var baseCreate = function() {
    function object() {
    }
    return function(proto) {
      if (!isObject_default(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  var baseCreate_default = baseCreate;

  // ../node_modules/lodash-es/_apply.js
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  var apply_default = apply;

  // ../node_modules/lodash-es/noop.js
  function noop() {
  }
  var noop_default = noop;

  // ../node_modules/lodash-es/_copyArray.js
  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  var copyArray_default = copyArray;

  // ../node_modules/lodash-es/_shortOut.js
  var HOT_COUNT = 800;
  var HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  var shortOut_default = shortOut;

  // ../node_modules/lodash-es/constant.js
  function constant(value) {
    return function() {
      return value;
    };
  }
  var constant_default = constant;

  // ../node_modules/lodash-es/_defineProperty.js
  var defineProperty = function() {
    try {
      var func = getNative_default(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  var defineProperty_default = defineProperty;

  // ../node_modules/lodash-es/_baseSetToString.js
  var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
    return defineProperty_default(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant_default(string),
      "writable": true
    });
  };
  var baseSetToString_default = baseSetToString;

  // ../node_modules/lodash-es/_setToString.js
  var setToString = shortOut_default(baseSetToString_default);
  var setToString_default = setToString;

  // ../node_modules/lodash-es/_arrayEach.js
  function arrayEach(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  var arrayEach_default = arrayEach;

  // ../node_modules/lodash-es/_baseFindIndex.js
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  var baseFindIndex_default = baseFindIndex;

  // ../node_modules/lodash-es/_baseIsNaN.js
  function baseIsNaN(value) {
    return value !== value;
  }
  var baseIsNaN_default = baseIsNaN;

  // ../node_modules/lodash-es/_strictIndexOf.js
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  var strictIndexOf_default = strictIndexOf;

  // ../node_modules/lodash-es/_baseIndexOf.js
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
  }
  var baseIndexOf_default = baseIndexOf;

  // ../node_modules/lodash-es/_arrayIncludes.js
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf_default(array, value, 0) > -1;
  }
  var arrayIncludes_default = arrayIncludes;

  // ../node_modules/lodash-es/_isIndex.js
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  var isIndex_default = isIndex;

  // ../node_modules/lodash-es/_baseAssignValue.js
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty_default) {
      defineProperty_default(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  var baseAssignValue_default = baseAssignValue;

  // ../node_modules/lodash-es/eq.js
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  var eq_default = eq;

  // ../node_modules/lodash-es/_assignValue.js
  var objectProto4 = Object.prototype;
  var hasOwnProperty3 = objectProto4.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue_default(object, key, value);
    }
  }
  var assignValue_default = assignValue;

  // ../node_modules/lodash-es/_copyObject.js
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue_default(object, key, newValue);
      } else {
        assignValue_default(object, key, newValue);
      }
    }
    return object;
  }
  var copyObject_default = copyObject;

  // ../node_modules/lodash-es/_overRest.js
  var nativeMax = Math.max;
  function overRest(func, start, transform) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply_default(func, this, otherArgs);
    };
  }
  var overRest_default = overRest;

  // ../node_modules/lodash-es/_baseRest.js
  function baseRest(func, start) {
    return setToString_default(overRest_default(func, start, identity_default), func + "");
  }
  var baseRest_default = baseRest;

  // ../node_modules/lodash-es/isLength.js
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  var isLength_default = isLength;

  // ../node_modules/lodash-es/isArrayLike.js
  function isArrayLike(value) {
    return value != null && isLength_default(value.length) && !isFunction_default(value);
  }
  var isArrayLike_default = isArrayLike;

  // ../node_modules/lodash-es/_isIterateeCall.js
  function isIterateeCall(value, index, object) {
    if (!isObject_default(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == "string" && index in object) {
      return eq_default(object[index], value);
    }
    return false;
  }
  var isIterateeCall_default = isIterateeCall;

  // ../node_modules/lodash-es/_createAssigner.js
  function createAssigner(assigner) {
    return baseRest_default(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  var createAssigner_default = createAssigner;

  // ../node_modules/lodash-es/_isPrototype.js
  var objectProto5 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
    return value === proto;
  }
  var isPrototype_default = isPrototype;

  // ../node_modules/lodash-es/_baseTimes.js
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  var baseTimes_default = baseTimes;

  // ../node_modules/lodash-es/_baseIsArguments.js
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
  }
  var baseIsArguments_default = baseIsArguments;

  // ../node_modules/lodash-es/isArguments.js
  var objectProto6 = Object.prototype;
  var hasOwnProperty4 = objectProto6.hasOwnProperty;
  var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
  var isArguments = baseIsArguments_default(function() {
    return arguments;
  }()) ? baseIsArguments_default : function(value) {
    return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArguments_default = isArguments;

  // ../node_modules/lodash-es/stubFalse.js
  function stubFalse() {
    return false;
  }
  var stubFalse_default = stubFalse;

  // ../node_modules/lodash-es/isBuffer.js
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root_default.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse_default;
  var isBuffer_default = isBuffer;

  // ../node_modules/lodash-es/_baseIsTypedArray.js
  var argsTag2 = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag2 = "[object Function]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
  }
  var baseIsTypedArray_default = baseIsTypedArray;

  // ../node_modules/lodash-es/_baseUnary.js
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  var baseUnary_default = baseUnary;

  // ../node_modules/lodash-es/_nodeUtil.js
  var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess = moduleExports2 && freeGlobal_default.process;
  var nodeUtil = function() {
    try {
      var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeUtil_default = nodeUtil;

  // ../node_modules/lodash-es/isTypedArray.js
  var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
  var isTypedArray_default = isTypedArray;

  // ../node_modules/lodash-es/_arrayLikeKeys.js
  var objectProto7 = Object.prototype;
  var hasOwnProperty5 = objectProto7.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType3 = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType3, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType3 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex_default(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  var arrayLikeKeys_default = arrayLikeKeys;

  // ../node_modules/lodash-es/_overArg.js
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var overArg_default = overArg;

  // ../node_modules/lodash-es/_nativeKeys.js
  var nativeKeys = overArg_default(Object.keys, Object);
  var nativeKeys_default = nativeKeys;

  // ../node_modules/lodash-es/_baseKeys.js
  var objectProto8 = Object.prototype;
  var hasOwnProperty6 = objectProto8.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype_default(object)) {
      return nativeKeys_default(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty6.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  var baseKeys_default = baseKeys;

  // ../node_modules/lodash-es/keys.js
  function keys(object) {
    return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
  }
  var keys_default = keys;

  // ../node_modules/lodash-es/assign.js
  var objectProto9 = Object.prototype;
  var hasOwnProperty7 = objectProto9.hasOwnProperty;
  var assign = createAssigner_default(function(object, source) {
    if (isPrototype_default(source) || isArrayLike_default(source)) {
      copyObject_default(source, keys_default(source), object);
      return;
    }
    for (var key in source) {
      if (hasOwnProperty7.call(source, key)) {
        assignValue_default(object, key, source[key]);
      }
    }
  });
  var assign_default = assign;

  // ../node_modules/lodash-es/_nativeKeysIn.js
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  var nativeKeysIn_default = nativeKeysIn;

  // ../node_modules/lodash-es/_baseKeysIn.js
  var objectProto10 = Object.prototype;
  var hasOwnProperty8 = objectProto10.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject_default(object)) {
      return nativeKeysIn_default(object);
    }
    var isProto = isPrototype_default(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty8.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  var baseKeysIn_default = baseKeysIn;

  // ../node_modules/lodash-es/keysIn.js
  function keysIn(object) {
    return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
  }
  var keysIn_default = keysIn;

  // ../node_modules/lodash-es/_isKey.js
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray_default(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  var isKey_default = isKey;

  // ../node_modules/lodash-es/_nativeCreate.js
  var nativeCreate = getNative_default(Object, "create");
  var nativeCreate_default = nativeCreate;

  // ../node_modules/lodash-es/_hashClear.js
  function hashClear() {
    this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
    this.size = 0;
  }
  var hashClear_default = hashClear;

  // ../node_modules/lodash-es/_hashDelete.js
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var hashDelete_default = hashDelete;

  // ../node_modules/lodash-es/_hashGet.js
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto11 = Object.prototype;
  var hasOwnProperty9 = objectProto11.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate_default) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty9.call(data, key) ? data[key] : void 0;
  }
  var hashGet_default = hashGet;

  // ../node_modules/lodash-es/_hashHas.js
  var objectProto12 = Object.prototype;
  var hasOwnProperty10 = objectProto12.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty10.call(data, key);
  }
  var hashHas_default = hashHas;

  // ../node_modules/lodash-es/_hashSet.js
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  var hashSet_default = hashSet;

  // ../node_modules/lodash-es/_Hash.js
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear_default;
  Hash.prototype["delete"] = hashDelete_default;
  Hash.prototype.get = hashGet_default;
  Hash.prototype.has = hashHas_default;
  Hash.prototype.set = hashSet_default;
  var Hash_default = Hash;

  // ../node_modules/lodash-es/_listCacheClear.js
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  var listCacheClear_default = listCacheClear;

  // ../node_modules/lodash-es/_assocIndexOf.js
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq_default(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var assocIndexOf_default = assocIndexOf;

  // ../node_modules/lodash-es/_listCacheDelete.js
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  var listCacheDelete_default = listCacheDelete;

  // ../node_modules/lodash-es/_listCacheGet.js
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  var listCacheGet_default = listCacheGet;

  // ../node_modules/lodash-es/_listCacheHas.js
  function listCacheHas(key) {
    return assocIndexOf_default(this.__data__, key) > -1;
  }
  var listCacheHas_default = listCacheHas;

  // ../node_modules/lodash-es/_listCacheSet.js
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  var listCacheSet_default = listCacheSet;

  // ../node_modules/lodash-es/_ListCache.js
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear_default;
  ListCache.prototype["delete"] = listCacheDelete_default;
  ListCache.prototype.get = listCacheGet_default;
  ListCache.prototype.has = listCacheHas_default;
  ListCache.prototype.set = listCacheSet_default;
  var ListCache_default = ListCache;

  // ../node_modules/lodash-es/_Map.js
  var Map2 = getNative_default(root_default, "Map");
  var Map_default = Map2;

  // ../node_modules/lodash-es/_mapCacheClear.js
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash_default(),
      "map": new (Map_default || ListCache_default)(),
      "string": new Hash_default()
    };
  }
  var mapCacheClear_default = mapCacheClear;

  // ../node_modules/lodash-es/_isKeyable.js
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  var isKeyable_default = isKeyable;

  // ../node_modules/lodash-es/_getMapData.js
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  var getMapData_default = getMapData;

  // ../node_modules/lodash-es/_mapCacheDelete.js
  function mapCacheDelete(key) {
    var result = getMapData_default(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var mapCacheDelete_default = mapCacheDelete;

  // ../node_modules/lodash-es/_mapCacheGet.js
  function mapCacheGet(key) {
    return getMapData_default(this, key).get(key);
  }
  var mapCacheGet_default = mapCacheGet;

  // ../node_modules/lodash-es/_mapCacheHas.js
  function mapCacheHas(key) {
    return getMapData_default(this, key).has(key);
  }
  var mapCacheHas_default = mapCacheHas;

  // ../node_modules/lodash-es/_mapCacheSet.js
  function mapCacheSet(key, value) {
    var data = getMapData_default(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  var mapCacheSet_default = mapCacheSet;

  // ../node_modules/lodash-es/_MapCache.js
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear_default;
  MapCache.prototype["delete"] = mapCacheDelete_default;
  MapCache.prototype.get = mapCacheGet_default;
  MapCache.prototype.has = mapCacheHas_default;
  MapCache.prototype.set = mapCacheSet_default;
  var MapCache_default = MapCache;

  // ../node_modules/lodash-es/memoize.js
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache_default)();
    return memoized;
  }
  memoize.Cache = MapCache_default;
  var memoize_default = memoize;

  // ../node_modules/lodash-es/_memoizeCapped.js
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize_default(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  var memoizeCapped_default = memoizeCapped;

  // ../node_modules/lodash-es/_stringToPath.js
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped_default(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  var stringToPath_default = stringToPath;

  // ../node_modules/lodash-es/toString.js
  function toString2(value) {
    return value == null ? "" : baseToString_default(value);
  }
  var toString_default = toString2;

  // ../node_modules/lodash-es/_castPath.js
  function castPath(value, object) {
    if (isArray_default(value)) {
      return value;
    }
    return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
  }
  var castPath_default = castPath;

  // ../node_modules/lodash-es/_toKey.js
  var INFINITY3 = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol_default(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
  }
  var toKey_default = toKey;

  // ../node_modules/lodash-es/_baseGet.js
  function baseGet(object, path) {
    path = castPath_default(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey_default(path[index++])];
    }
    return index && index == length ? object : void 0;
  }
  var baseGet_default = baseGet;

  // ../node_modules/lodash-es/get.js
  function get(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet_default(object, path);
    return result === void 0 ? defaultValue : result;
  }
  var get_default = get;

  // ../node_modules/lodash-es/_arrayPush.js
  function arrayPush(array, values2) {
    var index = -1, length = values2.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values2[index];
    }
    return array;
  }
  var arrayPush_default = arrayPush;

  // ../node_modules/lodash-es/_isFlattenable.js
  var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  var isFlattenable_default = isFlattenable;

  // ../node_modules/lodash-es/_baseFlatten.js
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable_default);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush_default(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  var baseFlatten_default = baseFlatten;

  // ../node_modules/lodash-es/flatten.js
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten_default(array, 1) : [];
  }
  var flatten_default = flatten;

  // ../node_modules/lodash-es/_getPrototype.js
  var getPrototype = overArg_default(Object.getPrototypeOf, Object);
  var getPrototype_default = getPrototype;

  // ../node_modules/lodash-es/_baseSlice.js
  function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  var baseSlice_default = baseSlice;

  // ../node_modules/lodash-es/_arrayReduce.js
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  var arrayReduce_default = arrayReduce;

  // ../node_modules/lodash-es/_stackClear.js
  function stackClear() {
    this.__data__ = new ListCache_default();
    this.size = 0;
  }
  var stackClear_default = stackClear;

  // ../node_modules/lodash-es/_stackDelete.js
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  var stackDelete_default = stackDelete;

  // ../node_modules/lodash-es/_stackGet.js
  function stackGet(key) {
    return this.__data__.get(key);
  }
  var stackGet_default = stackGet;

  // ../node_modules/lodash-es/_stackHas.js
  function stackHas(key) {
    return this.__data__.has(key);
  }
  var stackHas_default = stackHas;

  // ../node_modules/lodash-es/_stackSet.js
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache_default) {
      var pairs = data.__data__;
      if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache_default(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  var stackSet_default = stackSet;

  // ../node_modules/lodash-es/_Stack.js
  function Stack(entries) {
    var data = this.__data__ = new ListCache_default(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear_default;
  Stack.prototype["delete"] = stackDelete_default;
  Stack.prototype.get = stackGet_default;
  Stack.prototype.has = stackHas_default;
  Stack.prototype.set = stackSet_default;
  var Stack_default = Stack;

  // ../node_modules/lodash-es/_baseAssign.js
  function baseAssign(object, source) {
    return object && copyObject_default(source, keys_default(source), object);
  }
  var baseAssign_default = baseAssign;

  // ../node_modules/lodash-es/_baseAssignIn.js
  function baseAssignIn(object, source) {
    return object && copyObject_default(source, keysIn_default(source), object);
  }
  var baseAssignIn_default = baseAssignIn;

  // ../node_modules/lodash-es/_cloneBuffer.js
  var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
  var Buffer3 = moduleExports3 ? root_default.Buffer : void 0;
  var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  var cloneBuffer_default = cloneBuffer;

  // ../node_modules/lodash-es/_arrayFilter.js
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  var arrayFilter_default = arrayFilter;

  // ../node_modules/lodash-es/stubArray.js
  function stubArray() {
    return [];
  }
  var stubArray_default = stubArray;

  // ../node_modules/lodash-es/_getSymbols.js
  var objectProto13 = Object.prototype;
  var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable2.call(object, symbol);
    });
  };
  var getSymbols_default = getSymbols;

  // ../node_modules/lodash-es/_copySymbols.js
  function copySymbols(source, object) {
    return copyObject_default(source, getSymbols_default(source), object);
  }
  var copySymbols_default = copySymbols;

  // ../node_modules/lodash-es/_getSymbolsIn.js
  var nativeGetSymbols2 = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
    var result = [];
    while (object) {
      arrayPush_default(result, getSymbols_default(object));
      object = getPrototype_default(object);
    }
    return result;
  };
  var getSymbolsIn_default = getSymbolsIn;

  // ../node_modules/lodash-es/_copySymbolsIn.js
  function copySymbolsIn(source, object) {
    return copyObject_default(source, getSymbolsIn_default(source), object);
  }
  var copySymbolsIn_default = copySymbolsIn;

  // ../node_modules/lodash-es/_baseGetAllKeys.js
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
  }
  var baseGetAllKeys_default = baseGetAllKeys;

  // ../node_modules/lodash-es/_getAllKeys.js
  function getAllKeys(object) {
    return baseGetAllKeys_default(object, keys_default, getSymbols_default);
  }
  var getAllKeys_default = getAllKeys;

  // ../node_modules/lodash-es/_getAllKeysIn.js
  function getAllKeysIn(object) {
    return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
  }
  var getAllKeysIn_default = getAllKeysIn;

  // ../node_modules/lodash-es/_DataView.js
  var DataView = getNative_default(root_default, "DataView");
  var DataView_default = DataView;

  // ../node_modules/lodash-es/_Promise.js
  var Promise2 = getNative_default(root_default, "Promise");
  var Promise_default = Promise2;

  // ../node_modules/lodash-es/_Set.js
  var Set2 = getNative_default(root_default, "Set");
  var Set_default = Set2;

  // ../node_modules/lodash-es/_getTag.js
  var mapTag2 = "[object Map]";
  var objectTag2 = "[object Object]";
  var promiseTag = "[object Promise]";
  var setTag2 = "[object Set]";
  var weakMapTag2 = "[object WeakMap]";
  var dataViewTag2 = "[object DataView]";
  var dataViewCtorString = toSource_default(DataView_default);
  var mapCtorString = toSource_default(Map_default);
  var promiseCtorString = toSource_default(Promise_default);
  var setCtorString = toSource_default(Set_default);
  var weakMapCtorString = toSource_default(WeakMap_default);
  var getTag = baseGetTag_default;
  if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
    getTag = function(value) {
      var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag2;
          case mapCtorString:
            return mapTag2;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag2;
          case weakMapCtorString:
            return weakMapTag2;
        }
      }
      return result;
    };
  }
  var getTag_default = getTag;

  // ../node_modules/lodash-es/_initCloneArray.js
  var objectProto14 = Object.prototype;
  var hasOwnProperty11 = objectProto14.hasOwnProperty;
  function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty11.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  var initCloneArray_default = initCloneArray;

  // ../node_modules/lodash-es/_Uint8Array.js
  var Uint8Array2 = root_default.Uint8Array;
  var Uint8Array_default = Uint8Array2;

  // ../node_modules/lodash-es/_cloneArrayBuffer.js
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
    return result;
  }
  var cloneArrayBuffer_default = cloneArrayBuffer;

  // ../node_modules/lodash-es/_cloneDataView.js
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  var cloneDataView_default = cloneDataView;

  // ../node_modules/lodash-es/_cloneRegExp.js
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  var cloneRegExp_default = cloneRegExp;

  // ../node_modules/lodash-es/_cloneSymbol.js
  var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  var cloneSymbol_default = cloneSymbol;

  // ../node_modules/lodash-es/_cloneTypedArray.js
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  var cloneTypedArray_default = cloneTypedArray;

  // ../node_modules/lodash-es/_initCloneByTag.js
  var boolTag2 = "[object Boolean]";
  var dateTag2 = "[object Date]";
  var mapTag3 = "[object Map]";
  var numberTag2 = "[object Number]";
  var regexpTag2 = "[object RegExp]";
  var setTag3 = "[object Set]";
  var stringTag2 = "[object String]";
  var symbolTag2 = "[object Symbol]";
  var arrayBufferTag2 = "[object ArrayBuffer]";
  var dataViewTag3 = "[object DataView]";
  var float32Tag2 = "[object Float32Array]";
  var float64Tag2 = "[object Float64Array]";
  var int8Tag2 = "[object Int8Array]";
  var int16Tag2 = "[object Int16Array]";
  var int32Tag2 = "[object Int32Array]";
  var uint8Tag2 = "[object Uint8Array]";
  var uint8ClampedTag2 = "[object Uint8ClampedArray]";
  var uint16Tag2 = "[object Uint16Array]";
  var uint32Tag2 = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag2:
        return cloneArrayBuffer_default(object);
      case boolTag2:
      case dateTag2:
        return new Ctor(+object);
      case dataViewTag3:
        return cloneDataView_default(object, isDeep);
      case float32Tag2:
      case float64Tag2:
      case int8Tag2:
      case int16Tag2:
      case int32Tag2:
      case uint8Tag2:
      case uint8ClampedTag2:
      case uint16Tag2:
      case uint32Tag2:
        return cloneTypedArray_default(object, isDeep);
      case mapTag3:
        return new Ctor();
      case numberTag2:
      case stringTag2:
        return new Ctor(object);
      case regexpTag2:
        return cloneRegExp_default(object);
      case setTag3:
        return new Ctor();
      case symbolTag2:
        return cloneSymbol_default(object);
    }
  }
  var initCloneByTag_default = initCloneByTag;

  // ../node_modules/lodash-es/_initCloneObject.js
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
  }
  var initCloneObject_default = initCloneObject;

  // ../node_modules/lodash-es/_baseIsMap.js
  var mapTag4 = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike_default(value) && getTag_default(value) == mapTag4;
  }
  var baseIsMap_default = baseIsMap;

  // ../node_modules/lodash-es/isMap.js
  var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
  var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
  var isMap_default = isMap;

  // ../node_modules/lodash-es/_baseIsSet.js
  var setTag4 = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike_default(value) && getTag_default(value) == setTag4;
  }
  var baseIsSet_default = baseIsSet;

  // ../node_modules/lodash-es/isSet.js
  var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
  var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
  var isSet_default = isSet;

  // ../node_modules/lodash-es/_baseClone.js
  var CLONE_DEEP_FLAG = 1;
  var CLONE_FLAT_FLAG = 2;
  var CLONE_SYMBOLS_FLAG = 4;
  var argsTag3 = "[object Arguments]";
  var arrayTag2 = "[object Array]";
  var boolTag3 = "[object Boolean]";
  var dateTag3 = "[object Date]";
  var errorTag2 = "[object Error]";
  var funcTag3 = "[object Function]";
  var genTag2 = "[object GeneratorFunction]";
  var mapTag5 = "[object Map]";
  var numberTag3 = "[object Number]";
  var objectTag3 = "[object Object]";
  var regexpTag3 = "[object RegExp]";
  var setTag5 = "[object Set]";
  var stringTag3 = "[object String]";
  var symbolTag3 = "[object Symbol]";
  var weakMapTag3 = "[object WeakMap]";
  var arrayBufferTag3 = "[object ArrayBuffer]";
  var dataViewTag4 = "[object DataView]";
  var float32Tag3 = "[object Float32Array]";
  var float64Tag3 = "[object Float64Array]";
  var int8Tag3 = "[object Int8Array]";
  var int16Tag3 = "[object Int16Array]";
  var int32Tag3 = "[object Int32Array]";
  var uint8Tag3 = "[object Uint8Array]";
  var uint8ClampedTag3 = "[object Uint8ClampedArray]";
  var uint16Tag3 = "[object Uint16Array]";
  var uint32Tag3 = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag3] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
  cloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject_default(value)) {
      return value;
    }
    var isArr = isArray_default(value);
    if (isArr) {
      result = initCloneArray_default(value);
      if (!isDeep) {
        return copyArray_default(value, result);
      }
    } else {
      var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
      if (isBuffer_default(value)) {
        return cloneBuffer_default(value, isDeep);
      }
      if (tag == objectTag3 || tag == argsTag3 || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject_default(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag_default(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack_default());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (isSet_default(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap_default(value)) {
      value.forEach(function(subValue, key2) {
        result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach_default(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
    return result;
  }
  var baseClone_default = baseClone;

  // ../node_modules/lodash-es/clone.js
  var CLONE_SYMBOLS_FLAG2 = 4;
  function clone(value) {
    return baseClone_default(value, CLONE_SYMBOLS_FLAG2);
  }
  var clone_default = clone;

  // ../node_modules/lodash-es/compact.js
  function compact(array) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (value) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  var compact_default = compact;

  // ../node_modules/lodash-es/_setCacheAdd.js
  var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED3);
    return this;
  }
  var setCacheAdd_default = setCacheAdd;

  // ../node_modules/lodash-es/_setCacheHas.js
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  var setCacheHas_default = setCacheHas;

  // ../node_modules/lodash-es/_SetCache.js
  function SetCache(values2) {
    var index = -1, length = values2 == null ? 0 : values2.length;
    this.__data__ = new MapCache_default();
    while (++index < length) {
      this.add(values2[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
  SetCache.prototype.has = setCacheHas_default;
  var SetCache_default = SetCache;

  // ../node_modules/lodash-es/_arraySome.js
  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  var arraySome_default = arraySome;

  // ../node_modules/lodash-es/_cacheHas.js
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  var cacheHas_default = cacheHas;

  // ../node_modules/lodash-es/_equalArrays.js
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome_default(other, function(othValue2, othIndex) {
          if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  var equalArrays_default = equalArrays;

  // ../node_modules/lodash-es/_mapToArray.js
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  var mapToArray_default = mapToArray;

  // ../node_modules/lodash-es/_setToArray.js
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var setToArray_default = setToArray;

  // ../node_modules/lodash-es/_equalByTag.js
  var COMPARE_PARTIAL_FLAG2 = 1;
  var COMPARE_UNORDERED_FLAG2 = 2;
  var boolTag4 = "[object Boolean]";
  var dateTag4 = "[object Date]";
  var errorTag3 = "[object Error]";
  var mapTag6 = "[object Map]";
  var numberTag4 = "[object Number]";
  var regexpTag4 = "[object RegExp]";
  var setTag6 = "[object Set]";
  var stringTag4 = "[object String]";
  var symbolTag4 = "[object Symbol]";
  var arrayBufferTag4 = "[object ArrayBuffer]";
  var dataViewTag5 = "[object DataView]";
  var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag5:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag4:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
          return false;
        }
        return true;
      case boolTag4:
      case dateTag4:
      case numberTag4:
        return eq_default(+object, +other);
      case errorTag3:
        return object.name == other.name && object.message == other.message;
      case regexpTag4:
      case stringTag4:
        return object == other + "";
      case mapTag6:
        var convert = mapToArray_default;
      case setTag6:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
        convert || (convert = setToArray_default);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG2;
        stack.set(object, other);
        var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag4:
        if (symbolValueOf2) {
          return symbolValueOf2.call(object) == symbolValueOf2.call(other);
        }
    }
    return false;
  }
  var equalByTag_default = equalByTag;

  // ../node_modules/lodash-es/_equalObjects.js
  var COMPARE_PARTIAL_FLAG3 = 1;
  var objectProto15 = Object.prototype;
  var hasOwnProperty12 = objectProto15.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty12.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  var equalObjects_default = equalObjects;

  // ../node_modules/lodash-es/_baseIsEqualDeep.js
  var COMPARE_PARTIAL_FLAG4 = 1;
  var argsTag4 = "[object Arguments]";
  var arrayTag3 = "[object Array]";
  var objectTag4 = "[object Object]";
  var objectProto16 = Object.prototype;
  var hasOwnProperty13 = objectProto16.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
    objTag = objTag == argsTag4 ? objectTag4 : objTag;
    othTag = othTag == argsTag4 ? objectTag4 : othTag;
    var objIsObj = objTag == objectTag4, othIsObj = othTag == objectTag4, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer_default(object)) {
      if (!isBuffer_default(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack_default());
      return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
      var objIsWrapped = objIsObj && hasOwnProperty13.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty13.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack_default());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack_default());
    return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
  }
  var baseIsEqualDeep_default = baseIsEqualDeep;

  // ../node_modules/lodash-es/_baseIsEqual.js
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  var baseIsEqual_default = baseIsEqual;

  // ../node_modules/lodash-es/_baseIsMatch.js
  var COMPARE_PARTIAL_FLAG5 = 1;
  var COMPARE_UNORDERED_FLAG3 = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0], objValue = object[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack_default();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  var baseIsMatch_default = baseIsMatch;

  // ../node_modules/lodash-es/_isStrictComparable.js
  function isStrictComparable(value) {
    return value === value && !isObject_default(value);
  }
  var isStrictComparable_default = isStrictComparable;

  // ../node_modules/lodash-es/_getMatchData.js
  function getMatchData(object) {
    var result = keys_default(object), length = result.length;
    while (length--) {
      var key = result[length], value = object[key];
      result[length] = [key, value, isStrictComparable_default(value)];
    }
    return result;
  }
  var getMatchData_default = getMatchData;

  // ../node_modules/lodash-es/_matchesStrictComparable.js
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
    };
  }
  var matchesStrictComparable_default = matchesStrictComparable;

  // ../node_modules/lodash-es/_baseMatches.js
  function baseMatches(source) {
    var matchData = getMatchData_default(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch_default(object, source, matchData);
    };
  }
  var baseMatches_default = baseMatches;

  // ../node_modules/lodash-es/_baseHasIn.js
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  var baseHasIn_default = baseHasIn;

  // ../node_modules/lodash-es/_hasPath.js
  function hasPath(object, path, hasFunc) {
    path = castPath_default(path, object);
    var index = -1, length = path.length, result = false;
    while (++index < length) {
      var key = toKey_default(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
  }
  var hasPath_default = hasPath;

  // ../node_modules/lodash-es/hasIn.js
  function hasIn(object, path) {
    return object != null && hasPath_default(object, path, baseHasIn_default);
  }
  var hasIn_default = hasIn;

  // ../node_modules/lodash-es/_baseMatchesProperty.js
  var COMPARE_PARTIAL_FLAG6 = 1;
  var COMPARE_UNORDERED_FLAG4 = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey_default(path) && isStrictComparable_default(srcValue)) {
      return matchesStrictComparable_default(toKey_default(path), srcValue);
    }
    return function(object) {
      var objValue = get_default(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
    };
  }
  var baseMatchesProperty_default = baseMatchesProperty;

  // ../node_modules/lodash-es/_baseProperty.js
  function baseProperty(key) {
    return function(object) {
      return object == null ? void 0 : object[key];
    };
  }
  var baseProperty_default = baseProperty;

  // ../node_modules/lodash-es/_basePropertyDeep.js
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet_default(object, path);
    };
  }
  var basePropertyDeep_default = basePropertyDeep;

  // ../node_modules/lodash-es/property.js
  function property(path) {
    return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
  }
  var property_default = property;

  // ../node_modules/lodash-es/_baseIteratee.js
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity_default;
    }
    if (typeof value == "object") {
      return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
    }
    return property_default(value);
  }
  var baseIteratee_default = baseIteratee;

  // ../node_modules/lodash-es/_arrayAggregator.js
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }
  var arrayAggregator_default = arrayAggregator;

  // ../node_modules/lodash-es/_createBaseFor.js
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  var createBaseFor_default = createBaseFor;

  // ../node_modules/lodash-es/_baseFor.js
  var baseFor = createBaseFor_default();
  var baseFor_default = baseFor;

  // ../node_modules/lodash-es/_baseForOwn.js
  function baseForOwn(object, iteratee) {
    return object && baseFor_default(object, iteratee, keys_default);
  }
  var baseForOwn_default = baseForOwn;

  // ../node_modules/lodash-es/_createBaseEach.js
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike_default(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  var createBaseEach_default = createBaseEach;

  // ../node_modules/lodash-es/_baseEach.js
  var baseEach = createBaseEach_default(baseForOwn_default);
  var baseEach_default = baseEach;

  // ../node_modules/lodash-es/_baseAggregator.js
  function baseAggregator(collection, setter, iteratee, accumulator) {
    baseEach_default(collection, function(value, key, collection2) {
      setter(accumulator, value, iteratee(value), collection2);
    });
    return accumulator;
  }
  var baseAggregator_default = baseAggregator;

  // ../node_modules/lodash-es/_createAggregator.js
  function createAggregator(setter, initializer) {
    return function(collection, iteratee) {
      var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
      return func(collection, setter, baseIteratee_default(iteratee, 2), accumulator);
    };
  }
  var createAggregator_default = createAggregator;

  // ../node_modules/lodash-es/defaults.js
  var objectProto17 = Object.prototype;
  var hasOwnProperty14 = objectProto17.hasOwnProperty;
  var defaults = baseRest_default(function(object, sources) {
    object = Object(object);
    var index = -1;
    var length = sources.length;
    var guard = length > 2 ? sources[2] : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      var props = keysIn_default(source);
      var propsIndex = -1;
      var propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object[key];
        if (value === void 0 || eq_default(value, objectProto17[key]) && !hasOwnProperty14.call(object, key)) {
          object[key] = source[key];
        }
      }
    }
    return object;
  });
  var defaults_default = defaults;

  // ../node_modules/lodash-es/isArrayLikeObject.js
  function isArrayLikeObject(value) {
    return isObjectLike_default(value) && isArrayLike_default(value);
  }
  var isArrayLikeObject_default = isArrayLikeObject;

  // ../node_modules/lodash-es/_arrayIncludesWith.js
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  var arrayIncludesWith_default = arrayIncludesWith;

  // ../node_modules/lodash-es/_baseDifference.js
  var LARGE_ARRAY_SIZE2 = 200;
  function baseDifference(array, values2, iteratee, comparator) {
    var index = -1, includes2 = arrayIncludes_default, isCommon = true, length = array.length, result = [], valuesLength = values2.length;
    if (!length) {
      return result;
    }
    if (iteratee) {
      values2 = arrayMap_default(values2, baseUnary_default(iteratee));
    }
    if (comparator) {
      includes2 = arrayIncludesWith_default;
      isCommon = false;
    } else if (values2.length >= LARGE_ARRAY_SIZE2) {
      includes2 = cacheHas_default;
      isCommon = false;
      values2 = new SetCache_default(values2);
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee == null ? value : iteratee(value);
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values2[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes2(values2, computed, comparator)) {
          result.push(value);
        }
      }
    return result;
  }
  var baseDifference_default = baseDifference;

  // ../node_modules/lodash-es/difference.js
  var difference = baseRest_default(function(array, values2) {
    return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true)) : [];
  });
  var difference_default = difference;

  // ../node_modules/lodash-es/last.js
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : void 0;
  }
  var last_default = last;

  // ../node_modules/lodash-es/drop.js
  function drop(array, n, guard) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    n = guard || n === void 0 ? 1 : toInteger_default(n);
    return baseSlice_default(array, n < 0 ? 0 : n, length);
  }
  var drop_default = drop;

  // ../node_modules/lodash-es/dropRight.js
  function dropRight(array, n, guard) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    n = guard || n === void 0 ? 1 : toInteger_default(n);
    n = length - n;
    return baseSlice_default(array, 0, n < 0 ? 0 : n);
  }
  var dropRight_default = dropRight;

  // ../node_modules/lodash-es/_castFunction.js
  function castFunction(value) {
    return typeof value == "function" ? value : identity_default;
  }
  var castFunction_default = castFunction;

  // ../node_modules/lodash-es/forEach.js
  function forEach(collection, iteratee) {
    var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
    return func(collection, castFunction_default(iteratee));
  }
  var forEach_default = forEach;

  // ../node_modules/lodash-es/_arrayEvery.js
  function arrayEvery(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }
  var arrayEvery_default = arrayEvery;

  // ../node_modules/lodash-es/_baseEvery.js
  function baseEvery(collection, predicate) {
    var result = true;
    baseEach_default(collection, function(value, index, collection2) {
      result = !!predicate(value, index, collection2);
      return result;
    });
    return result;
  }
  var baseEvery_default = baseEvery;

  // ../node_modules/lodash-es/every.js
  function every(collection, predicate, guard) {
    var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;
    if (guard && isIterateeCall_default(collection, predicate, guard)) {
      predicate = void 0;
    }
    return func(collection, baseIteratee_default(predicate, 3));
  }
  var every_default = every;

  // ../node_modules/lodash-es/_baseFilter.js
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach_default(collection, function(value, index, collection2) {
      if (predicate(value, index, collection2)) {
        result.push(value);
      }
    });
    return result;
  }
  var baseFilter_default = baseFilter;

  // ../node_modules/lodash-es/filter.js
  function filter(collection, predicate) {
    var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
    return func(collection, baseIteratee_default(predicate, 3));
  }
  var filter_default = filter;

  // ../node_modules/lodash-es/_createFind.js
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike_default(collection)) {
        var iteratee = baseIteratee_default(predicate, 3);
        collection = keys_default(collection);
        predicate = function(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }
      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
    };
  }
  var createFind_default = createFind;

  // ../node_modules/lodash-es/findIndex.js
  var nativeMax2 = Math.max;
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
    if (index < 0) {
      index = nativeMax2(length + index, 0);
    }
    return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index);
  }
  var findIndex_default = findIndex;

  // ../node_modules/lodash-es/find.js
  var find = createFind_default(findIndex_default);
  var find_default = find;

  // ../node_modules/lodash-es/head.js
  function head(array) {
    return array && array.length ? array[0] : void 0;
  }
  var head_default = head;

  // ../node_modules/lodash-es/_baseMap.js
  function baseMap(collection, iteratee) {
    var index = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
    baseEach_default(collection, function(value, key, collection2) {
      result[++index] = iteratee(value, key, collection2);
    });
    return result;
  }
  var baseMap_default = baseMap;

  // ../node_modules/lodash-es/map.js
  function map(collection, iteratee) {
    var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
    return func(collection, baseIteratee_default(iteratee, 3));
  }
  var map_default = map;

  // ../node_modules/lodash-es/flatMap.js
  function flatMap(collection, iteratee) {
    return baseFlatten_default(map_default(collection, iteratee), 1);
  }
  var flatMap_default = flatMap;

  // ../node_modules/lodash-es/groupBy.js
  var objectProto18 = Object.prototype;
  var hasOwnProperty15 = objectProto18.hasOwnProperty;
  var groupBy = createAggregator_default(function(result, value, key) {
    if (hasOwnProperty15.call(result, key)) {
      result[key].push(value);
    } else {
      baseAssignValue_default(result, key, [value]);
    }
  });
  var groupBy_default = groupBy;

  // ../node_modules/lodash-es/_baseHas.js
  var objectProto19 = Object.prototype;
  var hasOwnProperty16 = objectProto19.hasOwnProperty;
  function baseHas(object, key) {
    return object != null && hasOwnProperty16.call(object, key);
  }
  var baseHas_default = baseHas;

  // ../node_modules/lodash-es/has.js
  function has(object, path) {
    return object != null && hasPath_default(object, path, baseHas_default);
  }
  var has_default = has;

  // ../node_modules/lodash-es/isString.js
  var stringTag5 = "[object String]";
  function isString(value) {
    return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag5;
  }
  var isString_default = isString;

  // ../node_modules/lodash-es/_baseValues.js
  function baseValues(object, props) {
    return arrayMap_default(props, function(key) {
      return object[key];
    });
  }
  var baseValues_default = baseValues;

  // ../node_modules/lodash-es/values.js
  function values(object) {
    return object == null ? [] : baseValues_default(object, keys_default(object));
  }
  var values_default = values;

  // ../node_modules/lodash-es/includes.js
  var nativeMax3 = Math.max;
  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike_default(collection) ? collection : values_default(collection);
    fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax3(length + fromIndex, 0);
    }
    return isString_default(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf_default(collection, value, fromIndex) > -1;
  }
  var includes_default = includes;

  // ../node_modules/lodash-es/indexOf.js
  var nativeMax4 = Math.max;
  function indexOf(array, value, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
    if (index < 0) {
      index = nativeMax4(length + index, 0);
    }
    return baseIndexOf_default(array, value, index);
  }
  var indexOf_default = indexOf;

  // ../node_modules/lodash-es/isEmpty.js
  var mapTag7 = "[object Map]";
  var setTag7 = "[object Set]";
  var objectProto20 = Object.prototype;
  var hasOwnProperty17 = objectProto20.hasOwnProperty;
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
      return !value.length;
    }
    var tag = getTag_default(value);
    if (tag == mapTag7 || tag == setTag7) {
      return !value.size;
    }
    if (isPrototype_default(value)) {
      return !baseKeys_default(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty17.call(value, key)) {
        return false;
      }
    }
    return true;
  }
  var isEmpty_default = isEmpty;

  // ../node_modules/lodash-es/_baseIsRegExp.js
  var regexpTag5 = "[object RegExp]";
  function baseIsRegExp(value) {
    return isObjectLike_default(value) && baseGetTag_default(value) == regexpTag5;
  }
  var baseIsRegExp_default = baseIsRegExp;

  // ../node_modules/lodash-es/isRegExp.js
  var nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;
  var isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;
  var isRegExp_default = isRegExp;

  // ../node_modules/lodash-es/isUndefined.js
  function isUndefined(value) {
    return value === void 0;
  }
  var isUndefined_default = isUndefined;

  // ../node_modules/lodash-es/_baseLt.js
  function baseLt(value, other) {
    return value < other;
  }
  var baseLt_default = baseLt;

  // ../node_modules/lodash-es/_baseExtremum.js
  function baseExtremum(array, iteratee, comparator) {
    var index = -1, length = array.length;
    while (++index < length) {
      var value = array[index], current = iteratee(value);
      if (current != null && (computed === void 0 ? current === current && !isSymbol_default(current) : comparator(current, computed))) {
        var computed = current, result = value;
      }
    }
    return result;
  }
  var baseExtremum_default = baseExtremum;

  // ../node_modules/lodash-es/min.js
  function min(array) {
    return array && array.length ? baseExtremum_default(array, identity_default, baseLt_default) : void 0;
  }
  var min_default = min;

  // ../node_modules/lodash-es/negate.js
  var FUNC_ERROR_TEXT2 = "Expected a function";
  function negate(predicate) {
    if (typeof predicate != "function") {
      throw new TypeError(FUNC_ERROR_TEXT2);
    }
    return function() {
      var args = arguments;
      switch (args.length) {
        case 0:
          return !predicate.call(this);
        case 1:
          return !predicate.call(this, args[0]);
        case 2:
          return !predicate.call(this, args[0], args[1]);
        case 3:
          return !predicate.call(this, args[0], args[1], args[2]);
      }
      return !predicate.apply(this, args);
    };
  }
  var negate_default = negate;

  // ../node_modules/lodash-es/_baseSet.js
  function baseSet(object, path, value, customizer) {
    if (!isObject_default(object)) {
      return object;
    }
    path = castPath_default(path, object);
    var index = -1, length = path.length, lastIndex = length - 1, nested = object;
    while (nested != null && ++index < length) {
      var key = toKey_default(path[index]), newValue = value;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object;
      }
      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
        }
      }
      assignValue_default(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }
  var baseSet_default = baseSet;

  // ../node_modules/lodash-es/_basePickBy.js
  function basePickBy(object, paths, predicate) {
    var index = -1, length = paths.length, result = {};
    while (++index < length) {
      var path = paths[index], value = baseGet_default(object, path);
      if (predicate(value, path)) {
        baseSet_default(result, castPath_default(path, object), value);
      }
    }
    return result;
  }
  var basePickBy_default = basePickBy;

  // ../node_modules/lodash-es/pickBy.js
  function pickBy(object, predicate) {
    if (object == null) {
      return {};
    }
    var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {
      return [prop];
    });
    predicate = baseIteratee_default(predicate);
    return basePickBy_default(object, props, function(value, path) {
      return predicate(value, path[0]);
    });
  }
  var pickBy_default = pickBy;

  // ../node_modules/lodash-es/_baseReduce.js
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection2) {
      accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
    });
    return accumulator;
  }
  var baseReduce_default = baseReduce;

  // ../node_modules/lodash-es/reduce.js
  function reduce(collection, iteratee, accumulator) {
    var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;
    return func(collection, baseIteratee_default(iteratee, 4), accumulator, initAccum, baseEach_default);
  }
  var reduce_default = reduce;

  // ../node_modules/lodash-es/reject.js
  function reject(collection, predicate) {
    var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
    return func(collection, negate_default(baseIteratee_default(predicate, 3)));
  }
  var reject_default = reject;

  // ../node_modules/lodash-es/_baseSome.js
  function baseSome(collection, predicate) {
    var result;
    baseEach_default(collection, function(value, index, collection2) {
      result = predicate(value, index, collection2);
      return !result;
    });
    return !!result;
  }
  var baseSome_default = baseSome;

  // ../node_modules/lodash-es/some.js
  function some(collection, predicate, guard) {
    var func = isArray_default(collection) ? arraySome_default : baseSome_default;
    if (guard && isIterateeCall_default(collection, predicate, guard)) {
      predicate = void 0;
    }
    return func(collection, baseIteratee_default(predicate, 3));
  }
  var some_default = some;

  // ../node_modules/lodash-es/_createSet.js
  var INFINITY4 = 1 / 0;
  var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY4) ? noop_default : function(values2) {
    return new Set_default(values2);
  };
  var createSet_default = createSet;

  // ../node_modules/lodash-es/_baseUniq.js
  var LARGE_ARRAY_SIZE3 = 200;
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes2 = arrayIncludes_default, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes2 = arrayIncludesWith_default;
    } else if (length >= LARGE_ARRAY_SIZE3) {
      var set = iteratee ? null : createSet_default(array);
      if (set) {
        return setToArray_default(set);
      }
      isCommon = false;
      includes2 = cacheHas_default;
      seen = new SetCache_default();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes2(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  var baseUniq_default = baseUniq;

  // ../node_modules/lodash-es/uniq.js
  function uniq(array) {
    return array && array.length ? baseUniq_default(array) : [];
  }
  var uniq_default = uniq;

  // ../node_modules/lodash-es/uniqBy.js
  function uniqBy(array, iteratee) {
    return array && array.length ? baseUniq_default(array, baseIteratee_default(iteratee, 2)) : [];
  }
  var uniqBy_default = uniqBy;

  // ../node_modules/@chevrotain/utils/lib/src/print.js
  function PRINT_ERROR(msg) {
    if (console && console.error) {
      console.error(`Error: ${msg}`);
    }
  }
  function PRINT_WARNING(msg) {
    if (console && console.warn) {
      console.warn(`Warning: ${msg}`);
    }
  }

  // ../node_modules/@chevrotain/utils/lib/src/timer.js
  function timer(func) {
    const start = (/* @__PURE__ */ new Date()).getTime();
    const val = func();
    const end = (/* @__PURE__ */ new Date()).getTime();
    const total = end - start;
    return { time: total, value: val };
  }

  // ../node_modules/@chevrotain/utils/lib/src/to-fast-properties.js
  function toFastProperties(toBecomeFast) {
    function FakeConstructor() {
    }
    FakeConstructor.prototype = toBecomeFast;
    const fakeInstance = new FakeConstructor();
    function fakeAccess() {
      return typeof fakeInstance.bar;
    }
    fakeAccess();
    fakeAccess();
    if (1)
      return toBecomeFast;
    (0, eval)(toBecomeFast);
  }

  // ../node_modules/@chevrotain/gast/lib/src/model.js
  function tokenLabel(tokType) {
    if (hasTokenLabel(tokType)) {
      return tokType.LABEL;
    } else {
      return tokType.name;
    }
  }
  function hasTokenLabel(obj) {
    return isString_default(obj.LABEL) && obj.LABEL !== "";
  }
  var AbstractProduction = class {
    get definition() {
      return this._definition;
    }
    set definition(value) {
      this._definition = value;
    }
    constructor(_definition) {
      this._definition = _definition;
    }
    accept(visitor2) {
      visitor2.visit(this);
      forEach_default(this.definition, (prod) => {
        prod.accept(visitor2);
      });
    }
  };
  var NonTerminal = class extends AbstractProduction {
    constructor(options) {
      super([]);
      this.idx = 1;
      assign_default(this, pickBy_default(options, (v) => v !== void 0));
    }
    set definition(definition) {
    }
    get definition() {
      if (this.referencedRule !== void 0) {
        return this.referencedRule.definition;
      }
      return [];
    }
    accept(visitor2) {
      visitor2.visit(this);
    }
  };
  var Rule = class extends AbstractProduction {
    constructor(options) {
      super(options.definition);
      this.orgText = "";
      assign_default(this, pickBy_default(options, (v) => v !== void 0));
    }
  };
  var Alternative = class extends AbstractProduction {
    constructor(options) {
      super(options.definition);
      this.ignoreAmbiguities = false;
      assign_default(this, pickBy_default(options, (v) => v !== void 0));
    }
  };
  var Option = class extends AbstractProduction {
    constructor(options) {
      super(options.definition);
      this.idx = 1;
      assign_default(this, pickBy_default(options, (v) => v !== void 0));
    }
  };
  var RepetitionMandatory = class extends AbstractProduction {
    constructor(options) {
      super(options.definition);
      this.idx = 1;
      assign_default(this, pickBy_default(options, (v) => v !== void 0));
    }
  };
  var RepetitionMandatoryWithSeparator = class extends AbstractProduction {
    constructor(options) {
      super(options.definition);
      this.idx = 1;
      assign_default(this, pickBy_default(options, (v) => v !== void 0));
    }
  };
  var Repetition = class extends AbstractProduction {
    constructor(options) {
      super(options.definition);
      this.idx = 1;
      assign_default(this, pickBy_default(options, (v) => v !== void 0));
    }
  };
  var RepetitionWithSeparator = class extends AbstractProduction {
    constructor(options) {
      super(options.definition);
      this.idx = 1;
      assign_default(this, pickBy_default(options, (v) => v !== void 0));
    }
  };
  var Alternation = class extends AbstractProduction {
    get definition() {
      return this._definition;
    }
    set definition(value) {
      this._definition = value;
    }
    constructor(options) {
      super(options.definition);
      this.idx = 1;
      this.ignoreAmbiguities = false;
      this.hasPredicates = false;
      assign_default(this, pickBy_default(options, (v) => v !== void 0));
    }
  };
  var Terminal = class {
    constructor(options) {
      this.idx = 1;
      assign_default(this, pickBy_default(options, (v) => v !== void 0));
    }
    accept(visitor2) {
      visitor2.visit(this);
    }
  };
  function serializeGrammar(topRules) {
    return map_default(topRules, serializeProduction);
  }
  function serializeProduction(node) {
    function convertDefinition(definition) {
      return map_default(definition, serializeProduction);
    }
    if (node instanceof NonTerminal) {
      const serializedNonTerminal = {
        type: "NonTerminal",
        name: node.nonTerminalName,
        idx: node.idx
      };
      if (isString_default(node.label)) {
        serializedNonTerminal.label = node.label;
      }
      return serializedNonTerminal;
    } else if (node instanceof Alternative) {
      return {
        type: "Alternative",
        definition: convertDefinition(node.definition)
      };
    } else if (node instanceof Option) {
      return {
        type: "Option",
        idx: node.idx,
        definition: convertDefinition(node.definition)
      };
    } else if (node instanceof RepetitionMandatory) {
      return {
        type: "RepetitionMandatory",
        idx: node.idx,
        definition: convertDefinition(node.definition)
      };
    } else if (node instanceof RepetitionMandatoryWithSeparator) {
      return {
        type: "RepetitionMandatoryWithSeparator",
        idx: node.idx,
        separator: serializeProduction(new Terminal({ terminalType: node.separator })),
        definition: convertDefinition(node.definition)
      };
    } else if (node instanceof RepetitionWithSeparator) {
      return {
        type: "RepetitionWithSeparator",
        idx: node.idx,
        separator: serializeProduction(new Terminal({ terminalType: node.separator })),
        definition: convertDefinition(node.definition)
      };
    } else if (node instanceof Repetition) {
      return {
        type: "Repetition",
        idx: node.idx,
        definition: convertDefinition(node.definition)
      };
    } else if (node instanceof Alternation) {
      return {
        type: "Alternation",
        idx: node.idx,
        definition: convertDefinition(node.definition)
      };
    } else if (node instanceof Terminal) {
      const serializedTerminal = {
        type: "Terminal",
        name: node.terminalType.name,
        label: tokenLabel(node.terminalType),
        idx: node.idx
      };
      if (isString_default(node.label)) {
        serializedTerminal.terminalLabel = node.label;
      }
      const pattern = node.terminalType.PATTERN;
      if (node.terminalType.PATTERN) {
        serializedTerminal.pattern = isRegExp_default(pattern) ? pattern.source : pattern;
      }
      return serializedTerminal;
    } else if (node instanceof Rule) {
      return {
        type: "Rule",
        name: node.name,
        orgText: node.orgText,
        definition: convertDefinition(node.definition)
      };
    } else {
      throw Error("non exhaustive match");
    }
  }

  // ../node_modules/@chevrotain/gast/lib/src/visitor.js
  var GAstVisitor = class {
    visit(node) {
      const nodeAny = node;
      switch (nodeAny.constructor) {
        case NonTerminal:
          return this.visitNonTerminal(nodeAny);
        case Alternative:
          return this.visitAlternative(nodeAny);
        case Option:
          return this.visitOption(nodeAny);
        case RepetitionMandatory:
          return this.visitRepetitionMandatory(nodeAny);
        case RepetitionMandatoryWithSeparator:
          return this.visitRepetitionMandatoryWithSeparator(nodeAny);
        case RepetitionWithSeparator:
          return this.visitRepetitionWithSeparator(nodeAny);
        case Repetition:
          return this.visitRepetition(nodeAny);
        case Alternation:
          return this.visitAlternation(nodeAny);
        case Terminal:
          return this.visitTerminal(nodeAny);
        case Rule:
          return this.visitRule(nodeAny);
        default:
          throw Error("non exhaustive match");
      }
    }
    /* c8 ignore next */
    visitNonTerminal(node) {
    }
    /* c8 ignore next */
    visitAlternative(node) {
    }
    /* c8 ignore next */
    visitOption(node) {
    }
    /* c8 ignore next */
    visitRepetition(node) {
    }
    /* c8 ignore next */
    visitRepetitionMandatory(node) {
    }
    /* c8 ignore next 3 */
    visitRepetitionMandatoryWithSeparator(node) {
    }
    /* c8 ignore next */
    visitRepetitionWithSeparator(node) {
    }
    /* c8 ignore next */
    visitAlternation(node) {
    }
    /* c8 ignore next */
    visitTerminal(node) {
    }
    /* c8 ignore next */
    visitRule(node) {
    }
  };

  // ../node_modules/@chevrotain/gast/lib/src/helpers.js
  function isSequenceProd(prod) {
    return prod instanceof Alternative || prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionMandatory || prod instanceof RepetitionMandatoryWithSeparator || prod instanceof RepetitionWithSeparator || prod instanceof Terminal || prod instanceof Rule;
  }
  function isOptionalProd(prod, alreadyVisited = []) {
    const isDirectlyOptional = prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionWithSeparator;
    if (isDirectlyOptional) {
      return true;
    }
    if (prod instanceof Alternation) {
      return some_default(prod.definition, (subProd) => {
        return isOptionalProd(subProd, alreadyVisited);
      });
    } else if (prod instanceof NonTerminal && includes_default(alreadyVisited, prod)) {
      return false;
    } else if (prod instanceof AbstractProduction) {
      if (prod instanceof NonTerminal) {
        alreadyVisited.push(prod);
      }
      return every_default(prod.definition, (subProd) => {
        return isOptionalProd(subProd, alreadyVisited);
      });
    } else {
      return false;
    }
  }
  function isBranchingProd(prod) {
    return prod instanceof Alternation;
  }
  function getProductionDslName(prod) {
    if (prod instanceof NonTerminal) {
      return "SUBRULE";
    } else if (prod instanceof Option) {
      return "OPTION";
    } else if (prod instanceof Alternation) {
      return "OR";
    } else if (prod instanceof RepetitionMandatory) {
      return "AT_LEAST_ONE";
    } else if (prod instanceof RepetitionMandatoryWithSeparator) {
      return "AT_LEAST_ONE_SEP";
    } else if (prod instanceof RepetitionWithSeparator) {
      return "MANY_SEP";
    } else if (prod instanceof Repetition) {
      return "MANY";
    } else if (prod instanceof Terminal) {
      return "CONSUME";
    } else {
      throw Error("non exhaustive match");
    }
  }

  // ../node_modules/chevrotain/lib/src/parse/grammar/rest.js
  var RestWalker = class {
    walk(prod, prevRest = []) {
      forEach_default(prod.definition, (subProd, index) => {
        const currRest = drop_default(prod.definition, index + 1);
        if (subProd instanceof NonTerminal) {
          this.walkProdRef(subProd, currRest, prevRest);
        } else if (subProd instanceof Terminal) {
          this.walkTerminal(subProd, currRest, prevRest);
        } else if (subProd instanceof Alternative) {
          this.walkFlat(subProd, currRest, prevRest);
        } else if (subProd instanceof Option) {
          this.walkOption(subProd, currRest, prevRest);
        } else if (subProd instanceof RepetitionMandatory) {
          this.walkAtLeastOne(subProd, currRest, prevRest);
        } else if (subProd instanceof RepetitionMandatoryWithSeparator) {
          this.walkAtLeastOneSep(subProd, currRest, prevRest);
        } else if (subProd instanceof RepetitionWithSeparator) {
          this.walkManySep(subProd, currRest, prevRest);
        } else if (subProd instanceof Repetition) {
          this.walkMany(subProd, currRest, prevRest);
        } else if (subProd instanceof Alternation) {
          this.walkOr(subProd, currRest, prevRest);
        } else {
          throw Error("non exhaustive match");
        }
      });
    }
    walkTerminal(terminal, currRest, prevRest) {
    }
    walkProdRef(refProd, currRest, prevRest) {
    }
    walkFlat(flatProd, currRest, prevRest) {
      const fullOrRest = currRest.concat(prevRest);
      this.walk(flatProd, fullOrRest);
    }
    walkOption(optionProd, currRest, prevRest) {
      const fullOrRest = currRest.concat(prevRest);
      this.walk(optionProd, fullOrRest);
    }
    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {
      const fullAtLeastOneRest = [
        new Option({ definition: atLeastOneProd.definition })
      ].concat(currRest, prevRest);
      this.walk(atLeastOneProd, fullAtLeastOneRest);
    }
    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {
      const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
      this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
    }
    walkMany(manyProd, currRest, prevRest) {
      const fullManyRest = [
        new Option({ definition: manyProd.definition })
      ].concat(currRest, prevRest);
      this.walk(manyProd, fullManyRest);
    }
    walkManySep(manySepProd, currRest, prevRest) {
      const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
      this.walk(manySepProd, fullManySepRest);
    }
    walkOr(orProd, currRest, prevRest) {
      const fullOrRest = currRest.concat(prevRest);
      forEach_default(orProd.definition, (alt) => {
        const prodWrapper = new Alternative({ definition: [alt] });
        this.walk(prodWrapper, fullOrRest);
      });
    }
  };
  function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
    const repSepRest = [
      new Option({
        definition: [
          new Terminal({ terminalType: repSepProd.separator })
        ].concat(repSepProd.definition)
      })
    ];
    const fullRepSepRest = repSepRest.concat(currRest, prevRest);
    return fullRepSepRest;
  }

  // ../node_modules/chevrotain/lib/src/parse/grammar/first.js
  function first(prod) {
    if (prod instanceof NonTerminal) {
      return first(prod.referencedRule);
    } else if (prod instanceof Terminal) {
      return firstForTerminal(prod);
    } else if (isSequenceProd(prod)) {
      return firstForSequence(prod);
    } else if (isBranchingProd(prod)) {
      return firstForBranching(prod);
    } else {
      throw Error("non exhaustive match");
    }
  }
  function firstForSequence(prod) {
    let firstSet = [];
    const seq = prod.definition;
    let nextSubProdIdx = 0;
    let hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    let currSubProd;
    let isLastInnerProdOptional = true;
    while (hasInnerProdsRemaining && isLastInnerProdOptional) {
      currSubProd = seq[nextSubProdIdx];
      isLastInnerProdOptional = isOptionalProd(currSubProd);
      firstSet = firstSet.concat(first(currSubProd));
      nextSubProdIdx = nextSubProdIdx + 1;
      hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    }
    return uniq_default(firstSet);
  }
  function firstForBranching(prod) {
    const allAlternativesFirsts = map_default(prod.definition, (innerProd) => {
      return first(innerProd);
    });
    return uniq_default(flatten_default(allAlternativesFirsts));
  }
  function firstForTerminal(terminal) {
    return [terminal.terminalType];
  }

  // ../node_modules/chevrotain/lib/src/parse/constants.js
  var IN = "_~IN~_";

  // ../node_modules/chevrotain/lib/src/parse/grammar/follow.js
  var ResyncFollowsWalker = class extends RestWalker {
    constructor(topProd) {
      super();
      this.topProd = topProd;
      this.follows = {};
    }
    startWalking() {
      this.walk(this.topProd);
      return this.follows;
    }
    walkTerminal(terminal, currRest, prevRest) {
    }
    walkProdRef(refProd, currRest, prevRest) {
      const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
      const fullRest = currRest.concat(prevRest);
      const restProd = new Alternative({ definition: fullRest });
      const t_in_topProd_follows = first(restProd);
      this.follows[followName] = t_in_topProd_follows;
    }
  };
  function computeAllProdsFollows(topProductions) {
    const reSyncFollows = {};
    forEach_default(topProductions, (topProd) => {
      const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
      assign_default(reSyncFollows, currRefsFollow);
    });
    return reSyncFollows;
  }
  function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
    return inner.name + occurenceInParent + IN;
  }

  // ../node_modules/chevrotain/lib/src/scan/reg_exp_parser.js
  var regExpAstCache = {};
  var regExpParser = new RegExpParser();
  function getRegExpAst(regExp) {
    const regExpStr = regExp.toString();
    if (regExpAstCache.hasOwnProperty(regExpStr)) {
      return regExpAstCache[regExpStr];
    } else {
      const regExpAst = regExpParser.pattern(regExpStr);
      regExpAstCache[regExpStr] = regExpAst;
      return regExpAst;
    }
  }
  function clearRegExpParserCache() {
    regExpAstCache = {};
  }

  // ../node_modules/chevrotain/lib/src/scan/reg_exp.js
  var complementErrorMessage = "Complement Sets are not supported for first char optimization";
  var failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
  function getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {
    try {
      const ast = getRegExpAst(regExp);
      const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
      return firstChars;
    } catch (e) {
      if (e.message === complementErrorMessage) {
        if (ensureOptimizations) {
          PRINT_WARNING(`${failedOptimizationPrefixMsg}	Unable to optimize: < ${regExp.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
        }
      } else {
        let msgSuffix = "";
        if (ensureOptimizations) {
          msgSuffix = "\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
        }
        PRINT_ERROR(`${failedOptimizationPrefixMsg}
	Failed parsing: < ${regExp.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues` + msgSuffix);
      }
    }
    return [];
  }
  function firstCharOptimizedIndices(ast, result, ignoreCase) {
    switch (ast.type) {
      case "Disjunction":
        for (let i = 0; i < ast.value.length; i++) {
          firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
        }
        break;
      case "Alternative":
        const terms = ast.value;
        for (let i = 0; i < terms.length; i++) {
          const term = terms[i];
          switch (term.type) {
            case "EndAnchor":
            case "GroupBackReference":
            case "Lookahead":
            case "NegativeLookahead":
            case "StartAnchor":
            case "WordBoundary":
            case "NonWordBoundary":
              continue;
          }
          const atom2 = term;
          switch (atom2.type) {
            case "Character":
              addOptimizedIdxToResult(atom2.value, result, ignoreCase);
              break;
            case "Set":
              if (atom2.complement === true) {
                throw Error(complementErrorMessage);
              }
              forEach_default(atom2.value, (code) => {
                if (typeof code === "number") {
                  addOptimizedIdxToResult(code, result, ignoreCase);
                } else {
                  const range = code;
                  if (ignoreCase === true) {
                    for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                      addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                    }
                  } else {
                    for (let rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {
                      addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                    }
                    if (range.to >= minOptimizationVal) {
                      const minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;
                      const maxUnOptVal = range.to;
                      const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);
                      const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);
                      for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                        result[currOptIdx] = currOptIdx;
                      }
                    }
                  }
                }
              });
              break;
            case "Group":
              firstCharOptimizedIndices(atom2.value, result, ignoreCase);
              break;
            default:
              throw Error("Non Exhaustive Match");
          }
          const isOptionalQuantifier = atom2.quantifier !== void 0 && atom2.quantifier.atLeast === 0;
          if (
            // A group may be optional due to empty contents /(?:)/
            // or if everything inside it is optional /((a)?)/
            atom2.type === "Group" && isWholeOptional(atom2) === false || // If this term is not a group it may only be optional if it has an optional quantifier
            atom2.type !== "Group" && isOptionalQuantifier === false
          ) {
            break;
          }
        }
        break;
      default:
        throw Error("non exhaustive match!");
    }
    return values_default(result);
  }
  function addOptimizedIdxToResult(code, result, ignoreCase) {
    const optimizedCharIdx = charCodeToOptimizedIndex(code);
    result[optimizedCharIdx] = optimizedCharIdx;
    if (ignoreCase === true) {
      handleIgnoreCase(code, result);
    }
  }
  function handleIgnoreCase(code, result) {
    const char = String.fromCharCode(code);
    const upperChar = char.toUpperCase();
    if (upperChar !== char) {
      const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));
      result[optimizedCharIdx] = optimizedCharIdx;
    } else {
      const lowerChar = char.toLowerCase();
      if (lowerChar !== char) {
        const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));
        result[optimizedCharIdx] = optimizedCharIdx;
      }
    }
  }
  function findCode(setNode, targetCharCodes) {
    return find_default(setNode.value, (codeOrRange) => {
      if (typeof codeOrRange === "number") {
        return includes_default(targetCharCodes, codeOrRange);
      } else {
        const range = codeOrRange;
        return find_default(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== void 0;
      }
    });
  }
  function isWholeOptional(ast) {
    const quantifier = ast.quantifier;
    if (quantifier && quantifier.atLeast === 0) {
      return true;
    }
    if (!ast.value) {
      return false;
    }
    return isArray_default(ast.value) ? every_default(ast.value, isWholeOptional) : isWholeOptional(ast.value);
  }
  var CharCodeFinder = class extends BaseRegExpVisitor {
    constructor(targetCharCodes) {
      super();
      this.targetCharCodes = targetCharCodes;
      this.found = false;
    }
    visitChildren(node) {
      if (this.found === true) {
        return;
      }
      switch (node.type) {
        case "Lookahead":
          this.visitLookahead(node);
          return;
        case "NegativeLookahead":
          this.visitNegativeLookahead(node);
          return;
      }
      super.visitChildren(node);
    }
    visitCharacter(node) {
      if (includes_default(this.targetCharCodes, node.value)) {
        this.found = true;
      }
    }
    visitSet(node) {
      if (node.complement) {
        if (findCode(node, this.targetCharCodes) === void 0) {
          this.found = true;
        }
      } else {
        if (findCode(node, this.targetCharCodes) !== void 0) {
          this.found = true;
        }
      }
    }
  };
  function canMatchCharCode(charCodes, pattern) {
    if (pattern instanceof RegExp) {
      const ast = getRegExpAst(pattern);
      const charCodeFinder = new CharCodeFinder(charCodes);
      charCodeFinder.visit(ast);
      return charCodeFinder.found;
    } else {
      return find_default(pattern, (char) => {
        return includes_default(charCodes, char.charCodeAt(0));
      }) !== void 0;
    }
  }

  // ../node_modules/chevrotain/lib/src/scan/lexer.js
  var PATTERN = "PATTERN";
  var DEFAULT_MODE = "defaultMode";
  var MODES = "modes";
  var SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
  function analyzeTokenTypes(tokenTypes, options) {
    options = defaults_default(options, {
      useSticky: SUPPORT_STICKY,
      debug: false,
      safeMode: false,
      positionTracking: "full",
      lineTerminatorCharacters: ["\r", "\n"],
      tracer: (msg, action) => action()
    });
    const tracer = options.tracer;
    tracer("initCharCodeToOptimizedIndexMap", () => {
      initCharCodeToOptimizedIndexMap();
    });
    let onlyRelevantTypes;
    tracer("Reject Lexer.NA", () => {
      onlyRelevantTypes = reject_default(tokenTypes, (currType) => {
        return currType[PATTERN] === Lexer.NA;
      });
    });
    let hasCustom = false;
    let allTransformedPatterns;
    tracer("Transform Patterns", () => {
      hasCustom = false;
      allTransformedPatterns = map_default(onlyRelevantTypes, (currType) => {
        const currPattern = currType[PATTERN];
        if (isRegExp_default(currPattern)) {
          const regExpSource = currPattern.source;
          if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp
          regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) {
            return regExpSource;
          } else if (regExpSource.length === 2 && regExpSource[0] === "\\" && // not a meta character
          !includes_default([
            "d",
            "D",
            "s",
            "S",
            "t",
            "r",
            "n",
            "t",
            "0",
            "c",
            "b",
            "B",
            "f",
            "v",
            "w",
            "W"
          ], regExpSource[1])) {
            return regExpSource[1];
          } else {
            return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
          }
        } else if (isFunction_default(currPattern)) {
          hasCustom = true;
          return { exec: currPattern };
        } else if (typeof currPattern === "object") {
          hasCustom = true;
          return currPattern;
        } else if (typeof currPattern === "string") {
          if (currPattern.length === 1) {
            return currPattern;
          } else {
            const escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
            const wrappedRegExp = new RegExp(escapedRegExpString);
            return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
          }
        } else {
          throw Error("non exhaustive match");
        }
      });
    });
    let patternIdxToType;
    let patternIdxToGroup;
    let patternIdxToLongerAltIdxArr;
    let patternIdxToPushMode;
    let patternIdxToPopMode;
    tracer("misc mapping", () => {
      patternIdxToType = map_default(onlyRelevantTypes, (currType) => currType.tokenTypeIdx);
      patternIdxToGroup = map_default(onlyRelevantTypes, (clazz) => {
        const groupName = clazz.GROUP;
        if (groupName === Lexer.SKIPPED) {
          return void 0;
        } else if (isString_default(groupName)) {
          return groupName;
        } else if (isUndefined_default(groupName)) {
          return false;
        } else {
          throw Error("non exhaustive match");
        }
      });
      patternIdxToLongerAltIdxArr = map_default(onlyRelevantTypes, (clazz) => {
        const longerAltType = clazz.LONGER_ALT;
        if (longerAltType) {
          const longerAltIdxArr = isArray_default(longerAltType) ? map_default(longerAltType, (type) => indexOf_default(onlyRelevantTypes, type)) : [indexOf_default(onlyRelevantTypes, longerAltType)];
          return longerAltIdxArr;
        }
      });
      patternIdxToPushMode = map_default(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE);
      patternIdxToPopMode = map_default(onlyRelevantTypes, (clazz) => has_default(clazz, "POP_MODE"));
    });
    let patternIdxToCanLineTerminator;
    tracer("Line Terminator Handling", () => {
      const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
      patternIdxToCanLineTerminator = map_default(onlyRelevantTypes, (tokType) => false);
      if (options.positionTracking !== "onlyOffset") {
        patternIdxToCanLineTerminator = map_default(onlyRelevantTypes, (tokType) => {
          if (has_default(tokType, "LINE_BREAKS")) {
            return !!tokType.LINE_BREAKS;
          } else {
            return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);
          }
        });
      }
    });
    let patternIdxToIsCustom;
    let patternIdxToShort;
    let emptyGroups;
    let patternIdxToConfig;
    tracer("Misc Mapping #2", () => {
      patternIdxToIsCustom = map_default(onlyRelevantTypes, isCustomPattern);
      patternIdxToShort = map_default(allTransformedPatterns, isShortPattern);
      emptyGroups = reduce_default(onlyRelevantTypes, (acc, clazz) => {
        const groupName = clazz.GROUP;
        if (isString_default(groupName) && !(groupName === Lexer.SKIPPED)) {
          acc[groupName] = [];
        }
        return acc;
      }, {});
      patternIdxToConfig = map_default(allTransformedPatterns, (x, idx) => {
        return {
          pattern: allTransformedPatterns[idx],
          longerAlt: patternIdxToLongerAltIdxArr[idx],
          canLineTerminator: patternIdxToCanLineTerminator[idx],
          isCustom: patternIdxToIsCustom[idx],
          short: patternIdxToShort[idx],
          group: patternIdxToGroup[idx],
          push: patternIdxToPushMode[idx],
          pop: patternIdxToPopMode[idx],
          tokenTypeIdx: patternIdxToType[idx],
          tokenType: onlyRelevantTypes[idx]
        };
      });
    });
    let canBeOptimized = true;
    let charCodeToPatternIdxToConfig = [];
    if (!options.safeMode) {
      tracer("First Char Optimization", () => {
        charCodeToPatternIdxToConfig = reduce_default(onlyRelevantTypes, (result, currTokType, idx) => {
          if (typeof currTokType.PATTERN === "string") {
            const charCode = currTokType.PATTERN.charCodeAt(0);
            const optimizedIdx = charCodeToOptimizedIndex(charCode);
            addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
          } else if (isArray_default(currTokType.START_CHARS_HINT)) {
            let lastOptimizedIdx;
            forEach_default(currTokType.START_CHARS_HINT, (charOrInt) => {
              const charCode = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
              const currOptimizedIdx = charCodeToOptimizedIndex(charCode);
              if (lastOptimizedIdx !== currOptimizedIdx) {
                lastOptimizedIdx = currOptimizedIdx;
                addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
              }
            });
          } else if (isRegExp_default(currTokType.PATTERN)) {
            if (currTokType.PATTERN.unicode) {
              canBeOptimized = false;
              if (options.ensureOptimizations) {
                PRINT_ERROR(`${failedOptimizationPrefixMsg}	Unable to analyze < ${currTokType.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);
              }
            } else {
              const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);
              if (isEmpty_default(optimizedCodes)) {
                canBeOptimized = false;
              }
              forEach_default(optimizedCodes, (code) => {
                addToMapOfArrays(result, code, patternIdxToConfig[idx]);
              });
            }
          } else {
            if (options.ensureOptimizations) {
              PRINT_ERROR(`${failedOptimizationPrefixMsg}	TokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`);
            }
            canBeOptimized = false;
          }
          return result;
        }, []);
      });
    }
    return {
      emptyGroups,
      patternIdxToConfig,
      charCodeToPatternIdxToConfig,
      hasCustom,
      canBeOptimized
    };
  }
  function validatePatterns(tokenTypes, validModesNames) {
    let errors = [];
    const missingResult = findMissingPatterns(tokenTypes);
    errors = errors.concat(missingResult.errors);
    const invalidResult = findInvalidPatterns(missingResult.valid);
    const validTokenTypes = invalidResult.valid;
    errors = errors.concat(invalidResult.errors);
    errors = errors.concat(validateRegExpPattern(validTokenTypes));
    errors = errors.concat(findInvalidGroupType(validTokenTypes));
    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
    errors = errors.concat(findUnreachablePatterns(validTokenTypes));
    return errors;
  }
  function validateRegExpPattern(tokenTypes) {
    let errors = [];
    const withRegExpPatterns = filter_default(tokenTypes, (currTokType) => isRegExp_default(currTokType[PATTERN]));
    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
    return errors;
  }
  function findMissingPatterns(tokenTypes) {
    const tokenTypesWithMissingPattern = filter_default(tokenTypes, (currType) => {
      return !has_default(currType, PATTERN);
    });
    const errors = map_default(tokenTypesWithMissingPattern, (currType) => {
      return {
        message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
        type: LexerDefinitionErrorType.MISSING_PATTERN,
        tokenTypes: [currType]
      };
    });
    const valid = difference_default(tokenTypes, tokenTypesWithMissingPattern);
    return { errors, valid };
  }
  function findInvalidPatterns(tokenTypes) {
    const tokenTypesWithInvalidPattern = filter_default(tokenTypes, (currType) => {
      const pattern = currType[PATTERN];
      return !isRegExp_default(pattern) && !isFunction_default(pattern) && !has_default(pattern, "exec") && !isString_default(pattern);
    });
    const errors = map_default(tokenTypesWithInvalidPattern, (currType) => {
      return {
        message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
        type: LexerDefinitionErrorType.INVALID_PATTERN,
        tokenTypes: [currType]
      };
    });
    const valid = difference_default(tokenTypes, tokenTypesWithInvalidPattern);
    return { errors, valid };
  }
  var end_of_input = /[^\\][$]/;
  function findEndOfInputAnchor(tokenTypes) {
    class EndAnchorFinder extends BaseRegExpVisitor {
      constructor() {
        super(...arguments);
        this.found = false;
      }
      visitEndAnchor(node) {
        this.found = true;
      }
    }
    const invalidRegex = filter_default(tokenTypes, (currType) => {
      const pattern = currType.PATTERN;
      try {
        const regexpAst = getRegExpAst(pattern);
        const endAnchorVisitor = new EndAnchorFinder();
        endAnchorVisitor.visit(regexpAst);
        return endAnchorVisitor.found;
      } catch (e) {
        return end_of_input.test(pattern.source);
      }
    });
    const errors = map_default(invalidRegex, (currType) => {
      return {
        message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
        type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
        tokenTypes: [currType]
      };
    });
    return errors;
  }
  function findEmptyMatchRegExps(tokenTypes) {
    const matchesEmptyString = filter_default(tokenTypes, (currType) => {
      const pattern = currType.PATTERN;
      return pattern.test("");
    });
    const errors = map_default(matchesEmptyString, (currType) => {
      return {
        message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
        type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
        tokenTypes: [currType]
      };
    });
    return errors;
  }
  var start_of_input = /[^\\[][\^]|^\^/;
  function findStartOfInputAnchor(tokenTypes) {
    class StartAnchorFinder extends BaseRegExpVisitor {
      constructor() {
        super(...arguments);
        this.found = false;
      }
      visitStartAnchor(node) {
        this.found = true;
      }
    }
    const invalidRegex = filter_default(tokenTypes, (currType) => {
      const pattern = currType.PATTERN;
      try {
        const regexpAst = getRegExpAst(pattern);
        const startAnchorVisitor = new StartAnchorFinder();
        startAnchorVisitor.visit(regexpAst);
        return startAnchorVisitor.found;
      } catch (e) {
        return start_of_input.test(pattern.source);
      }
    });
    const errors = map_default(invalidRegex, (currType) => {
      return {
        message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
        type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
        tokenTypes: [currType]
      };
    });
    return errors;
  }
  function findUnsupportedFlags(tokenTypes) {
    const invalidFlags = filter_default(tokenTypes, (currType) => {
      const pattern = currType[PATTERN];
      return pattern instanceof RegExp && (pattern.multiline || pattern.global);
    });
    const errors = map_default(invalidFlags, (currType) => {
      return {
        message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
        type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
        tokenTypes: [currType]
      };
    });
    return errors;
  }
  function findDuplicatePatterns(tokenTypes) {
    const found = [];
    let identicalPatterns = map_default(tokenTypes, (outerType) => {
      return reduce_default(tokenTypes, (result, innerType) => {
        if (outerType.PATTERN.source === innerType.PATTERN.source && !includes_default(found, innerType) && innerType.PATTERN !== Lexer.NA) {
          found.push(innerType);
          result.push(innerType);
          return result;
        }
        return result;
      }, []);
    });
    identicalPatterns = compact_default(identicalPatterns);
    const duplicatePatterns = filter_default(identicalPatterns, (currIdenticalSet) => {
      return currIdenticalSet.length > 1;
    });
    const errors = map_default(duplicatePatterns, (setOfIdentical) => {
      const tokenTypeNames = map_default(setOfIdentical, (currType) => {
        return currType.name;
      });
      const dupPatternSrc = head_default(setOfIdentical).PATTERN;
      return {
        message: `The same RegExp pattern ->${dupPatternSrc}<-has been used in all of the following Token Types: ${tokenTypeNames.join(", ")} <-`,
        type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
        tokenTypes: setOfIdentical
      };
    });
    return errors;
  }
  function findInvalidGroupType(tokenTypes) {
    const invalidTypes = filter_default(tokenTypes, (clazz) => {
      if (!has_default(clazz, "GROUP")) {
        return false;
      }
      const group = clazz.GROUP;
      return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString_default(group);
    });
    const errors = map_default(invalidTypes, (currType) => {
      return {
        message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
        type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
        tokenTypes: [currType]
      };
    });
    return errors;
  }
  function findModesThatDoNotExist(tokenTypes, validModes) {
    const invalidModes = filter_default(tokenTypes, (clazz) => {
      return clazz.PUSH_MODE !== void 0 && !includes_default(validModes, clazz.PUSH_MODE);
    });
    const errors = map_default(invalidModes, (tokType) => {
      const msg = `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-which does not exist`;
      return {
        message: msg,
        type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
        tokenTypes: [tokType]
      };
    });
    return errors;
  }
  function findUnreachablePatterns(tokenTypes) {
    const errors = [];
    const canBeTested = reduce_default(tokenTypes, (result, tokType, idx) => {
      const pattern = tokType.PATTERN;
      if (pattern === Lexer.NA) {
        return result;
      }
      if (isString_default(pattern)) {
        result.push({ str: pattern, idx, tokenType: tokType });
      } else if (isRegExp_default(pattern) && noMetaChar(pattern)) {
        result.push({ str: pattern.source, idx, tokenType: tokType });
      }
      return result;
    }, []);
    forEach_default(tokenTypes, (tokType, testIdx) => {
      forEach_default(canBeTested, ({ str, idx, tokenType }) => {
        if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
          const msg = `Token: ->${tokenType.name}<- can never be matched.
Because it appears AFTER the Token Type ->${tokType.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
          errors.push({
            message: msg,
            type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,
            tokenTypes: [tokType, tokenType]
          });
        }
      });
    });
    return errors;
  }
  function testTokenType(str, pattern) {
    if (isRegExp_default(pattern)) {
      const regExpArray = pattern.exec(str);
      return regExpArray !== null && regExpArray.index === 0;
    } else if (isFunction_default(pattern)) {
      return pattern(str, 0, [], {});
    } else if (has_default(pattern, "exec")) {
      return pattern.exec(str, 0, [], {});
    } else if (typeof pattern === "string") {
      return pattern === str;
    } else {
      throw Error("non exhaustive match");
    }
  }
  function noMetaChar(regExp) {
    const metaChars = [
      ".",
      "\\",
      "[",
      "]",
      "|",
      "^",
      "$",
      "(",
      ")",
      "?",
      "*",
      "+",
      "{"
    ];
    return find_default(metaChars, (char) => regExp.source.indexOf(char) !== -1) === void 0;
  }
  function addStartOfInput(pattern) {
    const flags = pattern.ignoreCase ? "i" : "";
    return new RegExp(`^(?:${pattern.source})`, flags);
  }
  function addStickyFlag(pattern) {
    const flags = pattern.ignoreCase ? "iy" : "y";
    return new RegExp(`${pattern.source}`, flags);
  }
  function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    const errors = [];
    if (!has_default(lexerDefinition, DEFAULT_MODE)) {
      errors.push({
        message: "A MultiMode Lexer cannot be initialized without a <" + DEFAULT_MODE + "> property in its definition\n",
        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
      });
    }
    if (!has_default(lexerDefinition, MODES)) {
      errors.push({
        message: "A MultiMode Lexer cannot be initialized without a <" + MODES + "> property in its definition\n",
        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
      });
    }
    if (has_default(lexerDefinition, MODES) && has_default(lexerDefinition, DEFAULT_MODE) && !has_default(lexerDefinition.modes, lexerDefinition.defaultMode)) {
      errors.push({
        message: `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>which does not exist
`,
        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
      });
    }
    if (has_default(lexerDefinition, MODES)) {
      forEach_default(lexerDefinition.modes, (currModeValue, currModeName) => {
        forEach_default(currModeValue, (currTokType, currIdx) => {
          if (isUndefined_default(currTokType)) {
            errors.push({
              message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${currModeName}> at index: <${currIdx}>
`,
              type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
            });
          } else if (has_default(currTokType, "LONGER_ALT")) {
            const longerAlt = isArray_default(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];
            forEach_default(longerAlt, (currLongerAlt) => {
              if (!isUndefined_default(currLongerAlt) && !includes_default(currModeValue, currLongerAlt)) {
                errors.push({
                  message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>
`,
                  type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
                });
              }
            });
          }
        });
      });
    }
    return errors;
  }
  function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    const warnings = [];
    let hasAnyLineBreak = false;
    const allTokenTypes = compact_default(flatten_default(values_default(lexerDefinition.modes)));
    const concreteTokenTypes = reject_default(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA);
    const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
    if (trackLines) {
      forEach_default(concreteTokenTypes, (tokType) => {
        const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
        if (currIssue !== false) {
          const message = buildLineBreakIssueMessage(tokType, currIssue);
          const warningDescriptor = {
            message,
            type: currIssue.issue,
            tokenType: tokType
          };
          warnings.push(warningDescriptor);
        } else {
          if (has_default(tokType, "LINE_BREAKS")) {
            if (tokType.LINE_BREAKS === true) {
              hasAnyLineBreak = true;
            }
          } else {
            if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {
              hasAnyLineBreak = true;
            }
          }
        }
      });
    }
    if (trackLines && !hasAnyLineBreak) {
      warnings.push({
        message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",
        type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
      });
    }
    return warnings;
  }
  function cloneEmptyGroups(emptyGroups) {
    const clonedResult = {};
    const groupKeys = keys_default(emptyGroups);
    forEach_default(groupKeys, (currKey) => {
      const currGroupValue = emptyGroups[currKey];
      if (isArray_default(currGroupValue)) {
        clonedResult[currKey] = [];
      } else {
        throw Error("non exhaustive match");
      }
    });
    return clonedResult;
  }
  function isCustomPattern(tokenType) {
    const pattern = tokenType.PATTERN;
    if (isRegExp_default(pattern)) {
      return false;
    } else if (isFunction_default(pattern)) {
      return true;
    } else if (has_default(pattern, "exec")) {
      return true;
    } else if (isString_default(pattern)) {
      return false;
    } else {
      throw Error("non exhaustive match");
    }
  }
  function isShortPattern(pattern) {
    if (isString_default(pattern) && pattern.length === 1) {
      return pattern.charCodeAt(0);
    } else {
      return false;
    }
  }
  var LineTerminatorOptimizedTester = {
    // implements /\n|\r\n?/g.test
    test: function(text) {
      const len = text.length;
      for (let i = this.lastIndex; i < len; i++) {
        const c = text.charCodeAt(i);
        if (c === 10) {
          this.lastIndex = i + 1;
          return true;
        } else if (c === 13) {
          if (text.charCodeAt(i + 1) === 10) {
            this.lastIndex = i + 2;
          } else {
            this.lastIndex = i + 1;
          }
          return true;
        }
      }
      return false;
    },
    lastIndex: 0
  };
  function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
    if (has_default(tokType, "LINE_BREAKS")) {
      return false;
    } else {
      if (isRegExp_default(tokType.PATTERN)) {
        try {
          canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);
        } catch (e) {
          return {
            issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
            errMsg: e.message
          };
        }
        return false;
      } else if (isString_default(tokType.PATTERN)) {
        return false;
      } else if (isCustomPattern(tokType)) {
        return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
      } else {
        throw Error("non exhaustive match");
      }
    }
  }
  function buildLineBreakIssueMessage(tokType, details) {
    if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
      return `Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${tokType.name}> Token Type
	 Root cause: ${details.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;
    } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
      return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${tokType.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;
    } else {
      throw Error("non exhaustive match");
    }
  }
  function getCharCodes(charsOrCodes) {
    const charCodes = map_default(charsOrCodes, (numOrString) => {
      if (isString_default(numOrString)) {
        return numOrString.charCodeAt(0);
      } else {
        return numOrString;
      }
    });
    return charCodes;
  }
  function addToMapOfArrays(map2, key, value) {
    if (map2[key] === void 0) {
      map2[key] = [value];
    } else {
      map2[key].push(value);
    }
  }
  var minOptimizationVal = 256;
  var charCodeToOptimizedIdxMap = [];
  function charCodeToOptimizedIndex(charCode) {
    return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
  }
  function initCharCodeToOptimizedIndexMap() {
    if (isEmpty_default(charCodeToOptimizedIdxMap)) {
      charCodeToOptimizedIdxMap = new Array(65536);
      for (let i = 0; i < 65536; i++) {
        charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
      }
    }
  }

  // ../node_modules/chevrotain/lib/src/scan/tokens.js
  function tokenStructuredMatcher(tokInstance, tokConstructor) {
    const instanceType = tokInstance.tokenTypeIdx;
    if (instanceType === tokConstructor.tokenTypeIdx) {
      return true;
    } else {
      return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
    }
  }
  function tokenStructuredMatcherNoCategories(token, tokType) {
    return token.tokenTypeIdx === tokType.tokenTypeIdx;
  }
  var tokenShortNameIdx = 1;
  var tokenIdxToClass = {};
  function augmentTokenTypes(tokenTypes) {
    const tokenTypesAndParents = expandCategories(tokenTypes);
    assignTokenDefaultProps(tokenTypesAndParents);
    assignCategoriesMapProp(tokenTypesAndParents);
    assignCategoriesTokensProp(tokenTypesAndParents);
    forEach_default(tokenTypesAndParents, (tokType) => {
      tokType.isParent = tokType.categoryMatches.length > 0;
    });
  }
  function expandCategories(tokenTypes) {
    let result = clone_default(tokenTypes);
    let categories = tokenTypes;
    let searching = true;
    while (searching) {
      categories = compact_default(flatten_default(map_default(categories, (currTokType) => currTokType.CATEGORIES)));
      const newCategories = difference_default(categories, result);
      result = result.concat(newCategories);
      if (isEmpty_default(newCategories)) {
        searching = false;
      } else {
        categories = newCategories;
      }
    }
    return result;
  }
  function assignTokenDefaultProps(tokenTypes) {
    forEach_default(tokenTypes, (currTokType) => {
      if (!hasShortKeyProperty(currTokType)) {
        tokenIdxToClass[tokenShortNameIdx] = currTokType;
        currTokType.tokenTypeIdx = tokenShortNameIdx++;
      }
      if (hasCategoriesProperty(currTokType) && !isArray_default(currTokType.CATEGORIES)) {
        currTokType.CATEGORIES = [currTokType.CATEGORIES];
      }
      if (!hasCategoriesProperty(currTokType)) {
        currTokType.CATEGORIES = [];
      }
      if (!hasExtendingTokensTypesProperty(currTokType)) {
        currTokType.categoryMatches = [];
      }
      if (!hasExtendingTokensTypesMapProperty(currTokType)) {
        currTokType.categoryMatchesMap = {};
      }
    });
  }
  function assignCategoriesTokensProp(tokenTypes) {
    forEach_default(tokenTypes, (currTokType) => {
      currTokType.categoryMatches = [];
      forEach_default(currTokType.categoryMatchesMap, (val, key) => {
        currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);
      });
    });
  }
  function assignCategoriesMapProp(tokenTypes) {
    forEach_default(tokenTypes, (currTokType) => {
      singleAssignCategoriesToksMap([], currTokType);
    });
  }
  function singleAssignCategoriesToksMap(path, nextNode) {
    forEach_default(path, (pathNode) => {
      nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
    });
    forEach_default(nextNode.CATEGORIES, (nextCategory) => {
      const newPath = path.concat(nextNode);
      if (!includes_default(newPath, nextCategory)) {
        singleAssignCategoriesToksMap(newPath, nextCategory);
      }
    });
  }
  function hasShortKeyProperty(tokType) {
    return has_default(tokType, "tokenTypeIdx");
  }
  function hasCategoriesProperty(tokType) {
    return has_default(tokType, "CATEGORIES");
  }
  function hasExtendingTokensTypesProperty(tokType) {
    return has_default(tokType, "categoryMatches");
  }
  function hasExtendingTokensTypesMapProperty(tokType) {
    return has_default(tokType, "categoryMatchesMap");
  }
  function isTokenType(tokType) {
    return has_default(tokType, "tokenTypeIdx");
  }

  // ../node_modules/chevrotain/lib/src/scan/lexer_errors_public.js
  var defaultLexerErrorProvider = {
    buildUnableToPopLexerModeMessage(token) {
      return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;
    },
    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {
      return `unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset}, skipped ${length} characters.`;
    }
  };

  // ../node_modules/chevrotain/lib/src/scan/lexer_public.js
  var LexerDefinitionErrorType;
  (function(LexerDefinitionErrorType2) {
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
    LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
  })(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));
  var DEFAULT_LEXER_CONFIG = {
    deferDefinitionErrorsHandling: false,
    positionTracking: "full",
    lineTerminatorsPattern: /\n|\r\n?/g,
    lineTerminatorCharacters: ["\n", "\r"],
    ensureOptimizations: false,
    safeMode: false,
    errorMessageProvider: defaultLexerErrorProvider,
    traceInitPerf: false,
    skipValidations: false,
    recoveryEnabled: true
  };
  Object.freeze(DEFAULT_LEXER_CONFIG);
  var Lexer = class {
    constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {
      this.lexerDefinition = lexerDefinition;
      this.lexerDefinitionErrors = [];
      this.lexerDefinitionWarning = [];
      this.patternIdxToConfig = {};
      this.charCodeToPatternIdxToConfig = {};
      this.modes = [];
      this.emptyGroups = {};
      this.trackStartLines = true;
      this.trackEndLines = true;
      this.hasCustom = false;
      this.canModeBeOptimized = {};
      this.TRACE_INIT = (phaseDesc, phaseImpl) => {
        if (this.traceInitPerf === true) {
          this.traceInitIndent++;
          const indent = new Array(this.traceInitIndent + 1).join("	");
          if (this.traceInitIndent < this.traceInitMaxIdent) {
            console.log(`${indent}--> <${phaseDesc}>`);
          }
          const { time, value } = timer(phaseImpl);
          const traceMethod = time > 10 ? console.warn : console.log;
          if (this.traceInitIndent < this.traceInitMaxIdent) {
            traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);
          }
          this.traceInitIndent--;
          return value;
        } else {
          return phaseImpl();
        }
      };
      if (typeof config === "boolean") {
        throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
      }
      this.config = assign_default({}, DEFAULT_LEXER_CONFIG, config);
      const traceInitVal = this.config.traceInitPerf;
      if (traceInitVal === true) {
        this.traceInitMaxIdent = Infinity;
        this.traceInitPerf = true;
      } else if (typeof traceInitVal === "number") {
        this.traceInitMaxIdent = traceInitVal;
        this.traceInitPerf = true;
      }
      this.traceInitIndent = -1;
      this.TRACE_INIT("Lexer Constructor", () => {
        let actualDefinition;
        let hasOnlySingleMode = true;
        this.TRACE_INIT("Lexer Config handling", () => {
          if (this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
            this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;
          } else {
            if (this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
              throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
            }
          }
          if (config.safeMode && config.ensureOptimizations) {
            throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
          }
          this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);
          this.trackEndLines = /full/i.test(this.config.positionTracking);
          if (isArray_default(lexerDefinition)) {
            actualDefinition = {
              modes: { defaultMode: clone_default(lexerDefinition) },
              defaultMode: DEFAULT_MODE
            };
          } else {
            hasOnlySingleMode = false;
            actualDefinition = clone_default(lexerDefinition);
          }
        });
        if (this.config.skipValidations === false) {
          this.TRACE_INIT("performRuntimeChecks", () => {
            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));
          });
          this.TRACE_INIT("performWarningRuntimeChecks", () => {
            this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));
          });
        }
        actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};
        forEach_default(actualDefinition.modes, (currModeValue, currModeName) => {
          actualDefinition.modes[currModeName] = reject_default(currModeValue, (currTokType) => isUndefined_default(currTokType));
        });
        const allModeNames = keys_default(actualDefinition.modes);
        forEach_default(actualDefinition.modes, (currModDef, currModName) => {
          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {
            this.modes.push(currModName);
            if (this.config.skipValidations === false) {
              this.TRACE_INIT(`validatePatterns`, () => {
                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));
              });
            }
            if (isEmpty_default(this.lexerDefinitionErrors)) {
              augmentTokenTypes(currModDef);
              let currAnalyzeResult;
              this.TRACE_INIT(`analyzeTokenTypes`, () => {
                currAnalyzeResult = analyzeTokenTypes(currModDef, {
                  lineTerminatorCharacters: this.config.lineTerminatorCharacters,
                  positionTracking: config.positionTracking,
                  ensureOptimizations: config.ensureOptimizations,
                  safeMode: config.safeMode,
                  tracer: this.TRACE_INIT
                });
              });
              this.patternIdxToConfig[currModName] = currAnalyzeResult.patternIdxToConfig;
              this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult.charCodeToPatternIdxToConfig;
              this.emptyGroups = assign_default({}, this.emptyGroups, currAnalyzeResult.emptyGroups);
              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;
              this.canModeBeOptimized[currModName] = currAnalyzeResult.canBeOptimized;
            }
          });
        });
        this.defaultMode = actualDefinition.defaultMode;
        if (!isEmpty_default(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {
          const allErrMessages = map_default(this.lexerDefinitionErrors, (error) => {
            return error.message;
          });
          const allErrMessagesString = allErrMessages.join("-----------------------\n");
          throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
        }
        forEach_default(this.lexerDefinitionWarning, (warningDescriptor) => {
          PRINT_WARNING(warningDescriptor.message);
        });
        this.TRACE_INIT("Choosing sub-methods implementations", () => {
          if (SUPPORT_STICKY) {
            this.chopInput = identity_default;
            this.match = this.matchWithTest;
          } else {
            this.updateLastIndex = noop_default;
            this.match = this.matchWithExec;
          }
          if (hasOnlySingleMode) {
            this.handleModes = noop_default;
          }
          if (this.trackStartLines === false) {
            this.computeNewColumn = identity_default;
          }
          if (this.trackEndLines === false) {
            this.updateTokenEndLineColumnLocation = noop_default;
          }
          if (/full/i.test(this.config.positionTracking)) {
            this.createTokenInstance = this.createFullToken;
          } else if (/onlyStart/i.test(this.config.positionTracking)) {
            this.createTokenInstance = this.createStartOnlyToken;
          } else if (/onlyOffset/i.test(this.config.positionTracking)) {
            this.createTokenInstance = this.createOffsetOnlyToken;
          } else {
            throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);
          }
          if (this.hasCustom) {
            this.addToken = this.addTokenUsingPush;
            this.handlePayload = this.handlePayloadWithCustom;
          } else {
            this.addToken = this.addTokenUsingMemberAccess;
            this.handlePayload = this.handlePayloadNoCustom;
          }
        });
        this.TRACE_INIT("Failed Optimization Warnings", () => {
          const unOptimizedModes = reduce_default(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName) => {
            if (canBeOptimized === false) {
              cannotBeOptimized.push(modeName);
            }
            return cannotBeOptimized;
          }, []);
          if (config.ensureOptimizations && !isEmpty_default(unOptimizedModes)) {
            throw Error(`Lexer Modes: < ${unOptimizedModes.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`);
          }
        });
        this.TRACE_INIT("clearRegExpParserCache", () => {
          clearRegExpParserCache();
        });
        this.TRACE_INIT("toFastProperties", () => {
          toFastProperties(this);
        });
      });
    }
    tokenize(text, initialMode = this.defaultMode) {
      if (!isEmpty_default(this.lexerDefinitionErrors)) {
        const allErrMessages = map_default(this.lexerDefinitionErrors, (error) => {
          return error.message;
        });
        const allErrMessagesString = allErrMessages.join("-----------------------\n");
        throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
      }
      return this.tokenizeInternal(text, initialMode);
    }
    // There is quite a bit of duplication between this and "tokenizeInternalLazy"
    // This is intentional due to performance considerations.
    // this method also used quite a bit of `!` none null assertions because it is too optimized
    // for `tsc` to always understand it is "safe"
    tokenizeInternal(text, initialMode) {
      let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
      const orgText = text;
      const orgLength = orgText.length;
      let offset = 0;
      let matchedTokensIndex = 0;
      const guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);
      const matchedTokens = new Array(guessedNumberOfTokens);
      const errors = [];
      let line = this.trackStartLines ? 1 : void 0;
      let column = this.trackStartLines ? 1 : void 0;
      const groups = cloneEmptyGroups(this.emptyGroups);
      const trackLines = this.trackStartLines;
      const lineTerminatorPattern = this.config.lineTerminatorsPattern;
      let currModePatternsLength = 0;
      let patternIdxToConfig = [];
      let currCharCodeToPatternIdxToConfig = [];
      const modeStack = [];
      const emptyArray = [];
      Object.freeze(emptyArray);
      let getPossiblePatterns;
      function getPossiblePatternsSlow() {
        return patternIdxToConfig;
      }
      function getPossiblePatternsOptimized(charCode) {
        const optimizedCharIdx = charCodeToOptimizedIndex(charCode);
        const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
        if (possiblePatterns === void 0) {
          return emptyArray;
        } else {
          return possiblePatterns;
        }
      }
      const pop_mode = (popToken) => {
        if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
        // So no error should occur.
        popToken.tokenType.PUSH_MODE === void 0) {
          const msg2 = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
          errors.push({
            offset: popToken.startOffset,
            line: popToken.startLine,
            column: popToken.startColumn,
            length: popToken.image.length,
            message: msg2
          });
        } else {
          modeStack.pop();
          const newMode = last_default(modeStack);
          patternIdxToConfig = this.patternIdxToConfig[newMode];
          currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
          currModePatternsLength = patternIdxToConfig.length;
          const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
          if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
            getPossiblePatterns = getPossiblePatternsOptimized;
          } else {
            getPossiblePatterns = getPossiblePatternsSlow;
          }
        }
      };
      function push_mode(newMode) {
        modeStack.push(newMode);
        currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
        patternIdxToConfig = this.patternIdxToConfig[newMode];
        currModePatternsLength = patternIdxToConfig.length;
        currModePatternsLength = patternIdxToConfig.length;
        const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
          getPossiblePatterns = getPossiblePatternsOptimized;
        } else {
          getPossiblePatterns = getPossiblePatternsSlow;
        }
      }
      push_mode.call(this, initialMode);
      let currConfig;
      const recoveryEnabled = this.config.recoveryEnabled;
      while (offset < orgLength) {
        matchedImage = null;
        const nextCharCode = orgText.charCodeAt(offset);
        const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
        const chosenPatternsLength = chosenPatternIdxToConfig.length;
        for (i = 0; i < chosenPatternsLength; i++) {
          currConfig = chosenPatternIdxToConfig[i];
          const currPattern = currConfig.pattern;
          payload = null;
          const singleCharCode = currConfig.short;
          if (singleCharCode !== false) {
            if (nextCharCode === singleCharCode) {
              matchedImage = currPattern;
            }
          } else if (currConfig.isCustom === true) {
            match = currPattern.exec(orgText, offset, matchedTokens, groups);
            if (match !== null) {
              matchedImage = match[0];
              if (match.payload !== void 0) {
                payload = match.payload;
              }
            } else {
              matchedImage = null;
            }
          } else {
            this.updateLastIndex(currPattern, offset);
            matchedImage = this.match(currPattern, text, offset);
          }
          if (matchedImage !== null) {
            longerAlt = currConfig.longerAlt;
            if (longerAlt !== void 0) {
              const longerAltLength = longerAlt.length;
              for (k = 0; k < longerAltLength; k++) {
                const longerAltConfig = patternIdxToConfig[longerAlt[k]];
                const longerAltPattern = longerAltConfig.pattern;
                altPayload = null;
                if (longerAltConfig.isCustom === true) {
                  match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                  if (match !== null) {
                    matchAltImage = match[0];
                    if (match.payload !== void 0) {
                      altPayload = match.payload;
                    }
                  } else {
                    matchAltImage = null;
                  }
                } else {
                  this.updateLastIndex(longerAltPattern, offset);
                  matchAltImage = this.match(longerAltPattern, text, offset);
                }
                if (matchAltImage && matchAltImage.length > matchedImage.length) {
                  matchedImage = matchAltImage;
                  payload = altPayload;
                  currConfig = longerAltConfig;
                  break;
                }
              }
            }
            break;
          }
        }
        if (matchedImage !== null) {
          imageLength = matchedImage.length;
          group = currConfig.group;
          if (group !== void 0) {
            tokType = currConfig.tokenTypeIdx;
            newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
            this.handlePayload(newToken, payload);
            if (group === false) {
              matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
            } else {
              groups[group].push(newToken);
            }
          }
          text = this.chopInput(text, imageLength);
          offset = offset + imageLength;
          column = this.computeNewColumn(column, imageLength);
          if (trackLines === true && currConfig.canLineTerminator === true) {
            let numOfLTsInMatch = 0;
            let foundTerminator;
            let lastLTEndOffset;
            lineTerminatorPattern.lastIndex = 0;
            do {
              foundTerminator = lineTerminatorPattern.test(matchedImage);
              if (foundTerminator === true) {
                lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                numOfLTsInMatch++;
              }
            } while (foundTerminator === true);
            if (numOfLTsInMatch !== 0) {
              line = line + numOfLTsInMatch;
              column = imageLength - lastLTEndOffset;
              this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
            }
          }
          this.handleModes(currConfig, pop_mode, push_mode, newToken);
        } else {
          const errorStartOffset = offset;
          const errorLine = line;
          const errorColumn = column;
          let foundResyncPoint = recoveryEnabled === false;
          while (foundResyncPoint === false && offset < orgLength) {
            text = this.chopInput(text, 1);
            offset++;
            for (j = 0; j < currModePatternsLength; j++) {
              const currConfig2 = patternIdxToConfig[j];
              const currPattern = currConfig2.pattern;
              const singleCharCode = currConfig2.short;
              if (singleCharCode !== false) {
                if (orgText.charCodeAt(offset) === singleCharCode) {
                  foundResyncPoint = true;
                }
              } else if (currConfig2.isCustom === true) {
                foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
              } else {
                this.updateLastIndex(currPattern, offset);
                foundResyncPoint = currPattern.exec(text) !== null;
              }
              if (foundResyncPoint === true) {
                break;
              }
            }
          }
          errLength = offset - errorStartOffset;
          column = this.computeNewColumn(column, errLength);
          msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
          errors.push({
            offset: errorStartOffset,
            line: errorLine,
            column: errorColumn,
            length: errLength,
            message: msg
          });
          if (recoveryEnabled === false) {
            break;
          }
        }
      }
      if (!this.hasCustom) {
        matchedTokens.length = matchedTokensIndex;
      }
      return {
        tokens: matchedTokens,
        groups,
        errors
      };
    }
    handleModes(config, pop_mode, push_mode, newToken) {
      if (config.pop === true) {
        const pushMode = config.push;
        pop_mode(newToken);
        if (pushMode !== void 0) {
          push_mode.call(this, pushMode);
        }
      } else if (config.push !== void 0) {
        push_mode.call(this, config.push);
      }
    }
    chopInput(text, length) {
      return text.substring(length);
    }
    updateLastIndex(regExp, newLastIndex) {
      regExp.lastIndex = newLastIndex;
    }
    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler
    updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
      let lastCharIsLT, fixForEndingInLT;
      if (group !== void 0) {
        lastCharIsLT = lastLTIdx === imageLength - 1;
        fixForEndingInLT = lastCharIsLT ? -1 : 0;
        if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
          newToken.endLine = line + fixForEndingInLT;
          newToken.endColumn = column - 1 + -fixForEndingInLT;
        }
      }
    }
    computeNewColumn(oldColumn, imageLength) {
      return oldColumn + imageLength;
    }
    createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {
      return {
        image,
        startOffset,
        tokenTypeIdx,
        tokenType
      };
    }
    createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
      return {
        image,
        startOffset,
        startLine,
        startColumn,
        tokenTypeIdx,
        tokenType
      };
    }
    createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
      return {
        image,
        startOffset,
        endOffset: startOffset + imageLength - 1,
        startLine,
        endLine: startLine,
        startColumn,
        endColumn: startColumn + imageLength - 1,
        tokenTypeIdx,
        tokenType
      };
    }
    addTokenUsingPush(tokenVector, index, tokenToAdd) {
      tokenVector.push(tokenToAdd);
      return index;
    }
    addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {
      tokenVector[index] = tokenToAdd;
      index++;
      return index;
    }
    handlePayloadNoCustom(token, payload) {
    }
    handlePayloadWithCustom(token, payload) {
      if (payload !== null) {
        token.payload = payload;
      }
    }
    matchWithTest(pattern, text, offset) {
      const found = pattern.test(text);
      if (found === true) {
        return text.substring(offset, pattern.lastIndex);
      }
      return null;
    }
    matchWithExec(pattern, text) {
      const regExpArray = pattern.exec(text);
      return regExpArray !== null ? regExpArray[0] : null;
    }
  };
  Lexer.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
  Lexer.NA = /NOT_APPLICABLE/;

  // ../node_modules/chevrotain/lib/src/scan/tokens_public.js
  function tokenLabel2(tokType) {
    if (hasTokenLabel2(tokType)) {
      return tokType.LABEL;
    } else {
      return tokType.name;
    }
  }
  function hasTokenLabel2(obj) {
    return isString_default(obj.LABEL) && obj.LABEL !== "";
  }
  var PARENT = "parent";
  var CATEGORIES = "categories";
  var LABEL = "label";
  var GROUP = "group";
  var PUSH_MODE = "push_mode";
  var POP_MODE = "pop_mode";
  var LONGER_ALT = "longer_alt";
  var LINE_BREAKS = "line_breaks";
  var START_CHARS_HINT = "start_chars_hint";
  function createToken(config) {
    return createTokenInternal(config);
  }
  function createTokenInternal(config) {
    const pattern = config.pattern;
    const tokenType = {};
    tokenType.name = config.name;
    if (!isUndefined_default(pattern)) {
      tokenType.PATTERN = pattern;
    }
    if (has_default(config, PARENT)) {
      throw "The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";
    }
    if (has_default(config, CATEGORIES)) {
      tokenType.CATEGORIES = config[CATEGORIES];
    }
    augmentTokenTypes([tokenType]);
    if (has_default(config, LABEL)) {
      tokenType.LABEL = config[LABEL];
    }
    if (has_default(config, GROUP)) {
      tokenType.GROUP = config[GROUP];
    }
    if (has_default(config, POP_MODE)) {
      tokenType.POP_MODE = config[POP_MODE];
    }
    if (has_default(config, PUSH_MODE)) {
      tokenType.PUSH_MODE = config[PUSH_MODE];
    }
    if (has_default(config, LONGER_ALT)) {
      tokenType.LONGER_ALT = config[LONGER_ALT];
    }
    if (has_default(config, LINE_BREAKS)) {
      tokenType.LINE_BREAKS = config[LINE_BREAKS];
    }
    if (has_default(config, START_CHARS_HINT)) {
      tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
    }
    return tokenType;
  }
  var EOF = createToken({ name: "EOF", pattern: Lexer.NA });
  augmentTokenTypes([EOF]);
  function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
    return {
      image,
      startOffset,
      endOffset,
      startLine,
      endLine,
      startColumn,
      endColumn,
      tokenTypeIdx: tokType.tokenTypeIdx,
      tokenType: tokType
    };
  }
  function tokenMatcher(token, tokType) {
    return tokenStructuredMatcher(token, tokType);
  }

  // ../node_modules/chevrotain/lib/src/parse/errors_public.js
  var defaultParserErrorProvider = {
    buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {
      const hasLabel = hasTokenLabel2(expected);
      const expectedMsg = hasLabel ? `--> ${tokenLabel2(expected)} <--` : `token of type --> ${expected.name} <--`;
      const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;
      return msg;
    },
    buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {
      return "Redundant input, expecting EOF but found: " + firstRedundant.image;
    },
    buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName }) {
      const errPrefix = "Expecting: ";
      const actualText = head_default(actual).image;
      const errSuffix = "\nbut found: '" + actualText + "'";
      if (customUserDescription) {
        return errPrefix + customUserDescription + errSuffix;
      } else {
        const allLookAheadPaths = reduce_default(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);
        const nextValidTokenSequences = map_default(allLookAheadPaths, (currPath) => `[${map_default(currPath, (currTokenType) => tokenLabel2(currTokenType)).join(", ")}]`);
        const nextValidSequenceItems = map_default(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);
        const calculatedDescription = `one of these possible Token sequences:
${nextValidSequenceItems.join("\n")}`;
        return errPrefix + calculatedDescription + errSuffix;
      }
    },
    buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName }) {
      const errPrefix = "Expecting: ";
      const actualText = head_default(actual).image;
      const errSuffix = "\nbut found: '" + actualText + "'";
      if (customUserDescription) {
        return errPrefix + customUserDescription + errSuffix;
      } else {
        const nextValidTokenSequences = map_default(expectedIterationPaths, (currPath) => `[${map_default(currPath, (currTokenType) => tokenLabel2(currTokenType)).join(",")}]`);
        const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::
  <${nextValidTokenSequences.join(" ,")}>`;
        return errPrefix + calculatedDescription + errSuffix;
      }
    }
  };
  Object.freeze(defaultParserErrorProvider);
  var defaultGrammarResolverErrorProvider = {
    buildRuleNotFoundError(topLevelRule, undefinedRule) {
      const msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\ninside top level rule: ->" + topLevelRule.name + "<-";
      return msg;
    }
  };
  var defaultGrammarValidatorErrorProvider = {
    buildDuplicateFoundError(topLevelRule, duplicateProds) {
      function getExtraProductionArgument2(prod) {
        if (prod instanceof Terminal) {
          return prod.terminalType.name;
        } else if (prod instanceof NonTerminal) {
          return prod.nonTerminalName;
        } else {
          return "";
        }
      }
      const topLevelName = topLevelRule.name;
      const duplicateProd = head_default(duplicateProds);
      const index = duplicateProd.idx;
      const dslName = getProductionDslName(duplicateProd);
      const extraArgument = getExtraProductionArgument2(duplicateProd);
      const hasExplicitIndex = index > 0;
      let msg = `->${dslName}${hasExplicitIndex ? index : ""}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : ""}
                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `;
      msg = msg.replace(/[ \t]+/g, " ");
      msg = msg.replace(/\s\s+/g, "\n");
      return msg;
    },
    buildNamespaceConflictError(rule) {
      const errMsg = `Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;
      return errMsg;
    },
    buildAlternationPrefixAmbiguityError(options) {
      const pathMsg = map_default(options.prefixPath, (currTok) => tokenLabel2(currTok)).join(", ");
      const occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
      const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(" ,")}> due to common lookahead prefix
in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,
<${pathMsg}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
      return errMsg;
    },
    buildAlternationAmbiguityError(options) {
      const pathMsg = map_default(options.prefixPath, (currtok) => tokenLabel2(currtok)).join(", ");
      const occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
      let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(" ,")}> in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,
<${pathMsg}> may appears as a prefix path in all these alternatives.
`;
      currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`;
      return currMessage;
    },
    buildEmptyRepetitionError(options) {
      let dslName = getProductionDslName(options.repetition);
      if (options.repetition.idx !== 0) {
        dslName += options.repetition.idx;
      }
      const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`;
      return errMsg;
    },
    // TODO: remove - `errors_public` from nyc.config.js exclude
    //       once this method is fully removed from this file
    buildTokenNameError(options) {
      return "deprecated";
    },
    buildEmptyAlternationError(options) {
      const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}> in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`;
      return errMsg;
    },
    buildTooManyAlternativesError(options) {
      const errMsg = `An Alternation cannot have more than 256 alternatives:
<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.
 has ${options.alternation.definition.length + 1} alternatives.`;
      return errMsg;
    },
    buildLeftRecursionError(options) {
      const ruleName = options.topLevelRule.name;
      const pathNames = map_default(options.leftRecursionPath, (currRule) => currRule.name);
      const leftRecursivePath = `${ruleName} --> ${pathNames.concat([ruleName]).join(" --> ")}`;
      const errMsg = `Left Recursion found in grammar.
rule: <${ruleName}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is: 
 ${leftRecursivePath}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;
      return errMsg;
    },
    // TODO: remove - `errors_public` from nyc.config.js exclude
    //       once this method is fully removed from this file
    buildInvalidRuleNameError(options) {
      return "deprecated";
    },
    buildDuplicateRuleNameError(options) {
      let ruleName;
      if (options.topLevelRule instanceof Rule) {
        ruleName = options.topLevelRule.name;
      } else {
        ruleName = options.topLevelRule;
      }
      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;
      return errMsg;
    }
  };

  // ../node_modules/chevrotain/lib/src/parse/grammar/resolver.js
  function resolveGrammar(topLevels, errMsgProvider) {
    const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
    refResolver.resolveRefs();
    return refResolver.errors;
  }
  var GastRefResolverVisitor = class extends GAstVisitor {
    constructor(nameToTopRule, errMsgProvider) {
      super();
      this.nameToTopRule = nameToTopRule;
      this.errMsgProvider = errMsgProvider;
      this.errors = [];
    }
    resolveRefs() {
      forEach_default(values_default(this.nameToTopRule), (prod) => {
        this.currTopLevel = prod;
        prod.accept(this);
      });
    }
    visitNonTerminal(node) {
      const ref = this.nameToTopRule[node.nonTerminalName];
      if (!ref) {
        const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
        this.errors.push({
          message: msg,
          type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
          ruleName: this.currTopLevel.name,
          unresolvedRefName: node.nonTerminalName
        });
      } else {
        node.referencedRule = ref;
      }
    }
  };

  // ../node_modules/chevrotain/lib/src/parse/grammar/interpreter.js
  var AbstractNextPossibleTokensWalker = class extends RestWalker {
    constructor(topProd, path) {
      super();
      this.topProd = topProd;
      this.path = path;
      this.possibleTokTypes = [];
      this.nextProductionName = "";
      this.nextProductionOccurrence = 0;
      this.found = false;
      this.isAtEndOfPath = false;
    }
    startWalking() {
      this.found = false;
      if (this.path.ruleStack[0] !== this.topProd.name) {
        throw Error("The path does not start with the walker's top Rule!");
      }
      this.ruleStack = clone_default(this.path.ruleStack).reverse();
      this.occurrenceStack = clone_default(this.path.occurrenceStack).reverse();
      this.ruleStack.pop();
      this.occurrenceStack.pop();
      this.updateExpectedNext();
      this.walk(this.topProd);
      return this.possibleTokTypes;
    }
    walk(prod, prevRest = []) {
      if (!this.found) {
        super.walk(prod, prevRest);
      }
    }
    walkProdRef(refProd, currRest, prevRest) {
      if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
        const fullRest = currRest.concat(prevRest);
        this.updateExpectedNext();
        this.walk(refProd.referencedRule, fullRest);
      }
    }
    updateExpectedNext() {
      if (isEmpty_default(this.ruleStack)) {
        this.nextProductionName = "";
        this.nextProductionOccurrence = 0;
        this.isAtEndOfPath = true;
      } else {
        this.nextProductionName = this.ruleStack.pop();
        this.nextProductionOccurrence = this.occurrenceStack.pop();
      }
    }
  };
  var NextAfterTokenWalker = class extends AbstractNextPossibleTokensWalker {
    constructor(topProd, path) {
      super(topProd, path);
      this.path = path;
      this.nextTerminalName = "";
      this.nextTerminalOccurrence = 0;
      this.nextTerminalName = this.path.lastTok.name;
      this.nextTerminalOccurrence = this.path.lastTokOccurrence;
    }
    walkTerminal(terminal, currRest, prevRest) {
      if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
        const fullRest = currRest.concat(prevRest);
        const restProd = new Alternative({ definition: fullRest });
        this.possibleTokTypes = first(restProd);
        this.found = true;
      }
    }
  };
  var AbstractNextTerminalAfterProductionWalker = class extends RestWalker {
    constructor(topRule, occurrence) {
      super();
      this.topRule = topRule;
      this.occurrence = occurrence;
      this.result = {
        token: void 0,
        occurrence: void 0,
        isEndOfRule: void 0
      };
    }
    startWalking() {
      this.walk(this.topRule);
      return this.result;
    }
  };
  var NextTerminalAfterManyWalker = class extends AbstractNextTerminalAfterProductionWalker {
    walkMany(manyProd, currRest, prevRest) {
      if (manyProd.idx === this.occurrence) {
        const firstAfterMany = head_default(currRest.concat(prevRest));
        this.result.isEndOfRule = firstAfterMany === void 0;
        if (firstAfterMany instanceof Terminal) {
          this.result.token = firstAfterMany.terminalType;
          this.result.occurrence = firstAfterMany.idx;
        }
      } else {
        super.walkMany(manyProd, currRest, prevRest);
      }
    }
  };
  var NextTerminalAfterManySepWalker = class extends AbstractNextTerminalAfterProductionWalker {
    walkManySep(manySepProd, currRest, prevRest) {
      if (manySepProd.idx === this.occurrence) {
        const firstAfterManySep = head_default(currRest.concat(prevRest));
        this.result.isEndOfRule = firstAfterManySep === void 0;
        if (firstAfterManySep instanceof Terminal) {
          this.result.token = firstAfterManySep.terminalType;
          this.result.occurrence = firstAfterManySep.idx;
        }
      } else {
        super.walkManySep(manySepProd, currRest, prevRest);
      }
    }
  };
  var NextTerminalAfterAtLeastOneWalker = class extends AbstractNextTerminalAfterProductionWalker {
    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {
      if (atLeastOneProd.idx === this.occurrence) {
        const firstAfterAtLeastOne = head_default(currRest.concat(prevRest));
        this.result.isEndOfRule = firstAfterAtLeastOne === void 0;
        if (firstAfterAtLeastOne instanceof Terminal) {
          this.result.token = firstAfterAtLeastOne.terminalType;
          this.result.occurrence = firstAfterAtLeastOne.idx;
        }
      } else {
        super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);
      }
    }
  };
  var NextTerminalAfterAtLeastOneSepWalker = class extends AbstractNextTerminalAfterProductionWalker {
    walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {
      if (atleastOneSepProd.idx === this.occurrence) {
        const firstAfterfirstAfterAtLeastOneSep = head_default(currRest.concat(prevRest));
        this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;
        if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {
          this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
          this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
        }
      } else {
        super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);
      }
    }
  };
  function possiblePathsFrom(targetDef, maxLength, currPath = []) {
    currPath = clone_default(currPath);
    let result = [];
    let i = 0;
    function remainingPathWith(nextDef) {
      return nextDef.concat(drop_default(targetDef, i + 1));
    }
    function getAlternativesForProd(definition) {
      const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
      return result.concat(alternatives);
    }
    while (currPath.length < maxLength && i < targetDef.length) {
      const prod = targetDef[i];
      if (prod instanceof Alternative) {
        return getAlternativesForProd(prod.definition);
      } else if (prod instanceof NonTerminal) {
        return getAlternativesForProd(prod.definition);
      } else if (prod instanceof Option) {
        result = getAlternativesForProd(prod.definition);
      } else if (prod instanceof RepetitionMandatory) {
        const newDef = prod.definition.concat([
          new Repetition({
            definition: prod.definition
          })
        ]);
        return getAlternativesForProd(newDef);
      } else if (prod instanceof RepetitionMandatoryWithSeparator) {
        const newDef = [
          new Alternative({ definition: prod.definition }),
          new Repetition({
            definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)
          })
        ];
        return getAlternativesForProd(newDef);
      } else if (prod instanceof RepetitionWithSeparator) {
        const newDef = prod.definition.concat([
          new Repetition({
            definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)
          })
        ]);
        result = getAlternativesForProd(newDef);
      } else if (prod instanceof Repetition) {
        const newDef = prod.definition.concat([
          new Repetition({
            definition: prod.definition
          })
        ]);
        result = getAlternativesForProd(newDef);
      } else if (prod instanceof Alternation) {
        forEach_default(prod.definition, (currAlt) => {
          if (isEmpty_default(currAlt.definition) === false) {
            result = getAlternativesForProd(currAlt.definition);
          }
        });
        return result;
      } else if (prod instanceof Terminal) {
        currPath.push(prod.terminalType);
      } else {
        throw Error("non exhaustive match");
      }
      i++;
    }
    result.push({
      partialPath: currPath,
      suffixDef: drop_default(targetDef, i)
    });
    return result;
  }
  function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
    const EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
    const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
    const EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
    let foundCompletePath = false;
    const tokenVectorLength = tokenVector.length;
    const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
    const result = [];
    const possiblePaths = [];
    possiblePaths.push({
      idx: -1,
      def: initialDef,
      ruleStack: [],
      occurrenceStack: []
    });
    while (!isEmpty_default(possiblePaths)) {
      const currPath = possiblePaths.pop();
      if (currPath === EXIT_ALTERNATIVE) {
        if (foundCompletePath && last_default(possiblePaths).idx <= minimalAlternativesIndex) {
          possiblePaths.pop();
        }
        continue;
      }
      const currDef = currPath.def;
      const currIdx = currPath.idx;
      const currRuleStack = currPath.ruleStack;
      const currOccurrenceStack = currPath.occurrenceStack;
      if (isEmpty_default(currDef)) {
        continue;
      }
      const prod = currDef[0];
      if (prod === EXIT_NON_TERMINAL) {
        const nextPath = {
          idx: currIdx,
          def: drop_default(currDef),
          ruleStack: dropRight_default(currRuleStack),
          occurrenceStack: dropRight_default(currOccurrenceStack)
        };
        possiblePaths.push(nextPath);
      } else if (prod instanceof Terminal) {
        if (currIdx < tokenVectorLength - 1) {
          const nextIdx = currIdx + 1;
          const actualToken = tokenVector[nextIdx];
          if (tokMatcher(actualToken, prod.terminalType)) {
            const nextPath = {
              idx: nextIdx,
              def: drop_default(currDef),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
          }
        } else if (currIdx === tokenVectorLength - 1) {
          result.push({
            nextTokenType: prod.terminalType,
            nextTokenOccurrence: prod.idx,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          });
          foundCompletePath = true;
        } else {
          throw Error("non exhaustive match");
        }
      } else if (prod instanceof NonTerminal) {
        const newRuleStack = clone_default(currRuleStack);
        newRuleStack.push(prod.nonTerminalName);
        const newOccurrenceStack = clone_default(currOccurrenceStack);
        newOccurrenceStack.push(prod.idx);
        const nextPath = {
          idx: currIdx,
          def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop_default(currDef)),
          ruleStack: newRuleStack,
          occurrenceStack: newOccurrenceStack
        };
        possiblePaths.push(nextPath);
      } else if (prod instanceof Option) {
        const nextPathWithout = {
          idx: currIdx,
          def: drop_default(currDef),
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        };
        possiblePaths.push(nextPathWithout);
        possiblePaths.push(EXIT_ALTERNATIVE);
        const nextPathWith = {
          idx: currIdx,
          def: prod.definition.concat(drop_default(currDef)),
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        };
        possiblePaths.push(nextPathWith);
      } else if (prod instanceof RepetitionMandatory) {
        const secondIteration = new Repetition({
          definition: prod.definition,
          idx: prod.idx
        });
        const nextDef = prod.definition.concat([secondIteration], drop_default(currDef));
        const nextPath = {
          idx: currIdx,
          def: nextDef,
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        };
        possiblePaths.push(nextPath);
      } else if (prod instanceof RepetitionMandatoryWithSeparator) {
        const separatorGast = new Terminal({
          terminalType: prod.separator
        });
        const secondIteration = new Repetition({
          definition: [separatorGast].concat(prod.definition),
          idx: prod.idx
        });
        const nextDef = prod.definition.concat([secondIteration], drop_default(currDef));
        const nextPath = {
          idx: currIdx,
          def: nextDef,
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        };
        possiblePaths.push(nextPath);
      } else if (prod instanceof RepetitionWithSeparator) {
        const nextPathWithout = {
          idx: currIdx,
          def: drop_default(currDef),
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        };
        possiblePaths.push(nextPathWithout);
        possiblePaths.push(EXIT_ALTERNATIVE);
        const separatorGast = new Terminal({
          terminalType: prod.separator
        });
        const nthRepetition = new Repetition({
          definition: [separatorGast].concat(prod.definition),
          idx: prod.idx
        });
        const nextDef = prod.definition.concat([nthRepetition], drop_default(currDef));
        const nextPathWith = {
          idx: currIdx,
          def: nextDef,
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        };
        possiblePaths.push(nextPathWith);
      } else if (prod instanceof Repetition) {
        const nextPathWithout = {
          idx: currIdx,
          def: drop_default(currDef),
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        };
        possiblePaths.push(nextPathWithout);
        possiblePaths.push(EXIT_ALTERNATIVE);
        const nthRepetition = new Repetition({
          definition: prod.definition,
          idx: prod.idx
        });
        const nextDef = prod.definition.concat([nthRepetition], drop_default(currDef));
        const nextPathWith = {
          idx: currIdx,
          def: nextDef,
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        };
        possiblePaths.push(nextPathWith);
      } else if (prod instanceof Alternation) {
        for (let i = prod.definition.length - 1; i >= 0; i--) {
          const currAlt = prod.definition[i];
          const currAltPath = {
            idx: currIdx,
            def: currAlt.definition.concat(drop_default(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(currAltPath);
          possiblePaths.push(EXIT_ALTERNATIVE);
        }
      } else if (prod instanceof Alternative) {
        possiblePaths.push({
          idx: currIdx,
          def: prod.definition.concat(drop_default(currDef)),
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        });
      } else if (prod instanceof Rule) {
        possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
      } else {
        throw Error("non exhaustive match");
      }
    }
    return result;
  }
  function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
    const newRuleStack = clone_default(currRuleStack);
    newRuleStack.push(topRule.name);
    const newCurrOccurrenceStack = clone_default(currOccurrenceStack);
    newCurrOccurrenceStack.push(1);
    return {
      idx: currIdx,
      def: topRule.definition,
      ruleStack: newRuleStack,
      occurrenceStack: newCurrOccurrenceStack
    };
  }

  // ../node_modules/chevrotain/lib/src/parse/grammar/lookahead.js
  var PROD_TYPE;
  (function(PROD_TYPE2) {
    PROD_TYPE2[PROD_TYPE2["OPTION"] = 0] = "OPTION";
    PROD_TYPE2[PROD_TYPE2["REPETITION"] = 1] = "REPETITION";
    PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
    PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
    PROD_TYPE2[PROD_TYPE2["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
    PROD_TYPE2[PROD_TYPE2["ALTERNATION"] = 5] = "ALTERNATION";
  })(PROD_TYPE || (PROD_TYPE = {}));
  function getProdType(prod) {
    if (prod instanceof Option || prod === "Option") {
      return PROD_TYPE.OPTION;
    } else if (prod instanceof Repetition || prod === "Repetition") {
      return PROD_TYPE.REPETITION;
    } else if (prod instanceof RepetitionMandatory || prod === "RepetitionMandatory") {
      return PROD_TYPE.REPETITION_MANDATORY;
    } else if (prod instanceof RepetitionMandatoryWithSeparator || prod === "RepetitionMandatoryWithSeparator") {
      return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
    } else if (prod instanceof RepetitionWithSeparator || prod === "RepetitionWithSeparator") {
      return PROD_TYPE.REPETITION_WITH_SEPARATOR;
    } else if (prod instanceof Alternation || prod === "Alternation") {
      return PROD_TYPE.ALTERNATION;
    } else {
      throw Error("non exhaustive match");
    }
  }
  function getLookaheadPaths(options) {
    const { occurrence, rule, prodType, maxLookahead } = options;
    const type = getProdType(prodType);
    if (type === PROD_TYPE.ALTERNATION) {
      return getLookaheadPathsForOr(occurrence, rule, maxLookahead);
    } else {
      return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);
    }
  }
  function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
    const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
    const tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;
    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);
  }
  function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
    const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
    const tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;
    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);
  }
  function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {
    const numOfAlts = alts.length;
    const areAllOneTokenLookahead = every_default(alts, (currAlt) => {
      return every_default(currAlt, (currPath) => {
        return currPath.length === 1;
      });
    });
    if (hasPredicates) {
      return function(orAlts) {
        const predicates = map_default(orAlts, (currAlt) => currAlt.GATE);
        for (let t = 0; t < numOfAlts; t++) {
          const currAlt = alts[t];
          const currNumOfPaths = currAlt.length;
          const currPredicate = predicates[t];
          if (currPredicate !== void 0 && currPredicate.call(this) === false) {
            continue;
          }
          nextPath:
            for (let j = 0; j < currNumOfPaths; j++) {
              const currPath = currAlt[j];
              const currPathLength = currPath.length;
              for (let i = 0; i < currPathLength; i++) {
                const nextToken = this.LA(i + 1);
                if (tokenMatcher2(nextToken, currPath[i]) === false) {
                  continue nextPath;
                }
              }
              return t;
            }
        }
        return void 0;
      };
    } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
      const singleTokenAlts = map_default(alts, (currAlt) => {
        return flatten_default(currAlt);
      });
      const choiceToAlt = reduce_default(singleTokenAlts, (result, currAlt, idx) => {
        forEach_default(currAlt, (currTokType) => {
          if (!has_default(result, currTokType.tokenTypeIdx)) {
            result[currTokType.tokenTypeIdx] = idx;
          }
          forEach_default(currTokType.categoryMatches, (currExtendingType) => {
            if (!has_default(result, currExtendingType)) {
              result[currExtendingType] = idx;
            }
          });
        });
        return result;
      }, {});
      return function() {
        const nextToken = this.LA(1);
        return choiceToAlt[nextToken.tokenTypeIdx];
      };
    } else {
      return function() {
        for (let t = 0; t < numOfAlts; t++) {
          const currAlt = alts[t];
          const currNumOfPaths = currAlt.length;
          nextPath:
            for (let j = 0; j < currNumOfPaths; j++) {
              const currPath = currAlt[j];
              const currPathLength = currPath.length;
              for (let i = 0; i < currPathLength; i++) {
                const nextToken = this.LA(i + 1);
                if (tokenMatcher2(nextToken, currPath[i]) === false) {
                  continue nextPath;
                }
              }
              return t;
            }
        }
        return void 0;
      };
    }
  }
  function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {
    const areAllOneTokenLookahead = every_default(alt, (currPath) => {
      return currPath.length === 1;
    });
    const numOfPaths = alt.length;
    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
      const singleTokensTypes = flatten_default(alt);
      if (singleTokensTypes.length === 1 && isEmpty_default(singleTokensTypes[0].categoryMatches)) {
        const expectedTokenType = singleTokensTypes[0];
        const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;
        return function() {
          return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;
        };
      } else {
        const choiceToAlt = reduce_default(singleTokensTypes, (result, currTokType, idx) => {
          result[currTokType.tokenTypeIdx] = true;
          forEach_default(currTokType.categoryMatches, (currExtendingType) => {
            result[currExtendingType] = true;
          });
          return result;
        }, []);
        return function() {
          const nextToken = this.LA(1);
          return choiceToAlt[nextToken.tokenTypeIdx] === true;
        };
      }
    } else {
      return function() {
        nextPath:
          for (let j = 0; j < numOfPaths; j++) {
            const currPath = alt[j];
            const currPathLength = currPath.length;
            for (let i = 0; i < currPathLength; i++) {
              const nextToken = this.LA(i + 1);
              if (tokenMatcher2(nextToken, currPath[i]) === false) {
                continue nextPath;
              }
            }
            return true;
          }
        return false;
      };
    }
  }
  var RestDefinitionFinderWalker = class extends RestWalker {
    constructor(topProd, targetOccurrence, targetProdType) {
      super();
      this.topProd = topProd;
      this.targetOccurrence = targetOccurrence;
      this.targetProdType = targetProdType;
    }
    startWalking() {
      this.walk(this.topProd);
      return this.restDef;
    }
    checkIsTarget(node, expectedProdType, currRest, prevRest) {
      if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
        this.restDef = currRest.concat(prevRest);
        return true;
      }
      return false;
    }
    walkOption(optionProd, currRest, prevRest) {
      if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
        super.walkOption(optionProd, currRest, prevRest);
      }
    }
    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {
      if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
        super.walkOption(atLeastOneProd, currRest, prevRest);
      }
    }
    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {
      if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
        super.walkOption(atLeastOneSepProd, currRest, prevRest);
      }
    }
    walkMany(manyProd, currRest, prevRest) {
      if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
        super.walkOption(manyProd, currRest, prevRest);
      }
    }
    walkManySep(manySepProd, currRest, prevRest) {
      if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
        super.walkOption(manySepProd, currRest, prevRest);
      }
    }
  };
  var InsideDefinitionFinderVisitor = class extends GAstVisitor {
    constructor(targetOccurrence, targetProdType, targetRef) {
      super();
      this.targetOccurrence = targetOccurrence;
      this.targetProdType = targetProdType;
      this.targetRef = targetRef;
      this.result = [];
    }
    checkIsTarget(node, expectedProdName) {
      if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {
        this.result = node.definition;
      }
    }
    visitOption(node) {
      this.checkIsTarget(node, PROD_TYPE.OPTION);
    }
    visitRepetition(node) {
      this.checkIsTarget(node, PROD_TYPE.REPETITION);
    }
    visitRepetitionMandatory(node) {
      this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
    }
    visitRepetitionMandatoryWithSeparator(node) {
      this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
    }
    visitRepetitionWithSeparator(node) {
      this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
    }
    visitAlternation(node) {
      this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
    }
  };
  function initializeArrayOfArrays(size) {
    const result = new Array(size);
    for (let i = 0; i < size; i++) {
      result[i] = [];
    }
    return result;
  }
  function pathToHashKeys(path) {
    let keys2 = [""];
    for (let i = 0; i < path.length; i++) {
      const tokType = path[i];
      const longerKeys = [];
      for (let j = 0; j < keys2.length; j++) {
        const currShorterKey = keys2[j];
        longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
        for (let t = 0; t < tokType.categoryMatches.length; t++) {
          const categoriesKeySuffix = "_" + tokType.categoryMatches[t];
          longerKeys.push(currShorterKey + categoriesKeySuffix);
        }
      }
      keys2 = longerKeys;
    }
    return keys2;
  }
  function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
    for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
      if (currAltIdx === idx) {
        continue;
      }
      const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
      for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
        const searchKey = searchPathKeys[searchIdx];
        if (otherAltKnownPathsKeys[searchKey] === true) {
          return false;
        }
      }
    }
    return true;
  }
  function lookAheadSequenceFromAlternatives(altsDefs, k) {
    const partialAlts = map_default(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1));
    const finalResult = initializeArrayOfArrays(partialAlts.length);
    const altsHashes = map_default(partialAlts, (currAltPaths) => {
      const dict = {};
      forEach_default(currAltPaths, (item) => {
        const keys2 = pathToHashKeys(item.partialPath);
        forEach_default(keys2, (currKey) => {
          dict[currKey] = true;
        });
      });
      return dict;
    });
    let newData = partialAlts;
    for (let pathLength = 1; pathLength <= k; pathLength++) {
      const currDataset = newData;
      newData = initializeArrayOfArrays(currDataset.length);
      for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {
        const currAltPathsAndSuffixes = currDataset[altIdx];
        for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
          const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
          const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
          const prefixKeys = pathToHashKeys(currPathPrefix);
          const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);
          if (isUnique || isEmpty_default(suffixDef) || currPathPrefix.length === k) {
            const currAltResult = finalResult[altIdx];
            if (containsPath(currAltResult, currPathPrefix) === false) {
              currAltResult.push(currPathPrefix);
              for (let j = 0; j < prefixKeys.length; j++) {
                const currKey = prefixKeys[j];
                altsHashes[altIdx][currKey] = true;
              }
            }
          } else {
            const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);
            newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);
            forEach_default(newPartialPathsAndSuffixes, (item) => {
              const prefixKeys2 = pathToHashKeys(item.partialPath);
              forEach_default(prefixKeys2, (key) => {
                altsHashes[altIdx][key] = true;
              });
            });
          }
        }
      }
    }
    return finalResult;
  }
  function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
    const visitor2 = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
    ruleGrammar.accept(visitor2);
    return lookAheadSequenceFromAlternatives(visitor2.result, k);
  }
  function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
    const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
    ruleGrammar.accept(insideDefVisitor);
    const insideDef = insideDefVisitor.result;
    const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
    const afterDef = afterDefWalker.startWalking();
    const insideFlat = new Alternative({ definition: insideDef });
    const afterFlat = new Alternative({ definition: afterDef });
    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
  }
  function containsPath(alternative, searchPath) {
    compareOtherPath:
      for (let i = 0; i < alternative.length; i++) {
        const otherPath = alternative[i];
        if (otherPath.length !== searchPath.length) {
          continue;
        }
        for (let j = 0; j < otherPath.length; j++) {
          const searchTok = searchPath[j];
          const otherTok = otherPath[j];
          const matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;
          if (matchingTokens === false) {
            continue compareOtherPath;
          }
        }
        return true;
      }
    return false;
  }
  function isStrictPrefixOfPath(prefix, other) {
    return prefix.length < other.length && every_default(prefix, (tokType, idx) => {
      const otherTokType = other[idx];
      return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
    });
  }
  function areTokenCategoriesNotUsed(lookAheadPaths) {
    return every_default(lookAheadPaths, (singleAltPaths) => every_default(singleAltPaths, (singlePath) => every_default(singlePath, (token) => isEmpty_default(token.categoryMatches))));
  }

  // ../node_modules/chevrotain/lib/src/parse/grammar/checks.js
  function validateLookahead(options) {
    const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({
      rules: options.rules,
      tokenTypes: options.tokenTypes,
      grammarName: options.grammarName
    });
    return map_default(lookaheadValidationErrorMessages, (errorMessage) => Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage));
  }
  function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {
    const duplicateErrors = flatMap_default(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));
    const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
    const tooManyAltsErrors = flatMap_default(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));
    const duplicateRulesError = flatMap_default(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));
    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);
  }
  function validateDuplicateProductions(topLevelRule, errMsgProvider) {
    const collectorVisitor2 = new OccurrenceValidationCollector();
    topLevelRule.accept(collectorVisitor2);
    const allRuleProductions = collectorVisitor2.allProductions;
    const productionGroups = groupBy_default(allRuleProductions, identifyProductionForDuplicates);
    const duplicates = pickBy_default(productionGroups, (currGroup) => {
      return currGroup.length > 1;
    });
    const errors = map_default(values_default(duplicates), (currDuplicates) => {
      const firstProd = head_default(currDuplicates);
      const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
      const dslName = getProductionDslName(firstProd);
      const defError = {
        message: msg,
        type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
        ruleName: topLevelRule.name,
        dslName,
        occurrence: firstProd.idx
      };
      const param = getExtraProductionArgument(firstProd);
      if (param) {
        defError.parameter = param;
      }
      return defError;
    });
    return errors;
  }
  function identifyProductionForDuplicates(prod) {
    return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;
  }
  function getExtraProductionArgument(prod) {
    if (prod instanceof Terminal) {
      return prod.terminalType.name;
    } else if (prod instanceof NonTerminal) {
      return prod.nonTerminalName;
    } else {
      return "";
    }
  }
  var OccurrenceValidationCollector = class extends GAstVisitor {
    constructor() {
      super(...arguments);
      this.allProductions = [];
    }
    visitNonTerminal(subrule) {
      this.allProductions.push(subrule);
    }
    visitOption(option2) {
      this.allProductions.push(option2);
    }
    visitRepetitionWithSeparator(manySep) {
      this.allProductions.push(manySep);
    }
    visitRepetitionMandatory(atLeastOne) {
      this.allProductions.push(atLeastOne);
    }
    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {
      this.allProductions.push(atLeastOneSep);
    }
    visitRepetition(many) {
      this.allProductions.push(many);
    }
    visitAlternation(or) {
      this.allProductions.push(or);
    }
    visitTerminal(terminal) {
      this.allProductions.push(terminal);
    }
  };
  function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
    const errors = [];
    const occurrences = reduce_default(allRules, (result, curRule) => {
      if (curRule.name === rule.name) {
        return result + 1;
      }
      return result;
    }, 0);
    if (occurrences > 1) {
      const errMsg = errMsgProvider.buildDuplicateRuleNameError({
        topLevelRule: rule,
        grammarName: className
      });
      errors.push({
        message: errMsg,
        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
        ruleName: rule.name
      });
    }
    return errors;
  }
  function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
    const errors = [];
    let errMsg;
    if (!includes_default(definedRulesNames, ruleName)) {
      errMsg = `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-as it is not defined in any of the super grammars `;
      errors.push({
        message: errMsg,
        type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
        ruleName
      });
    }
    return errors;
  }
  function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {
    const errors = [];
    const nextNonTerminals = getFirstNoneTerminal(currRule.definition);
    if (isEmpty_default(nextNonTerminals)) {
      return [];
    } else {
      const ruleName = topRule.name;
      const foundLeftRecursion = includes_default(nextNonTerminals, topRule);
      if (foundLeftRecursion) {
        errors.push({
          message: errMsgProvider.buildLeftRecursionError({
            topLevelRule: topRule,
            leftRecursionPath: path
          }),
          type: ParserDefinitionErrorType.LEFT_RECURSION,
          ruleName
        });
      }
      const validNextSteps = difference_default(nextNonTerminals, path.concat([topRule]));
      const errorsFromNextSteps = flatMap_default(validNextSteps, (currRefRule) => {
        const newPath = clone_default(path);
        newPath.push(currRefRule);
        return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
      });
      return errors.concat(errorsFromNextSteps);
    }
  }
  function getFirstNoneTerminal(definition) {
    let result = [];
    if (isEmpty_default(definition)) {
      return result;
    }
    const firstProd = head_default(definition);
    if (firstProd instanceof NonTerminal) {
      result.push(firstProd.referencedRule);
    } else if (firstProd instanceof Alternative || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {
      result = result.concat(getFirstNoneTerminal(firstProd.definition));
    } else if (firstProd instanceof Alternation) {
      result = flatten_default(map_default(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));
    } else if (firstProd instanceof Terminal) {
    } else {
      throw Error("non exhaustive match");
    }
    const isFirstOptional = isOptionalProd(firstProd);
    const hasMore = definition.length > 1;
    if (isFirstOptional && hasMore) {
      const rest = drop_default(definition);
      return result.concat(getFirstNoneTerminal(rest));
    } else {
      return result;
    }
  }
  var OrCollector = class extends GAstVisitor {
    constructor() {
      super(...arguments);
      this.alternations = [];
    }
    visitAlternation(node) {
      this.alternations.push(node);
    }
  };
  function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
    const orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    const ors = orCollector.alternations;
    const errors = flatMap_default(ors, (currOr) => {
      const exceptLast = dropRight_default(currOr.definition);
      return flatMap_default(exceptLast, (currAlternative, currAltIdx) => {
        const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);
        if (isEmpty_default(possibleFirstInAlt)) {
          return [
            {
              message: errMsgProvider.buildEmptyAlternationError({
                topLevelRule,
                alternation: currOr,
                emptyChoiceIdx: currAltIdx
              }),
              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
              ruleName: topLevelRule.name,
              occurrence: currOr.idx,
              alternative: currAltIdx + 1
            }
          ];
        } else {
          return [];
        }
      });
    });
    return errors;
  }
  function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
    const orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    let ors = orCollector.alternations;
    ors = reject_default(ors, (currOr) => currOr.ignoreAmbiguities === true);
    const errors = flatMap_default(ors, (currOr) => {
      const currOccurrence = currOr.idx;
      const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
      const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
      const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
      const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
      return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);
    });
    return errors;
  }
  var RepetitionCollector = class extends GAstVisitor {
    constructor() {
      super(...arguments);
      this.allProductions = [];
    }
    visitRepetitionWithSeparator(manySep) {
      this.allProductions.push(manySep);
    }
    visitRepetitionMandatory(atLeastOne) {
      this.allProductions.push(atLeastOne);
    }
    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {
      this.allProductions.push(atLeastOneSep);
    }
    visitRepetition(many) {
      this.allProductions.push(many);
    }
  };
  function validateTooManyAlts(topLevelRule, errMsgProvider) {
    const orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    const ors = orCollector.alternations;
    const errors = flatMap_default(ors, (currOr) => {
      if (currOr.definition.length > 255) {
        return [
          {
            message: errMsgProvider.buildTooManyAlternativesError({
              topLevelRule,
              alternation: currOr
            }),
            type: ParserDefinitionErrorType.TOO_MANY_ALTS,
            ruleName: topLevelRule.name,
            occurrence: currOr.idx
          }
        ];
      } else {
        return [];
      }
    });
    return errors;
  }
  function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
    const errors = [];
    forEach_default(topLevelRules, (currTopRule) => {
      const collectorVisitor2 = new RepetitionCollector();
      currTopRule.accept(collectorVisitor2);
      const allRuleProductions = collectorVisitor2.allProductions;
      forEach_default(allRuleProductions, (currProd) => {
        const prodType = getProdType(currProd);
        const actualMaxLookahead = currProd.maxLookahead || maxLookahead;
        const currOccurrence = currProd.idx;
        const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);
        const pathsInsideProduction = paths[0];
        if (isEmpty_default(flatten_default(pathsInsideProduction))) {
          const errMsg = errMsgProvider.buildEmptyRepetitionError({
            topLevelRule: currTopRule,
            repetition: currProd
          });
          errors.push({
            message: errMsg,
            type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
            ruleName: currTopRule.name
          });
        }
      });
    });
    return errors;
  }
  function checkAlternativesAmbiguities(alternatives, alternation2, rule, errMsgProvider) {
    const foundAmbiguousPaths = [];
    const identicalAmbiguities = reduce_default(alternatives, (result, currAlt, currAltIdx) => {
      if (alternation2.definition[currAltIdx].ignoreAmbiguities === true) {
        return result;
      }
      forEach_default(currAlt, (currPath) => {
        const altsCurrPathAppearsIn = [currAltIdx];
        forEach_default(alternatives, (currOtherAlt, currOtherAltIdx) => {
          if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) && // ignore (skip) ambiguities with this "other" alternative
          alternation2.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
            altsCurrPathAppearsIn.push(currOtherAltIdx);
          }
        });
        if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {
          foundAmbiguousPaths.push(currPath);
          result.push({
            alts: altsCurrPathAppearsIn,
            path: currPath
          });
        }
      });
      return result;
    }, []);
    const currErrors = map_default(identicalAmbiguities, (currAmbDescriptor) => {
      const ambgIndices = map_default(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);
      const currMessage = errMsgProvider.buildAlternationAmbiguityError({
        topLevelRule: rule,
        alternation: alternation2,
        ambiguityIndices: ambgIndices,
        prefixPath: currAmbDescriptor.path
      });
      return {
        message: currMessage,
        type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,
        ruleName: rule.name,
        occurrence: alternation2.idx,
        alternatives: currAmbDescriptor.alts
      };
    });
    return currErrors;
  }
  function checkPrefixAlternativesAmbiguities(alternatives, alternation2, rule, errMsgProvider) {
    const pathsAndIndices = reduce_default(alternatives, (result, currAlt, idx) => {
      const currPathsAndIdx = map_default(currAlt, (currPath) => {
        return { idx, path: currPath };
      });
      return result.concat(currPathsAndIdx);
    }, []);
    const errors = compact_default(flatMap_default(pathsAndIndices, (currPathAndIdx) => {
      const alternativeGast = alternation2.definition[currPathAndIdx.idx];
      if (alternativeGast.ignoreAmbiguities === true) {
        return [];
      }
      const targetIdx = currPathAndIdx.idx;
      const targetPath = currPathAndIdx.path;
      const prefixAmbiguitiesPathsAndIndices = filter_default(pathsAndIndices, (searchPathAndIdx) => {
        return (
          // ignore (skip) ambiguities with this "other" alternative
          alternation2.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads
          // will be be detected using a different validation.
          isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)
        );
      });
      const currPathPrefixErrors = map_default(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {
        const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
        const occurrence = alternation2.idx === 0 ? "" : alternation2.idx;
        const message = errMsgProvider.buildAlternationPrefixAmbiguityError({
          topLevelRule: rule,
          alternation: alternation2,
          ambiguityIndices: ambgIndices,
          prefixPath: currAmbPathAndIdx.path
        });
        return {
          message,
          type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
          ruleName: rule.name,
          occurrence,
          alternatives: ambgIndices
        };
      });
      return currPathPrefixErrors;
    }));
    return errors;
  }
  function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
    const errors = [];
    const tokenNames = map_default(tokenTypes, (currToken) => currToken.name);
    forEach_default(topLevels, (currRule) => {
      const currRuleName = currRule.name;
      if (includes_default(tokenNames, currRuleName)) {
        const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
        errors.push({
          message: errMsg,
          type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
          ruleName: currRuleName
        });
      }
    });
    return errors;
  }

  // ../node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js
  function resolveGrammar2(options) {
    const actualOptions = defaults_default(options, {
      errMsgProvider: defaultGrammarResolverErrorProvider
    });
    const topRulesTable = {};
    forEach_default(options.rules, (rule) => {
      topRulesTable[rule.name] = rule;
    });
    return resolveGrammar(topRulesTable, actualOptions.errMsgProvider);
  }
  function validateGrammar2(options) {
    options = defaults_default(options, {
      errMsgProvider: defaultGrammarValidatorErrorProvider
    });
    return validateGrammar(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);
  }

  // ../node_modules/chevrotain/lib/src/parse/exceptions_public.js
  var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
  var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
  var EARLY_EXIT_EXCEPTION = "EarlyExitException";
  var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
  var RECOGNITION_EXCEPTION_NAMES = [
    MISMATCHED_TOKEN_EXCEPTION,
    NO_VIABLE_ALT_EXCEPTION,
    EARLY_EXIT_EXCEPTION,
    NOT_ALL_INPUT_PARSED_EXCEPTION
  ];
  Object.freeze(RECOGNITION_EXCEPTION_NAMES);
  function isRecognitionException(error) {
    return includes_default(RECOGNITION_EXCEPTION_NAMES, error.name);
  }
  var RecognitionException = class extends Error {
    constructor(message, token) {
      super(message);
      this.token = token;
      this.resyncedTokens = [];
      Object.setPrototypeOf(this, new.target.prototype);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
  };
  var MismatchedTokenException = class extends RecognitionException {
    constructor(message, token, previousToken) {
      super(message, token);
      this.previousToken = previousToken;
      this.name = MISMATCHED_TOKEN_EXCEPTION;
    }
  };
  var NoViableAltException = class extends RecognitionException {
    constructor(message, token, previousToken) {
      super(message, token);
      this.previousToken = previousToken;
      this.name = NO_VIABLE_ALT_EXCEPTION;
    }
  };
  var NotAllInputParsedException = class extends RecognitionException {
    constructor(message, token) {
      super(message, token);
      this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
    }
  };
  var EarlyExitException = class extends RecognitionException {
    constructor(message, token, previousToken) {
      super(message, token);
      this.previousToken = previousToken;
      this.name = EARLY_EXIT_EXCEPTION;
    }
  };

  // ../node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js
  var EOF_FOLLOW_KEY = {};
  var IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
  var InRuleRecoveryException = class extends Error {
    constructor(message) {
      super(message);
      this.name = IN_RULE_RECOVERY_EXCEPTION;
    }
  };
  var Recoverable = class {
    initRecoverable(config) {
      this.firstAfterRepMap = {};
      this.resyncFollows = {};
      this.recoveryEnabled = has_default(config, "recoveryEnabled") ? config.recoveryEnabled : DEFAULT_PARSER_CONFIG.recoveryEnabled;
      if (this.recoveryEnabled) {
        this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
      }
    }
    getTokenToInsert(tokType) {
      const tokToInsert = createTokenInstance(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
      tokToInsert.isInsertedInRecovery = true;
      return tokToInsert;
    }
    canTokenTypeBeInsertedInRecovery(tokType) {
      return true;
    }
    canTokenTypeBeDeletedInRecovery(tokType) {
      return true;
    }
    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
      const reSyncTokType = this.findReSyncTokenType();
      const savedLexerState = this.exportLexerState();
      const resyncedTokens = [];
      let passedResyncPoint = false;
      const nextTokenWithoutResync = this.LA(1);
      let currToken = this.LA(1);
      const generateErrorMessage = () => {
        const previousToken = this.LA(0);
        const msg = this.errorMessageProvider.buildMismatchTokenMessage({
          expected: expectedTokType,
          actual: nextTokenWithoutResync,
          previous: previousToken,
          ruleName: this.getCurrRuleFullName()
        });
        const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));
        error.resyncedTokens = dropRight_default(resyncedTokens);
        this.SAVE_ERROR(error);
      };
      while (!passedResyncPoint) {
        if (this.tokenMatcher(currToken, expectedTokType)) {
          generateErrorMessage();
          return;
        } else if (lookAheadFunc.call(this)) {
          generateErrorMessage();
          grammarRule.apply(this, grammarRuleArgs);
          return;
        } else if (this.tokenMatcher(currToken, reSyncTokType)) {
          passedResyncPoint = true;
        } else {
          currToken = this.SKIP_TOKEN();
          this.addToResyncTokens(currToken, resyncedTokens);
        }
      }
      this.importLexerState(savedLexerState);
    }
    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {
      if (notStuck === false) {
        return false;
      }
      if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
        return false;
      }
      if (this.isBackTracking()) {
        return false;
      }
      if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
        return false;
      }
      return true;
    }
    // Error Recovery functionality
    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {
      const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
      const follows = this.getNextPossibleTokenTypes(grammarPath);
      return follows;
    }
    tryInRuleRecovery(expectedTokType, follows) {
      if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
        const tokToInsert = this.getTokenToInsert(expectedTokType);
        return tokToInsert;
      }
      if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
        const nextTok = this.SKIP_TOKEN();
        this.consumeToken();
        return nextTok;
      }
      throw new InRuleRecoveryException("sad sad panda");
    }
    canPerformInRuleRecovery(expectedToken, follows) {
      return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
    }
    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {
      if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
        return false;
      }
      if (isEmpty_default(follows)) {
        return false;
      }
      const mismatchedTok = this.LA(1);
      const isMisMatchedTokInFollows = find_default(follows, (possibleFollowsTokType) => {
        return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
      }) !== void 0;
      return isMisMatchedTokInFollows;
    }
    canRecoverWithSingleTokenDeletion(expectedTokType) {
      if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {
        return false;
      }
      const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
      return isNextTokenWhatIsExpected;
    }
    isInCurrentRuleReSyncSet(tokenTypeIdx) {
      const followKey = this.getCurrFollowKey();
      const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
      return includes_default(currentRuleReSyncSet, tokenTypeIdx);
    }
    findReSyncTokenType() {
      const allPossibleReSyncTokTypes = this.flattenFollowSet();
      let nextToken = this.LA(1);
      let k = 2;
      while (true) {
        const foundMatch = find_default(allPossibleReSyncTokTypes, (resyncTokType) => {
          const canMatch = tokenMatcher(nextToken, resyncTokType);
          return canMatch;
        });
        if (foundMatch !== void 0) {
          return foundMatch;
        }
        nextToken = this.LA(k);
        k++;
      }
    }
    getCurrFollowKey() {
      if (this.RULE_STACK.length === 1) {
        return EOF_FOLLOW_KEY;
      }
      const currRuleShortName = this.getLastExplicitRuleShortName();
      const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
      const prevRuleShortName = this.getPreviousExplicitRuleShortName();
      return {
        ruleName: this.shortRuleNameToFullName(currRuleShortName),
        idxInCallingRule: currRuleIdx,
        inRule: this.shortRuleNameToFullName(prevRuleShortName)
      };
    }
    buildFullFollowKeyStack() {
      const explicitRuleStack = this.RULE_STACK;
      const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
      return map_default(explicitRuleStack, (ruleName, idx) => {
        if (idx === 0) {
          return EOF_FOLLOW_KEY;
        }
        return {
          ruleName: this.shortRuleNameToFullName(ruleName),
          idxInCallingRule: explicitOccurrenceStack[idx],
          inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
        };
      });
    }
    flattenFollowSet() {
      const followStack = map_default(this.buildFullFollowKeyStack(), (currKey) => {
        return this.getFollowSetFromFollowKey(currKey);
      });
      return flatten_default(followStack);
    }
    getFollowSetFromFollowKey(followKey) {
      if (followKey === EOF_FOLLOW_KEY) {
        return [EOF];
      }
      const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;
      return this.resyncFollows[followName];
    }
    // It does not make any sense to include a virtual EOF token in the list of resynced tokens
    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)
    addToResyncTokens(token, resyncTokens) {
      if (!this.tokenMatcher(token, EOF)) {
        resyncTokens.push(token);
      }
      return resyncTokens;
    }
    reSyncTo(tokType) {
      const resyncedTokens = [];
      let nextTok = this.LA(1);
      while (this.tokenMatcher(nextTok, tokType) === false) {
        nextTok = this.SKIP_TOKEN();
        this.addToResyncTokens(nextTok, resyncedTokens);
      }
      return dropRight_default(resyncedTokens);
    }
    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
    }
    getCurrentGrammarPath(tokType, tokIdxInRule) {
      const pathRuleStack = this.getHumanReadableRuleStack();
      const pathOccurrenceStack = clone_default(this.RULE_OCCURRENCE_STACK);
      const grammarPath = {
        ruleStack: pathRuleStack,
        occurrenceStack: pathOccurrenceStack,
        lastTok: tokType,
        lastTokOccurrence: tokIdxInRule
      };
      return grammarPath;
    }
    getHumanReadableRuleStack() {
      return map_default(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));
    }
  };
  function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
    let firstAfterRepInfo = this.firstAfterRepMap[key];
    if (firstAfterRepInfo === void 0) {
      const currRuleName = this.getCurrRuleFullName();
      const ruleGrammar = this.getGAstProductions()[currRuleName];
      const walker = new nextToksWalker(ruleGrammar, prodOccurrence);
      firstAfterRepInfo = walker.startWalking();
      this.firstAfterRepMap[key] = firstAfterRepInfo;
    }
    let expectTokAfterLastMatch = firstAfterRepInfo.token;
    let nextTokIdx = firstAfterRepInfo.occurrence;
    const isEndOfRule = firstAfterRepInfo.isEndOfRule;
    if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {
      expectTokAfterLastMatch = EOF;
      nextTokIdx = 1;
    }
    if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {
      return;
    }
    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
      this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
    }
  }

  // ../node_modules/chevrotain/lib/src/parse/grammar/keys.js
  var BITS_FOR_METHOD_TYPE = 4;
  var BITS_FOR_OCCURRENCE_IDX = 8;
  var BITS_FOR_ALT_IDX = 8;
  var OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;
  var OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;
  var MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;
  var AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;
  var MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;
  var AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;
  function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
    return occurrence | dslMethodIdx | ruleIdx;
  }
  var BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;

  // ../node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js
  var LLkLookaheadStrategy = class {
    constructor(options) {
      var _a;
      this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;
    }
    validate(options) {
      const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);
      if (isEmpty_default(leftRecursionErrors)) {
        const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);
        const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);
        const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);
        const allErrors = [
          ...leftRecursionErrors,
          ...emptyAltErrors,
          ...ambiguousAltsErrors,
          ...emptyRepetitionErrors
        ];
        return allErrors;
      }
      return leftRecursionErrors;
    }
    validateNoLeftRecursion(rules) {
      return flatMap_default(rules, (currTopRule) => validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider));
    }
    validateEmptyOrAlternatives(rules) {
      return flatMap_default(rules, (currTopRule) => validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider));
    }
    validateAmbiguousAlternationAlternatives(rules, maxLookahead) {
      return flatMap_default(rules, (currTopRule) => validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider));
    }
    validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {
      return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);
    }
    buildLookaheadForAlternation(options) {
      return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);
    }
    buildLookaheadForOptional(options) {
      return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);
    }
  };

  // ../node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js
  var LooksAhead = class {
    initLooksAhead(config) {
      this.dynamicTokensEnabled = has_default(config, "dynamicTokensEnabled") ? config.dynamicTokensEnabled : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
      this.maxLookahead = has_default(config, "maxLookahead") ? config.maxLookahead : DEFAULT_PARSER_CONFIG.maxLookahead;
      this.lookaheadStrategy = has_default(config, "lookaheadStrategy") ? config.lookaheadStrategy : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });
      this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
    }
    preComputeLookaheadFunctions(rules) {
      forEach_default(rules, (currRule) => {
        this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {
          const { alternation: alternation2, repetition: repetition2, option: option2, repetitionMandatory: repetitionMandatory2, repetitionMandatoryWithSeparator, repetitionWithSeparator } = collectMethods(currRule);
          forEach_default(alternation2, (currProd) => {
            const prodIdx = currProd.idx === 0 ? "" : currProd.idx;
            this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {
              const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({
                prodOccurrence: currProd.idx,
                rule: currRule,
                maxLookahead: currProd.maxLookahead || this.maxLookahead,
                hasPredicates: currProd.hasPredicates,
                dynamicTokensEnabled: this.dynamicTokensEnabled
              });
              const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);
              this.setLaFuncCache(key, laFunc);
            });
          });
          forEach_default(repetition2, (currProd) => {
            this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, "Repetition", currProd.maxLookahead, getProductionDslName(currProd));
          });
          forEach_default(option2, (currProd) => {
            this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, "Option", currProd.maxLookahead, getProductionDslName(currProd));
          });
          forEach_default(repetitionMandatory2, (currProd) => {
            this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, "RepetitionMandatory", currProd.maxLookahead, getProductionDslName(currProd));
          });
          forEach_default(repetitionMandatoryWithSeparator, (currProd) => {
            this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, "RepetitionMandatoryWithSeparator", currProd.maxLookahead, getProductionDslName(currProd));
          });
          forEach_default(repetitionWithSeparator, (currProd) => {
            this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, "RepetitionWithSeparator", currProd.maxLookahead, getProductionDslName(currProd));
          });
        });
      });
    }
    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
      this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? "" : prodOccurrence}`, () => {
        const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({
          prodOccurrence,
          rule,
          maxLookahead: prodMaxLookahead || this.maxLookahead,
          dynamicTokensEnabled: this.dynamicTokensEnabled,
          prodType
        });
        const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
        this.setLaFuncCache(key, laFunc);
      });
    }
    // this actually returns a number, but it is always used as a string (object prop key)
    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {
      const currRuleShortName = this.getLastExplicitRuleShortName();
      return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);
    }
    getLaFuncFromCache(key) {
      return this.lookAheadFuncsCache.get(key);
    }
    /* istanbul ignore next */
    setLaFuncCache(key, value) {
      this.lookAheadFuncsCache.set(key, value);
    }
  };
  var DslMethodsCollectorVisitor = class extends GAstVisitor {
    constructor() {
      super(...arguments);
      this.dslMethods = {
        option: [],
        alternation: [],
        repetition: [],
        repetitionWithSeparator: [],
        repetitionMandatory: [],
        repetitionMandatoryWithSeparator: []
      };
    }
    reset() {
      this.dslMethods = {
        option: [],
        alternation: [],
        repetition: [],
        repetitionWithSeparator: [],
        repetitionMandatory: [],
        repetitionMandatoryWithSeparator: []
      };
    }
    visitOption(option2) {
      this.dslMethods.option.push(option2);
    }
    visitRepetitionWithSeparator(manySep) {
      this.dslMethods.repetitionWithSeparator.push(manySep);
    }
    visitRepetitionMandatory(atLeastOne) {
      this.dslMethods.repetitionMandatory.push(atLeastOne);
    }
    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {
      this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
    }
    visitRepetition(many) {
      this.dslMethods.repetition.push(many);
    }
    visitAlternation(or) {
      this.dslMethods.alternation.push(or);
    }
  };
  var collectorVisitor = new DslMethodsCollectorVisitor();
  function collectMethods(rule) {
    collectorVisitor.reset();
    rule.accept(collectorVisitor);
    const dslMethods = collectorVisitor.dslMethods;
    collectorVisitor.reset();
    return dslMethods;
  }

  // ../node_modules/chevrotain/lib/src/parse/cst/cst.js
  function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
    if (isNaN(currNodeLocation.startOffset) === true) {
      currNodeLocation.startOffset = newLocationInfo.startOffset;
      currNodeLocation.endOffset = newLocationInfo.endOffset;
    } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
      currNodeLocation.endOffset = newLocationInfo.endOffset;
    }
  }
  function setNodeLocationFull(currNodeLocation, newLocationInfo) {
    if (isNaN(currNodeLocation.startOffset) === true) {
      currNodeLocation.startOffset = newLocationInfo.startOffset;
      currNodeLocation.startColumn = newLocationInfo.startColumn;
      currNodeLocation.startLine = newLocationInfo.startLine;
      currNodeLocation.endOffset = newLocationInfo.endOffset;
      currNodeLocation.endColumn = newLocationInfo.endColumn;
      currNodeLocation.endLine = newLocationInfo.endLine;
    } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
      currNodeLocation.endOffset = newLocationInfo.endOffset;
      currNodeLocation.endColumn = newLocationInfo.endColumn;
      currNodeLocation.endLine = newLocationInfo.endLine;
    }
  }
  function addTerminalToCst(node, token, tokenTypeName) {
    if (node.children[tokenTypeName] === void 0) {
      node.children[tokenTypeName] = [token];
    } else {
      node.children[tokenTypeName].push(token);
    }
  }
  function addNoneTerminalToCst(node, ruleName, ruleResult) {
    if (node.children[ruleName] === void 0) {
      node.children[ruleName] = [ruleResult];
    } else {
      node.children[ruleName].push(ruleResult);
    }
  }

  // ../node_modules/chevrotain/lib/src/lang/lang_extensions.js
  var NAME = "name";
  function defineNameProp(obj, nameValue) {
    Object.defineProperty(obj, NAME, {
      enumerable: false,
      configurable: true,
      writable: false,
      value: nameValue
    });
  }

  // ../node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js
  function defaultVisit(ctx, param) {
    const childrenNames = keys_default(ctx);
    const childrenNamesLength = childrenNames.length;
    for (let i = 0; i < childrenNamesLength; i++) {
      const currChildName = childrenNames[i];
      const currChildArray = ctx[currChildName];
      const currChildArrayLength = currChildArray.length;
      for (let j = 0; j < currChildArrayLength; j++) {
        const currChild = currChildArray[j];
        if (currChild.tokenTypeIdx === void 0) {
          this[currChild.name](currChild.children, param);
        }
      }
    }
  }
  function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
    const derivedConstructor = function() {
    };
    defineNameProp(derivedConstructor, grammarName + "BaseSemantics");
    const semanticProto = {
      visit: function(cstNode, param) {
        if (isArray_default(cstNode)) {
          cstNode = cstNode[0];
        }
        if (isUndefined_default(cstNode)) {
          return void 0;
        }
        return this[cstNode.name](cstNode.children, param);
      },
      validateVisitor: function() {
        const semanticDefinitionErrors = validateVisitor(this, ruleNames);
        if (!isEmpty_default(semanticDefinitionErrors)) {
          const errorMessages = map_default(semanticDefinitionErrors, (currDefError) => currDefError.msg);
          throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${errorMessages.join("\n\n").replace(/\n/g, "\n	")}`);
        }
      }
    };
    derivedConstructor.prototype = semanticProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    derivedConstructor._RULE_NAMES = ruleNames;
    return derivedConstructor;
  }
  function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
    const derivedConstructor = function() {
    };
    defineNameProp(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
    const withDefaultsProto = Object.create(baseConstructor.prototype);
    forEach_default(ruleNames, (ruleName) => {
      withDefaultsProto[ruleName] = defaultVisit;
    });
    derivedConstructor.prototype = withDefaultsProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    return derivedConstructor;
  }
  var CstVisitorDefinitionError;
  (function(CstVisitorDefinitionError2) {
    CstVisitorDefinitionError2[CstVisitorDefinitionError2["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
    CstVisitorDefinitionError2[CstVisitorDefinitionError2["MISSING_METHOD"] = 1] = "MISSING_METHOD";
  })(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));
  function validateVisitor(visitorInstance, ruleNames) {
    const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
    return missingErrors;
  }
  function validateMissingCstMethods(visitorInstance, ruleNames) {
    const missingRuleNames = filter_default(ruleNames, (currRuleName) => {
      return isFunction_default(visitorInstance[currRuleName]) === false;
    });
    const errors = map_default(missingRuleNames, (currRuleName) => {
      return {
        msg: `Missing visitor method: <${currRuleName}> on ${visitorInstance.constructor.name} CST Visitor.`,
        type: CstVisitorDefinitionError.MISSING_METHOD,
        methodName: currRuleName
      };
    });
    return compact_default(errors);
  }

  // ../node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js
  var TreeBuilder = class {
    initTreeBuilder(config) {
      this.CST_STACK = [];
      this.outputCst = config.outputCst;
      this.nodeLocationTracking = has_default(config, "nodeLocationTracking") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;
      if (!this.outputCst) {
        this.cstInvocationStateUpdate = noop_default;
        this.cstFinallyStateUpdate = noop_default;
        this.cstPostTerminal = noop_default;
        this.cstPostNonTerminal = noop_default;
        this.cstPostRule = noop_default;
      } else {
        if (/full/i.test(this.nodeLocationTracking)) {
          if (this.recoveryEnabled) {
            this.setNodeLocationFromToken = setNodeLocationFull;
            this.setNodeLocationFromNode = setNodeLocationFull;
            this.cstPostRule = noop_default;
            this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
          } else {
            this.setNodeLocationFromToken = noop_default;
            this.setNodeLocationFromNode = noop_default;
            this.cstPostRule = this.cstPostRuleFull;
            this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
          }
        } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
          if (this.recoveryEnabled) {
            this.setNodeLocationFromToken = setNodeLocationOnlyOffset;
            this.setNodeLocationFromNode = setNodeLocationOnlyOffset;
            this.cstPostRule = noop_default;
            this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
          } else {
            this.setNodeLocationFromToken = noop_default;
            this.setNodeLocationFromNode = noop_default;
            this.cstPostRule = this.cstPostRuleOnlyOffset;
            this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
          }
        } else if (/none/i.test(this.nodeLocationTracking)) {
          this.setNodeLocationFromToken = noop_default;
          this.setNodeLocationFromNode = noop_default;
          this.cstPostRule = noop_default;
          this.setInitialNodeLocation = noop_default;
        } else {
          throw Error(`Invalid <nodeLocationTracking> config option: "${config.nodeLocationTracking}"`);
        }
      }
    }
    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {
      cstNode.location = {
        startOffset: NaN,
        endOffset: NaN
      };
    }
    setInitialNodeLocationOnlyOffsetRegular(cstNode) {
      cstNode.location = {
        // without error recovery the starting Location of a new CstNode is guaranteed
        // To be the next Token's startOffset (for valid inputs).
        // For invalid inputs there won't be any CSTOutput so this potential
        // inaccuracy does not matter
        startOffset: this.LA(1).startOffset,
        endOffset: NaN
      };
    }
    setInitialNodeLocationFullRecovery(cstNode) {
      cstNode.location = {
        startOffset: NaN,
        startLine: NaN,
        startColumn: NaN,
        endOffset: NaN,
        endLine: NaN,
        endColumn: NaN
      };
    }
    /**
         *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work
    
         * @param cstNode
         */
    setInitialNodeLocationFullRegular(cstNode) {
      const nextToken = this.LA(1);
      cstNode.location = {
        startOffset: nextToken.startOffset,
        startLine: nextToken.startLine,
        startColumn: nextToken.startColumn,
        endOffset: NaN,
        endLine: NaN,
        endColumn: NaN
      };
    }
    cstInvocationStateUpdate(fullRuleName) {
      const cstNode = {
        name: fullRuleName,
        children: /* @__PURE__ */ Object.create(null)
      };
      this.setInitialNodeLocation(cstNode);
      this.CST_STACK.push(cstNode);
    }
    cstFinallyStateUpdate() {
      this.CST_STACK.pop();
    }
    cstPostRuleFull(ruleCstNode) {
      const prevToken = this.LA(0);
      const loc = ruleCstNode.location;
      if (loc.startOffset <= prevToken.startOffset === true) {
        loc.endOffset = prevToken.endOffset;
        loc.endLine = prevToken.endLine;
        loc.endColumn = prevToken.endColumn;
      } else {
        loc.startOffset = NaN;
        loc.startLine = NaN;
        loc.startColumn = NaN;
      }
    }
    cstPostRuleOnlyOffset(ruleCstNode) {
      const prevToken = this.LA(0);
      const loc = ruleCstNode.location;
      if (loc.startOffset <= prevToken.startOffset === true) {
        loc.endOffset = prevToken.endOffset;
      } else {
        loc.startOffset = NaN;
      }
    }
    cstPostTerminal(key, consumedToken) {
      const rootCst = this.CST_STACK[this.CST_STACK.length - 1];
      addTerminalToCst(rootCst, consumedToken, key);
      this.setNodeLocationFromToken(rootCst.location, consumedToken);
    }
    cstPostNonTerminal(ruleCstResult, ruleName) {
      const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
      addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);
      this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
    }
    getBaseCstVisitorConstructor() {
      if (isUndefined_default(this.baseCstVisitorConstructor)) {
        const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys_default(this.gastProductionsCache));
        this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
        return newBaseCstVisitorConstructor;
      }
      return this.baseCstVisitorConstructor;
    }
    getBaseCstVisitorConstructorWithDefaults() {
      if (isUndefined_default(this.baseCstVisitorWithDefaultsConstructor)) {
        const newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys_default(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
        this.baseCstVisitorWithDefaultsConstructor = newConstructor;
        return newConstructor;
      }
      return this.baseCstVisitorWithDefaultsConstructor;
    }
    getLastExplicitRuleShortName() {
      const ruleStack = this.RULE_STACK;
      return ruleStack[ruleStack.length - 1];
    }
    getPreviousExplicitRuleShortName() {
      const ruleStack = this.RULE_STACK;
      return ruleStack[ruleStack.length - 2];
    }
    getLastExplicitRuleOccurrenceIndex() {
      const occurrenceStack = this.RULE_OCCURRENCE_STACK;
      return occurrenceStack[occurrenceStack.length - 1];
    }
  };

  // ../node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js
  var LexerAdapter = class {
    initLexerAdapter() {
      this.tokVector = [];
      this.tokVectorLength = 0;
      this.currIdx = -1;
    }
    set input(newInput) {
      if (this.selfAnalysisDone !== true) {
        throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);
      }
      this.reset();
      this.tokVector = newInput;
      this.tokVectorLength = newInput.length;
    }
    get input() {
      return this.tokVector;
    }
    // skips a token and returns the next token
    SKIP_TOKEN() {
      if (this.currIdx <= this.tokVector.length - 2) {
        this.consumeToken();
        return this.LA(1);
      } else {
        return END_OF_FILE;
      }
    }
    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
    // or lexers dependent on parser context.
    LA(howMuch) {
      const soughtIdx = this.currIdx + howMuch;
      if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
        return END_OF_FILE;
      } else {
        return this.tokVector[soughtIdx];
      }
    }
    consumeToken() {
      this.currIdx++;
    }
    exportLexerState() {
      return this.currIdx;
    }
    importLexerState(newState2) {
      this.currIdx = newState2;
    }
    resetLexerState() {
      this.currIdx = -1;
    }
    moveToTerminatedState() {
      this.currIdx = this.tokVector.length - 1;
    }
    getLexerPosition() {
      return this.exportLexerState();
    }
  };

  // ../node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js
  var RecognizerApi = class {
    ACTION(impl) {
      return impl.call(this);
    }
    consume(idx, tokType, options) {
      return this.consumeInternal(tokType, idx, options);
    }
    subrule(idx, ruleToCall, options) {
      return this.subruleInternal(ruleToCall, idx, options);
    }
    option(idx, actionORMethodDef) {
      return this.optionInternal(actionORMethodDef, idx);
    }
    or(idx, altsOrOpts) {
      return this.orInternal(altsOrOpts, idx);
    }
    many(idx, actionORMethodDef) {
      return this.manyInternal(idx, actionORMethodDef);
    }
    atLeastOne(idx, actionORMethodDef) {
      return this.atLeastOneInternal(idx, actionORMethodDef);
    }
    CONSUME(tokType, options) {
      return this.consumeInternal(tokType, 0, options);
    }
    CONSUME1(tokType, options) {
      return this.consumeInternal(tokType, 1, options);
    }
    CONSUME2(tokType, options) {
      return this.consumeInternal(tokType, 2, options);
    }
    CONSUME3(tokType, options) {
      return this.consumeInternal(tokType, 3, options);
    }
    CONSUME4(tokType, options) {
      return this.consumeInternal(tokType, 4, options);
    }
    CONSUME5(tokType, options) {
      return this.consumeInternal(tokType, 5, options);
    }
    CONSUME6(tokType, options) {
      return this.consumeInternal(tokType, 6, options);
    }
    CONSUME7(tokType, options) {
      return this.consumeInternal(tokType, 7, options);
    }
    CONSUME8(tokType, options) {
      return this.consumeInternal(tokType, 8, options);
    }
    CONSUME9(tokType, options) {
      return this.consumeInternal(tokType, 9, options);
    }
    SUBRULE(ruleToCall, options) {
      return this.subruleInternal(ruleToCall, 0, options);
    }
    SUBRULE1(ruleToCall, options) {
      return this.subruleInternal(ruleToCall, 1, options);
    }
    SUBRULE2(ruleToCall, options) {
      return this.subruleInternal(ruleToCall, 2, options);
    }
    SUBRULE3(ruleToCall, options) {
      return this.subruleInternal(ruleToCall, 3, options);
    }
    SUBRULE4(ruleToCall, options) {
      return this.subruleInternal(ruleToCall, 4, options);
    }
    SUBRULE5(ruleToCall, options) {
      return this.subruleInternal(ruleToCall, 5, options);
    }
    SUBRULE6(ruleToCall, options) {
      return this.subruleInternal(ruleToCall, 6, options);
    }
    SUBRULE7(ruleToCall, options) {
      return this.subruleInternal(ruleToCall, 7, options);
    }
    SUBRULE8(ruleToCall, options) {
      return this.subruleInternal(ruleToCall, 8, options);
    }
    SUBRULE9(ruleToCall, options) {
      return this.subruleInternal(ruleToCall, 9, options);
    }
    OPTION(actionORMethodDef) {
      return this.optionInternal(actionORMethodDef, 0);
    }
    OPTION1(actionORMethodDef) {
      return this.optionInternal(actionORMethodDef, 1);
    }
    OPTION2(actionORMethodDef) {
      return this.optionInternal(actionORMethodDef, 2);
    }
    OPTION3(actionORMethodDef) {
      return this.optionInternal(actionORMethodDef, 3);
    }
    OPTION4(actionORMethodDef) {
      return this.optionInternal(actionORMethodDef, 4);
    }
    OPTION5(actionORMethodDef) {
      return this.optionInternal(actionORMethodDef, 5);
    }
    OPTION6(actionORMethodDef) {
      return this.optionInternal(actionORMethodDef, 6);
    }
    OPTION7(actionORMethodDef) {
      return this.optionInternal(actionORMethodDef, 7);
    }
    OPTION8(actionORMethodDef) {
      return this.optionInternal(actionORMethodDef, 8);
    }
    OPTION9(actionORMethodDef) {
      return this.optionInternal(actionORMethodDef, 9);
    }
    OR(altsOrOpts) {
      return this.orInternal(altsOrOpts, 0);
    }
    OR1(altsOrOpts) {
      return this.orInternal(altsOrOpts, 1);
    }
    OR2(altsOrOpts) {
      return this.orInternal(altsOrOpts, 2);
    }
    OR3(altsOrOpts) {
      return this.orInternal(altsOrOpts, 3);
    }
    OR4(altsOrOpts) {
      return this.orInternal(altsOrOpts, 4);
    }
    OR5(altsOrOpts) {
      return this.orInternal(altsOrOpts, 5);
    }
    OR6(altsOrOpts) {
      return this.orInternal(altsOrOpts, 6);
    }
    OR7(altsOrOpts) {
      return this.orInternal(altsOrOpts, 7);
    }
    OR8(altsOrOpts) {
      return this.orInternal(altsOrOpts, 8);
    }
    OR9(altsOrOpts) {
      return this.orInternal(altsOrOpts, 9);
    }
    MANY(actionORMethodDef) {
      this.manyInternal(0, actionORMethodDef);
    }
    MANY1(actionORMethodDef) {
      this.manyInternal(1, actionORMethodDef);
    }
    MANY2(actionORMethodDef) {
      this.manyInternal(2, actionORMethodDef);
    }
    MANY3(actionORMethodDef) {
      this.manyInternal(3, actionORMethodDef);
    }
    MANY4(actionORMethodDef) {
      this.manyInternal(4, actionORMethodDef);
    }
    MANY5(actionORMethodDef) {
      this.manyInternal(5, actionORMethodDef);
    }
    MANY6(actionORMethodDef) {
      this.manyInternal(6, actionORMethodDef);
    }
    MANY7(actionORMethodDef) {
      this.manyInternal(7, actionORMethodDef);
    }
    MANY8(actionORMethodDef) {
      this.manyInternal(8, actionORMethodDef);
    }
    MANY9(actionORMethodDef) {
      this.manyInternal(9, actionORMethodDef);
    }
    MANY_SEP(options) {
      this.manySepFirstInternal(0, options);
    }
    MANY_SEP1(options) {
      this.manySepFirstInternal(1, options);
    }
    MANY_SEP2(options) {
      this.manySepFirstInternal(2, options);
    }
    MANY_SEP3(options) {
      this.manySepFirstInternal(3, options);
    }
    MANY_SEP4(options) {
      this.manySepFirstInternal(4, options);
    }
    MANY_SEP5(options) {
      this.manySepFirstInternal(5, options);
    }
    MANY_SEP6(options) {
      this.manySepFirstInternal(6, options);
    }
    MANY_SEP7(options) {
      this.manySepFirstInternal(7, options);
    }
    MANY_SEP8(options) {
      this.manySepFirstInternal(8, options);
    }
    MANY_SEP9(options) {
      this.manySepFirstInternal(9, options);
    }
    AT_LEAST_ONE(actionORMethodDef) {
      this.atLeastOneInternal(0, actionORMethodDef);
    }
    AT_LEAST_ONE1(actionORMethodDef) {
      return this.atLeastOneInternal(1, actionORMethodDef);
    }
    AT_LEAST_ONE2(actionORMethodDef) {
      this.atLeastOneInternal(2, actionORMethodDef);
    }
    AT_LEAST_ONE3(actionORMethodDef) {
      this.atLeastOneInternal(3, actionORMethodDef);
    }
    AT_LEAST_ONE4(actionORMethodDef) {
      this.atLeastOneInternal(4, actionORMethodDef);
    }
    AT_LEAST_ONE5(actionORMethodDef) {
      this.atLeastOneInternal(5, actionORMethodDef);
    }
    AT_LEAST_ONE6(actionORMethodDef) {
      this.atLeastOneInternal(6, actionORMethodDef);
    }
    AT_LEAST_ONE7(actionORMethodDef) {
      this.atLeastOneInternal(7, actionORMethodDef);
    }
    AT_LEAST_ONE8(actionORMethodDef) {
      this.atLeastOneInternal(8, actionORMethodDef);
    }
    AT_LEAST_ONE9(actionORMethodDef) {
      this.atLeastOneInternal(9, actionORMethodDef);
    }
    AT_LEAST_ONE_SEP(options) {
      this.atLeastOneSepFirstInternal(0, options);
    }
    AT_LEAST_ONE_SEP1(options) {
      this.atLeastOneSepFirstInternal(1, options);
    }
    AT_LEAST_ONE_SEP2(options) {
      this.atLeastOneSepFirstInternal(2, options);
    }
    AT_LEAST_ONE_SEP3(options) {
      this.atLeastOneSepFirstInternal(3, options);
    }
    AT_LEAST_ONE_SEP4(options) {
      this.atLeastOneSepFirstInternal(4, options);
    }
    AT_LEAST_ONE_SEP5(options) {
      this.atLeastOneSepFirstInternal(5, options);
    }
    AT_LEAST_ONE_SEP6(options) {
      this.atLeastOneSepFirstInternal(6, options);
    }
    AT_LEAST_ONE_SEP7(options) {
      this.atLeastOneSepFirstInternal(7, options);
    }
    AT_LEAST_ONE_SEP8(options) {
      this.atLeastOneSepFirstInternal(8, options);
    }
    AT_LEAST_ONE_SEP9(options) {
      this.atLeastOneSepFirstInternal(9, options);
    }
    RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {
      if (includes_default(this.definedRulesNames, name)) {
        const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
          topLevelRule: name,
          grammarName: this.className
        });
        const error = {
          message: errMsg,
          type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
          ruleName: name
        };
        this.definitionErrors.push(error);
      }
      this.definedRulesNames.push(name);
      const ruleImplementation = this.defineRule(name, implementation, config);
      this[name] = ruleImplementation;
      return ruleImplementation;
    }
    OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {
      const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);
      this.definitionErrors = this.definitionErrors.concat(ruleErrors);
      const ruleImplementation = this.defineRule(name, impl, config);
      this[name] = ruleImplementation;
      return ruleImplementation;
    }
    BACKTRACK(grammarRule, args) {
      return function() {
        this.isBackTrackingStack.push(1);
        const orgState = this.saveRecogState();
        try {
          grammarRule.apply(this, args);
          return true;
        } catch (e) {
          if (isRecognitionException(e)) {
            return false;
          } else {
            throw e;
          }
        } finally {
          this.reloadRecogState(orgState);
          this.isBackTrackingStack.pop();
        }
      };
    }
    // GAST export APIs
    getGAstProductions() {
      return this.gastProductionsCache;
    }
    getSerializedGastProductions() {
      return serializeGrammar(values_default(this.gastProductionsCache));
    }
  };

  // ../node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js
  var RecognizerEngine = class {
    initRecognizerEngine(tokenVocabulary, config) {
      this.className = this.constructor.name;
      this.shortRuleNameToFull = {};
      this.fullRuleNameToShort = {};
      this.ruleShortNameIdx = 256;
      this.tokenMatcher = tokenStructuredMatcherNoCategories;
      this.subruleIdx = 0;
      this.definedRulesNames = [];
      this.tokensMap = {};
      this.isBackTrackingStack = [];
      this.RULE_STACK = [];
      this.RULE_OCCURRENCE_STACK = [];
      this.gastProductionsCache = {};
      if (has_default(config, "serializedGrammar")) {
        throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.");
      }
      if (isArray_default(tokenVocabulary)) {
        if (isEmpty_default(tokenVocabulary)) {
          throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
        }
        if (typeof tokenVocabulary[0].startOffset === "number") {
          throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
        }
      }
      if (isArray_default(tokenVocabulary)) {
        this.tokensMap = reduce_default(tokenVocabulary, (acc, tokType) => {
          acc[tokType.name] = tokType;
          return acc;
        }, {});
      } else if (has_default(tokenVocabulary, "modes") && every_default(flatten_default(values_default(tokenVocabulary.modes)), isTokenType)) {
        const allTokenTypes2 = flatten_default(values_default(tokenVocabulary.modes));
        const uniqueTokens = uniq_default(allTokenTypes2);
        this.tokensMap = reduce_default(uniqueTokens, (acc, tokType) => {
          acc[tokType.name] = tokType;
          return acc;
        }, {});
      } else if (isObject_default(tokenVocabulary)) {
        this.tokensMap = clone_default(tokenVocabulary);
      } else {
        throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
      }
      this.tokensMap["EOF"] = EOF;
      const allTokenTypes = has_default(tokenVocabulary, "modes") ? flatten_default(values_default(tokenVocabulary.modes)) : values_default(tokenVocabulary);
      const noTokenCategoriesUsed = every_default(allTokenTypes, (tokenConstructor) => isEmpty_default(tokenConstructor.categoryMatches));
      this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;
      augmentTokenTypes(values_default(this.tokensMap));
    }
    defineRule(ruleName, impl, config) {
      if (this.selfAnalysisDone) {
        throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
      }
      const resyncEnabled = has_default(config, "resyncEnabled") ? config.resyncEnabled : DEFAULT_RULE_CONFIG.resyncEnabled;
      const recoveryValueFunc = has_default(config, "recoveryValueFunc") ? config.recoveryValueFunc : DEFAULT_RULE_CONFIG.recoveryValueFunc;
      const shortName = this.ruleShortNameIdx << BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX;
      this.ruleShortNameIdx++;
      this.shortRuleNameToFull[shortName] = ruleName;
      this.fullRuleNameToShort[ruleName] = shortName;
      let invokeRuleWithTry;
      if (this.outputCst === true) {
        invokeRuleWithTry = function invokeRuleWithTry2(...args) {
          try {
            this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
            impl.apply(this, args);
            const cst = this.CST_STACK[this.CST_STACK.length - 1];
            this.cstPostRule(cst);
            return cst;
          } catch (e) {
            return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
          } finally {
            this.ruleFinallyStateUpdate();
          }
        };
      } else {
        invokeRuleWithTry = function invokeRuleWithTryCst(...args) {
          try {
            this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
            return impl.apply(this, args);
          } catch (e) {
            return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
          } finally {
            this.ruleFinallyStateUpdate();
          }
        };
      }
      const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });
      return wrappedGrammarRule;
    }
    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {
      const isFirstInvokedRule = this.RULE_STACK.length === 1;
      const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
      if (isRecognitionException(e)) {
        const recogError = e;
        if (reSyncEnabled) {
          const reSyncTokType = this.findReSyncTokenType();
          if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
            recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
            if (this.outputCst) {
              const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
              partialCstResult.recoveredNode = true;
              return partialCstResult;
            } else {
              return recoveryValueFunc(e);
            }
          } else {
            if (this.outputCst) {
              const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
              partialCstResult.recoveredNode = true;
              recogError.partialCstResult = partialCstResult;
            }
            throw recogError;
          }
        } else if (isFirstInvokedRule) {
          this.moveToTerminatedState();
          return recoveryValueFunc(e);
        } else {
          throw recogError;
        }
      } else {
        throw e;
      }
    }
    // Implementation of parsing DSL
    optionInternal(actionORMethodDef, occurrence) {
      const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);
      return this.optionInternalLogic(actionORMethodDef, occurrence, key);
    }
    optionInternalLogic(actionORMethodDef, occurrence, key) {
      let lookAheadFunc = this.getLaFuncFromCache(key);
      let action;
      if (typeof actionORMethodDef !== "function") {
        action = actionORMethodDef.DEF;
        const predicate = actionORMethodDef.GATE;
        if (predicate !== void 0) {
          const orgLookaheadFunction = lookAheadFunc;
          lookAheadFunc = () => {
            return predicate.call(this) && orgLookaheadFunction.call(this);
          };
        }
      } else {
        action = actionORMethodDef;
      }
      if (lookAheadFunc.call(this) === true) {
        return action.call(this);
      }
      return void 0;
    }
    atLeastOneInternal(prodOccurrence, actionORMethodDef) {
      const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);
      return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
    }
    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {
      let lookAheadFunc = this.getLaFuncFromCache(key);
      let action;
      if (typeof actionORMethodDef !== "function") {
        action = actionORMethodDef.DEF;
        const predicate = actionORMethodDef.GATE;
        if (predicate !== void 0) {
          const orgLookaheadFunction = lookAheadFunc;
          lookAheadFunc = () => {
            return predicate.call(this) && orgLookaheadFunction.call(this);
          };
        }
      } else {
        action = actionORMethodDef;
      }
      if (lookAheadFunc.call(this) === true) {
        let notStuck = this.doSingleRepetition(action);
        while (lookAheadFunc.call(this) === true && notStuck === true) {
          notStuck = this.doSingleRepetition(action);
        }
      } else {
        throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
      }
      this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);
    }
    atLeastOneSepFirstInternal(prodOccurrence, options) {
      const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);
      this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
    }
    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {
      const action = options.DEF;
      const separator = options.SEP;
      const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
      if (firstIterationLookaheadFunc.call(this) === true) {
        action.call(this);
        const separatorLookAheadFunc = () => {
          return this.tokenMatcher(this.LA(1), separator);
        };
        while (this.tokenMatcher(this.LA(1), separator) === true) {
          this.CONSUME(separator);
          action.call(this);
        }
        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
          prodOccurrence,
          separator,
          separatorLookAheadFunc,
          action,
          NextTerminalAfterAtLeastOneSepWalker
        ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);
      } else {
        throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
      }
    }
    manyInternal(prodOccurrence, actionORMethodDef) {
      const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);
      return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
    }
    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {
      let lookaheadFunction = this.getLaFuncFromCache(key);
      let action;
      if (typeof actionORMethodDef !== "function") {
        action = actionORMethodDef.DEF;
        const predicate = actionORMethodDef.GATE;
        if (predicate !== void 0) {
          const orgLookaheadFunction = lookaheadFunction;
          lookaheadFunction = () => {
            return predicate.call(this) && orgLookaheadFunction.call(this);
          };
        }
      } else {
        action = actionORMethodDef;
      }
      let notStuck = true;
      while (lookaheadFunction.call(this) === true && notStuck === true) {
        notStuck = this.doSingleRepetition(action);
      }
      this.attemptInRepetitionRecovery(
        this.manyInternal,
        [prodOccurrence, actionORMethodDef],
        lookaheadFunction,
        MANY_IDX,
        prodOccurrence,
        NextTerminalAfterManyWalker,
        // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
        // An infinite loop cannot occur as:
        // - Either the lookahead is guaranteed to consume something (Single Token Separator)
        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
        notStuck
      );
    }
    manySepFirstInternal(prodOccurrence, options) {
      const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);
      this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
    }
    manySepFirstInternalLogic(prodOccurrence, options, key) {
      const action = options.DEF;
      const separator = options.SEP;
      const firstIterationLaFunc = this.getLaFuncFromCache(key);
      if (firstIterationLaFunc.call(this) === true) {
        action.call(this);
        const separatorLookAheadFunc = () => {
          return this.tokenMatcher(this.LA(1), separator);
        };
        while (this.tokenMatcher(this.LA(1), separator) === true) {
          this.CONSUME(separator);
          action.call(this);
        }
        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
          prodOccurrence,
          separator,
          separatorLookAheadFunc,
          action,
          NextTerminalAfterManySepWalker
        ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);
      }
    }
    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
      while (separatorLookAheadFunc()) {
        this.CONSUME(separator);
        action.call(this);
      }
      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
        prodOccurrence,
        separator,
        separatorLookAheadFunc,
        action,
        nextTerminalAfterWalker
      ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
    }
    doSingleRepetition(action) {
      const beforeIteration = this.getLexerPosition();
      action.call(this);
      const afterIteration = this.getLexerPosition();
      return afterIteration > beforeIteration;
    }
    orInternal(altsOrOpts, occurrence) {
      const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);
      const alts = isArray_default(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
      const laFunc = this.getLaFuncFromCache(laKey);
      const altIdxToTake = laFunc.call(this, alts);
      if (altIdxToTake !== void 0) {
        const chosenAlternative = alts[altIdxToTake];
        return chosenAlternative.ALT.call(this);
      }
      this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
    }
    ruleFinallyStateUpdate() {
      this.RULE_STACK.pop();
      this.RULE_OCCURRENCE_STACK.pop();
      this.cstFinallyStateUpdate();
      if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
        const firstRedundantTok = this.LA(1);
        const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
          firstRedundant: firstRedundantTok,
          ruleName: this.getCurrRuleFullName()
        });
        this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));
      }
    }
    subruleInternal(ruleToCall, idx, options) {
      let ruleResult;
      try {
        const args = options !== void 0 ? options.ARGS : void 0;
        this.subruleIdx = idx;
        ruleResult = ruleToCall.apply(this, args);
        this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);
        return ruleResult;
      } catch (e) {
        throw this.subruleInternalError(e, options, ruleToCall.ruleName);
      }
    }
    subruleInternalError(e, options, ruleName) {
      if (isRecognitionException(e) && e.partialCstResult !== void 0) {
        this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);
        delete e.partialCstResult;
      }
      throw e;
    }
    consumeInternal(tokType, idx, options) {
      let consumedToken;
      try {
        const nextToken = this.LA(1);
        if (this.tokenMatcher(nextToken, tokType) === true) {
          this.consumeToken();
          consumedToken = nextToken;
        } else {
          this.consumeInternalError(tokType, nextToken, options);
        }
      } catch (eFromConsumption) {
        consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
      }
      this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);
      return consumedToken;
    }
    consumeInternalError(tokType, nextToken, options) {
      let msg;
      const previousToken = this.LA(0);
      if (options !== void 0 && options.ERR_MSG) {
        msg = options.ERR_MSG;
      } else {
        msg = this.errorMessageProvider.buildMismatchTokenMessage({
          expected: tokType,
          actual: nextToken,
          previous: previousToken,
          ruleName: this.getCurrRuleFullName()
        });
      }
      throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));
    }
    consumeInternalRecovery(tokType, idx, eFromConsumption) {
      if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
      eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
        const follows = this.getFollowsForInRuleRecovery(tokType, idx);
        try {
          return this.tryInRuleRecovery(tokType, follows);
        } catch (eFromInRuleRecovery) {
          if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {
            throw eFromConsumption;
          } else {
            throw eFromInRuleRecovery;
          }
        }
      } else {
        throw eFromConsumption;
      }
    }
    saveRecogState() {
      const savedErrors = this.errors;
      const savedRuleStack = clone_default(this.RULE_STACK);
      return {
        errors: savedErrors,
        lexerState: this.exportLexerState(),
        RULE_STACK: savedRuleStack,
        CST_STACK: this.CST_STACK
      };
    }
    reloadRecogState(newState2) {
      this.errors = newState2.errors;
      this.importLexerState(newState2.lexerState);
      this.RULE_STACK = newState2.RULE_STACK;
    }
    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {
      this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
      this.RULE_STACK.push(shortName);
      this.cstInvocationStateUpdate(fullName);
    }
    isBackTracking() {
      return this.isBackTrackingStack.length !== 0;
    }
    getCurrRuleFullName() {
      const shortName = this.getLastExplicitRuleShortName();
      return this.shortRuleNameToFull[shortName];
    }
    shortRuleNameToFullName(shortName) {
      return this.shortRuleNameToFull[shortName];
    }
    isAtEndOfInput() {
      return this.tokenMatcher(this.LA(1), EOF);
    }
    reset() {
      this.resetLexerState();
      this.subruleIdx = 0;
      this.isBackTrackingStack = [];
      this.errors = [];
      this.RULE_STACK = [];
      this.CST_STACK = [];
      this.RULE_OCCURRENCE_STACK = [];
    }
  };

  // ../node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js
  var ErrorHandler = class {
    initErrorHandler(config) {
      this._errors = [];
      this.errorMessageProvider = has_default(config, "errorMessageProvider") ? config.errorMessageProvider : DEFAULT_PARSER_CONFIG.errorMessageProvider;
    }
    SAVE_ERROR(error) {
      if (isRecognitionException(error)) {
        error.context = {
          ruleStack: this.getHumanReadableRuleStack(),
          ruleOccurrenceStack: clone_default(this.RULE_OCCURRENCE_STACK)
        };
        this._errors.push(error);
        return error;
      } else {
        throw Error("Trying to save an Error which is not a RecognitionException");
      }
    }
    get errors() {
      return clone_default(this._errors);
    }
    set errors(newErrors) {
      this._errors = newErrors;
    }
    // TODO: consider caching the error message computed information
    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {
      const ruleName = this.getCurrRuleFullName();
      const ruleGrammar = this.getGAstProductions()[ruleName];
      const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);
      const insideProdPaths = lookAheadPathsPerAlternative[0];
      const actualTokens = [];
      for (let i = 1; i <= this.maxLookahead; i++) {
        actualTokens.push(this.LA(i));
      }
      const msg = this.errorMessageProvider.buildEarlyExitMessage({
        expectedIterationPaths: insideProdPaths,
        actual: actualTokens,
        previous: this.LA(0),
        customUserDescription: userDefinedErrMsg,
        ruleName
      });
      throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));
    }
    // TODO: consider caching the error message computed information
    raiseNoAltException(occurrence, errMsgTypes) {
      const ruleName = this.getCurrRuleFullName();
      const ruleGrammar = this.getGAstProductions()[ruleName];
      const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);
      const actualTokens = [];
      for (let i = 1; i <= this.maxLookahead; i++) {
        actualTokens.push(this.LA(i));
      }
      const previousToken = this.LA(0);
      const errMsg = this.errorMessageProvider.buildNoViableAltMessage({
        expectedPathsPerAlt: lookAheadPathsPerAlternative,
        actual: actualTokens,
        previous: previousToken,
        customUserDescription: errMsgTypes,
        ruleName: this.getCurrRuleFullName()
      });
      throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));
    }
  };

  // ../node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js
  var ContentAssist = class {
    initContentAssist() {
    }
    computeContentAssist(startRuleName, precedingInput) {
      const startRuleGast = this.gastProductionsCache[startRuleName];
      if (isUndefined_default(startRuleGast)) {
        throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);
      }
      return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
    }
    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
    // TODO: should this be more explicitly part of the public API?
    getNextPossibleTokenTypes(grammarPath) {
      const topRuleName = head_default(grammarPath.ruleStack);
      const gastProductions = this.getGAstProductions();
      const topProduction = gastProductions[topRuleName];
      const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();
      return nextPossibleTokenTypes;
    }
  };

  // ../node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js
  var RECORDING_NULL_OBJECT = {
    description: "This Object indicates the Parser is during Recording Phase"
  };
  Object.freeze(RECORDING_NULL_OBJECT);
  var HANDLE_SEPARATOR = true;
  var MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;
  var RFT = createToken({ name: "RECORDING_PHASE_TOKEN", pattern: Lexer.NA });
  augmentTokenTypes([RFT]);
  var RECORDING_PHASE_TOKEN = createTokenInstance(
    RFT,
    "This IToken indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
    // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
    // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  );
  Object.freeze(RECORDING_PHASE_TOKEN);
  var RECORDING_PHASE_CSTNODE = {
    name: "This CSTNode indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
    children: {}
  };
  var GastRecorder = class {
    initGastRecorder(config) {
      this.recordingProdStack = [];
      this.RECORDING_PHASE = false;
    }
    enableRecording() {
      this.RECORDING_PHASE = true;
      this.TRACE_INIT("Enable Recording", () => {
        for (let i = 0; i < 10; i++) {
          const idx = i > 0 ? i : "";
          this[`CONSUME${idx}`] = function(arg1, arg2) {
            return this.consumeInternalRecord(arg1, i, arg2);
          };
          this[`SUBRULE${idx}`] = function(arg1, arg2) {
            return this.subruleInternalRecord(arg1, i, arg2);
          };
          this[`OPTION${idx}`] = function(arg1) {
            return this.optionInternalRecord(arg1, i);
          };
          this[`OR${idx}`] = function(arg1) {
            return this.orInternalRecord(arg1, i);
          };
          this[`MANY${idx}`] = function(arg1) {
            this.manyInternalRecord(i, arg1);
          };
          this[`MANY_SEP${idx}`] = function(arg1) {
            this.manySepFirstInternalRecord(i, arg1);
          };
          this[`AT_LEAST_ONE${idx}`] = function(arg1) {
            this.atLeastOneInternalRecord(i, arg1);
          };
          this[`AT_LEAST_ONE_SEP${idx}`] = function(arg1) {
            this.atLeastOneSepFirstInternalRecord(i, arg1);
          };
        }
        this[`consume`] = function(idx, arg1, arg2) {
          return this.consumeInternalRecord(arg1, idx, arg2);
        };
        this[`subrule`] = function(idx, arg1, arg2) {
          return this.subruleInternalRecord(arg1, idx, arg2);
        };
        this[`option`] = function(idx, arg1) {
          return this.optionInternalRecord(arg1, idx);
        };
        this[`or`] = function(idx, arg1) {
          return this.orInternalRecord(arg1, idx);
        };
        this[`many`] = function(idx, arg1) {
          this.manyInternalRecord(idx, arg1);
        };
        this[`atLeastOne`] = function(idx, arg1) {
          this.atLeastOneInternalRecord(idx, arg1);
        };
        this.ACTION = this.ACTION_RECORD;
        this.BACKTRACK = this.BACKTRACK_RECORD;
        this.LA = this.LA_RECORD;
      });
    }
    disableRecording() {
      this.RECORDING_PHASE = false;
      this.TRACE_INIT("Deleting Recording methods", () => {
        const that = this;
        for (let i = 0; i < 10; i++) {
          const idx = i > 0 ? i : "";
          delete that[`CONSUME${idx}`];
          delete that[`SUBRULE${idx}`];
          delete that[`OPTION${idx}`];
          delete that[`OR${idx}`];
          delete that[`MANY${idx}`];
          delete that[`MANY_SEP${idx}`];
          delete that[`AT_LEAST_ONE${idx}`];
          delete that[`AT_LEAST_ONE_SEP${idx}`];
        }
        delete that[`consume`];
        delete that[`subrule`];
        delete that[`option`];
        delete that[`or`];
        delete that[`many`];
        delete that[`atLeastOne`];
        delete that.ACTION;
        delete that.BACKTRACK;
        delete that.LA;
      });
    }
    //   Parser methods are called inside an ACTION?
    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
    // @ts-expect-error -- noop place holder
    ACTION_RECORD(impl) {
    }
    // Executing backtracking logic will break our recording logic assumptions
    BACKTRACK_RECORD(grammarRule, args) {
      return () => true;
    }
    // LA is part of the official API and may be used for custom lookahead logic
    // by end users who may forget to wrap it in ACTION or inside a GATE
    LA_RECORD(howMuch) {
      return END_OF_FILE;
    }
    topLevelRuleRecord(name, def) {
      try {
        const newTopLevelRule = new Rule({ definition: [], name });
        newTopLevelRule.name = name;
        this.recordingProdStack.push(newTopLevelRule);
        def.call(this);
        this.recordingProdStack.pop();
        return newTopLevelRule;
      } catch (originalError) {
        if (originalError.KNOWN_RECORDER_ERROR !== true) {
          try {
            originalError.message = originalError.message + '\n	 This error was thrown during the "grammar recording phase" For more info see:\n	https://chevrotain.io/docs/guide/internals.html#grammar-recording';
          } catch (mutabilityError) {
            throw originalError;
          }
        }
        throw originalError;
      }
    }
    // Implementation of parsing DSL
    optionInternalRecord(actionORMethodDef, occurrence) {
      return recordProd.call(this, Option, actionORMethodDef, occurrence);
    }
    atLeastOneInternalRecord(occurrence, actionORMethodDef) {
      recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);
    }
    atLeastOneSepFirstInternalRecord(occurrence, options) {
      recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
    }
    manyInternalRecord(occurrence, actionORMethodDef) {
      recordProd.call(this, Repetition, actionORMethodDef, occurrence);
    }
    manySepFirstInternalRecord(occurrence, options) {
      recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
    }
    orInternalRecord(altsOrOpts, occurrence) {
      return recordOrProd.call(this, altsOrOpts, occurrence);
    }
    subruleInternalRecord(ruleToCall, occurrence, options) {
      assertMethodIdxIsValid(occurrence);
      if (!ruleToCall || has_default(ruleToCall, "ruleName") === false) {
        const error = new Error(`<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
      }
      const prevProd = last_default(this.recordingProdStack);
      const ruleName = ruleToCall.ruleName;
      const newNoneTerminal = new NonTerminal({
        idx: occurrence,
        nonTerminalName: ruleName,
        label: options === null || options === void 0 ? void 0 : options.LABEL,
        // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
        referencedRule: void 0
      });
      prevProd.definition.push(newNoneTerminal);
      return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
    }
    consumeInternalRecord(tokType, occurrence, options) {
      assertMethodIdxIsValid(occurrence);
      if (!hasShortKeyProperty(tokType)) {
        const error = new Error(`<CONSUME${getIdxSuffix(occurrence)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(tokType)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
      }
      const prevProd = last_default(this.recordingProdStack);
      const newNoneTerminal = new Terminal({
        idx: occurrence,
        terminalType: tokType,
        label: options === null || options === void 0 ? void 0 : options.LABEL
      });
      prevProd.definition.push(newNoneTerminal);
      return RECORDING_PHASE_TOKEN;
    }
  };
  function recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {
    assertMethodIdxIsValid(occurrence);
    const prevProd = last_default(this.recordingProdStack);
    const grammarAction = isFunction_default(mainProdArg) ? mainProdArg : mainProdArg.DEF;
    const newProd = new prodConstructor({ definition: [], idx: occurrence });
    if (handleSep) {
      newProd.separator = mainProdArg.SEP;
    }
    if (has_default(mainProdArg, "MAX_LOOKAHEAD")) {
      newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    }
    this.recordingProdStack.push(newProd);
    grammarAction.call(this);
    prevProd.definition.push(newProd);
    this.recordingProdStack.pop();
    return RECORDING_NULL_OBJECT;
  }
  function recordOrProd(mainProdArg, occurrence) {
    assertMethodIdxIsValid(occurrence);
    const prevProd = last_default(this.recordingProdStack);
    const hasOptions = isArray_default(mainProdArg) === false;
    const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
    const newOrProd = new Alternation({
      definition: [],
      idx: occurrence,
      ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
    });
    if (has_default(mainProdArg, "MAX_LOOKAHEAD")) {
      newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    }
    const hasPredicates = some_default(alts, (currAlt) => isFunction_default(currAlt.GATE));
    newOrProd.hasPredicates = hasPredicates;
    prevProd.definition.push(newOrProd);
    forEach_default(alts, (currAlt) => {
      const currAltFlat = new Alternative({ definition: [] });
      newOrProd.definition.push(currAltFlat);
      if (has_default(currAlt, "IGNORE_AMBIGUITIES")) {
        currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
      } else if (has_default(currAlt, "GATE")) {
        currAltFlat.ignoreAmbiguities = true;
      }
      this.recordingProdStack.push(currAltFlat);
      currAlt.ALT.call(this);
      this.recordingProdStack.pop();
    });
    return RECORDING_NULL_OBJECT;
  }
  function getIdxSuffix(idx) {
    return idx === 0 ? "" : `${idx}`;
  }
  function assertMethodIdxIsValid(idx) {
    if (idx < 0 || idx > MAX_METHOD_IDX) {
      const error = new Error(
        // The stack trace will contain all the needed details
        `Invalid DSL Method idx value: <${idx}>
	Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`
      );
      error.KNOWN_RECORDER_ERROR = true;
      throw error;
    }
  }

  // ../node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js
  var PerformanceTracer = class {
    initPerformanceTracer(config) {
      if (has_default(config, "traceInitPerf")) {
        const userTraceInitPerf = config.traceInitPerf;
        const traceIsNumber = typeof userTraceInitPerf === "number";
        this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
        this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;
      } else {
        this.traceInitMaxIdent = 0;
        this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;
      }
      this.traceInitIndent = -1;
    }
    TRACE_INIT(phaseDesc, phaseImpl) {
      if (this.traceInitPerf === true) {
        this.traceInitIndent++;
        const indent = new Array(this.traceInitIndent + 1).join("	");
        if (this.traceInitIndent < this.traceInitMaxIdent) {
          console.log(`${indent}--> <${phaseDesc}>`);
        }
        const { time, value } = timer(phaseImpl);
        const traceMethod = time > 10 ? console.warn : console.log;
        if (this.traceInitIndent < this.traceInitMaxIdent) {
          traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);
        }
        this.traceInitIndent--;
        return value;
      } else {
        return phaseImpl();
      }
    }
  };

  // ../node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js
  function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach((baseCtor) => {
      const baseProto = baseCtor.prototype;
      Object.getOwnPropertyNames(baseProto).forEach((propName) => {
        if (propName === "constructor") {
          return;
        }
        const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
        if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {
          Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
        } else {
          derivedCtor.prototype[propName] = baseCtor.prototype[propName];
        }
      });
    });
  }

  // ../node_modules/chevrotain/lib/src/parse/parser/parser.js
  var END_OF_FILE = createTokenInstance(EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
  Object.freeze(END_OF_FILE);
  var DEFAULT_PARSER_CONFIG = Object.freeze({
    recoveryEnabled: false,
    maxLookahead: 3,
    dynamicTokensEnabled: false,
    outputCst: true,
    errorMessageProvider: defaultParserErrorProvider,
    nodeLocationTracking: "none",
    traceInitPerf: false,
    skipValidations: false
  });
  var DEFAULT_RULE_CONFIG = Object.freeze({
    recoveryValueFunc: () => void 0,
    resyncEnabled: true
  });
  var ParserDefinitionErrorType;
  (function(ParserDefinitionErrorType2) {
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
    ParserDefinitionErrorType2[ParserDefinitionErrorType2["CUSTOM_LOOKAHEAD_VALIDATION"] = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
  })(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));
  function EMPTY_ALT(value = void 0) {
    return function() {
      return value;
    };
  }
  var Parser = class _Parser {
    /**
     *  @deprecated use the **instance** method with the same name instead
     */
    static performSelfAnalysis(parserInstance) {
      throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
    }
    performSelfAnalysis() {
      this.TRACE_INIT("performSelfAnalysis", () => {
        let defErrorsMsgs;
        this.selfAnalysisDone = true;
        const className = this.className;
        this.TRACE_INIT("toFastProps", () => {
          toFastProperties(this);
        });
        this.TRACE_INIT("Grammar Recording", () => {
          try {
            this.enableRecording();
            forEach_default(this.definedRulesNames, (currRuleName) => {
              const wrappedRule = this[currRuleName];
              const originalGrammarAction = wrappedRule["originalGrammarAction"];
              let recordedRuleGast;
              this.TRACE_INIT(`${currRuleName} Rule`, () => {
                recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);
              });
              this.gastProductionsCache[currRuleName] = recordedRuleGast;
            });
          } finally {
            this.disableRecording();
          }
        });
        let resolverErrors = [];
        this.TRACE_INIT("Grammar Resolving", () => {
          resolverErrors = resolveGrammar2({
            rules: values_default(this.gastProductionsCache)
          });
          this.definitionErrors = this.definitionErrors.concat(resolverErrors);
        });
        this.TRACE_INIT("Grammar Validations", () => {
          if (isEmpty_default(resolverErrors) && this.skipValidations === false) {
            const validationErrors = validateGrammar2({
              rules: values_default(this.gastProductionsCache),
              tokenTypes: values_default(this.tokensMap),
              errMsgProvider: defaultGrammarValidatorErrorProvider,
              grammarName: className
            });
            const lookaheadValidationErrors = validateLookahead({
              lookaheadStrategy: this.lookaheadStrategy,
              rules: values_default(this.gastProductionsCache),
              tokenTypes: values_default(this.tokensMap),
              grammarName: className
            });
            this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);
          }
        });
        if (isEmpty_default(this.definitionErrors)) {
          if (this.recoveryEnabled) {
            this.TRACE_INIT("computeAllProdsFollows", () => {
              const allFollows = computeAllProdsFollows(values_default(this.gastProductionsCache));
              this.resyncFollows = allFollows;
            });
          }
          this.TRACE_INIT("ComputeLookaheadFunctions", () => {
            var _a, _b;
            (_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {
              rules: values_default(this.gastProductionsCache)
            });
            this.preComputeLookaheadFunctions(values_default(this.gastProductionsCache));
          });
        }
        if (!_Parser.DEFER_DEFINITION_ERRORS_HANDLING && !isEmpty_default(this.definitionErrors)) {
          defErrorsMsgs = map_default(this.definitionErrors, (defError) => defError.message);
          throw new Error(`Parser Definition Errors detected:
 ${defErrorsMsgs.join("\n-------------------------------\n")}`);
        }
      });
    }
    constructor(tokenVocabulary, config) {
      this.definitionErrors = [];
      this.selfAnalysisDone = false;
      const that = this;
      that.initErrorHandler(config);
      that.initLexerAdapter();
      that.initLooksAhead(config);
      that.initRecognizerEngine(tokenVocabulary, config);
      that.initRecoverable(config);
      that.initTreeBuilder(config);
      that.initContentAssist();
      that.initGastRecorder(config);
      that.initPerformanceTracer(config);
      if (has_default(config, "ignoredIssues")) {
        throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.");
      }
      this.skipValidations = has_default(config, "skipValidations") ? config.skipValidations : DEFAULT_PARSER_CONFIG.skipValidations;
    }
  };
  Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;
  applyMixins(Parser, [
    Recoverable,
    LooksAhead,
    TreeBuilder,
    LexerAdapter,
    RecognizerEngine,
    RecognizerApi,
    ErrorHandler,
    ContentAssist,
    GastRecorder,
    PerformanceTracer
  ]);
  var EmbeddedActionsParser = class extends Parser {
    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {
      const configClone = clone_default(config);
      configClone.outputCst = false;
      super(tokenVocabulary, configClone);
    }
  };

  // ../node_modules/chevrotain-allstar/lib/atn.js
  function buildATNKey(rule, type, occurrence) {
    return `${rule.name}_${type}_${occurrence}`;
  }
  var ATN_BASIC = 1;
  var ATN_RULE_START = 2;
  var ATN_PLUS_BLOCK_START = 4;
  var ATN_STAR_BLOCK_START = 5;
  var ATN_RULE_STOP = 7;
  var ATN_BLOCK_END = 8;
  var ATN_STAR_LOOP_BACK = 9;
  var ATN_STAR_LOOP_ENTRY = 10;
  var ATN_PLUS_LOOP_BACK = 11;
  var ATN_LOOP_END = 12;
  var AbstractTransition = class {
    constructor(target) {
      this.target = target;
    }
    isEpsilon() {
      return false;
    }
  };
  var AtomTransition = class extends AbstractTransition {
    constructor(target, tokenType) {
      super(target);
      this.tokenType = tokenType;
    }
  };
  var EpsilonTransition = class extends AbstractTransition {
    constructor(target) {
      super(target);
    }
    isEpsilon() {
      return true;
    }
  };
  var RuleTransition = class extends AbstractTransition {
    constructor(ruleStart, rule, followState) {
      super(ruleStart);
      this.rule = rule;
      this.followState = followState;
    }
    isEpsilon() {
      return true;
    }
  };
  function createATN(rules) {
    const atn = {
      decisionMap: {},
      decisionStates: [],
      ruleToStartState: /* @__PURE__ */ new Map(),
      ruleToStopState: /* @__PURE__ */ new Map(),
      states: []
    };
    createRuleStartAndStopATNStates(atn, rules);
    const ruleLength = rules.length;
    for (let i = 0; i < ruleLength; i++) {
      const rule = rules[i];
      const ruleBlock = block(atn, rule, rule);
      if (ruleBlock === void 0) {
        continue;
      }
      buildRuleHandle(atn, rule, ruleBlock);
    }
    return atn;
  }
  function createRuleStartAndStopATNStates(atn, rules) {
    const ruleLength = rules.length;
    for (let i = 0; i < ruleLength; i++) {
      const rule = rules[i];
      const start = newState(atn, rule, void 0, {
        type: ATN_RULE_START
      });
      const stop = newState(atn, rule, void 0, {
        type: ATN_RULE_STOP
      });
      start.stop = stop;
      atn.ruleToStartState.set(rule, start);
      atn.ruleToStopState.set(rule, stop);
    }
  }
  function atom(atn, rule, production) {
    if (production instanceof Terminal) {
      return tokenRef(atn, rule, production.terminalType, production);
    } else if (production instanceof NonTerminal) {
      return ruleRef(atn, rule, production);
    } else if (production instanceof Alternation) {
      return alternation(atn, rule, production);
    } else if (production instanceof Option) {
      return option(atn, rule, production);
    } else if (production instanceof Repetition) {
      return repetition(atn, rule, production);
    } else if (production instanceof RepetitionWithSeparator) {
      return repetitionSep(atn, rule, production);
    } else if (production instanceof RepetitionMandatory) {
      return repetitionMandatory(atn, rule, production);
    } else if (production instanceof RepetitionMandatoryWithSeparator) {
      return repetitionMandatorySep(atn, rule, production);
    } else {
      return block(atn, rule, production);
    }
  }
  function repetition(atn, rule, repetition2) {
    const starState = newState(atn, rule, repetition2, {
      type: ATN_STAR_BLOCK_START
    });
    defineDecisionState(atn, starState);
    const handle = makeAlts(atn, rule, starState, repetition2, block(atn, rule, repetition2));
    return star(atn, rule, repetition2, handle);
  }
  function repetitionSep(atn, rule, repetition2) {
    const starState = newState(atn, rule, repetition2, {
      type: ATN_STAR_BLOCK_START
    });
    defineDecisionState(atn, starState);
    const handle = makeAlts(atn, rule, starState, repetition2, block(atn, rule, repetition2));
    const sep = tokenRef(atn, rule, repetition2.separator, repetition2);
    return star(atn, rule, repetition2, handle, sep);
  }
  function repetitionMandatory(atn, rule, repetition2) {
    const plusState = newState(atn, rule, repetition2, {
      type: ATN_PLUS_BLOCK_START
    });
    defineDecisionState(atn, plusState);
    const handle = makeAlts(atn, rule, plusState, repetition2, block(atn, rule, repetition2));
    return plus(atn, rule, repetition2, handle);
  }
  function repetitionMandatorySep(atn, rule, repetition2) {
    const plusState = newState(atn, rule, repetition2, {
      type: ATN_PLUS_BLOCK_START
    });
    defineDecisionState(atn, plusState);
    const handle = makeAlts(atn, rule, plusState, repetition2, block(atn, rule, repetition2));
    const sep = tokenRef(atn, rule, repetition2.separator, repetition2);
    return plus(atn, rule, repetition2, handle, sep);
  }
  function alternation(atn, rule, alternation2) {
    const start = newState(atn, rule, alternation2, {
      type: ATN_BASIC
    });
    defineDecisionState(atn, start);
    const alts = map_default(alternation2.definition, (e) => atom(atn, rule, e));
    const handle = makeAlts(atn, rule, start, alternation2, ...alts);
    return handle;
  }
  function option(atn, rule, option2) {
    const start = newState(atn, rule, option2, {
      type: ATN_BASIC
    });
    defineDecisionState(atn, start);
    const handle = makeAlts(atn, rule, start, option2, block(atn, rule, option2));
    return optional(atn, rule, option2, handle);
  }
  function block(atn, rule, block2) {
    const handles = filter_default(map_default(block2.definition, (e) => atom(atn, rule, e)), (e) => e !== void 0);
    if (handles.length === 1) {
      return handles[0];
    } else if (handles.length === 0) {
      return void 0;
    } else {
      return makeBlock(atn, handles);
    }
  }
  function plus(atn, rule, plus2, handle, sep) {
    const blkStart = handle.left;
    const blkEnd = handle.right;
    const loop = newState(atn, rule, plus2, {
      type: ATN_PLUS_LOOP_BACK
    });
    defineDecisionState(atn, loop);
    const end = newState(atn, rule, plus2, {
      type: ATN_LOOP_END
    });
    blkStart.loopback = loop;
    end.loopback = loop;
    atn.decisionMap[buildATNKey(rule, sep ? "RepetitionMandatoryWithSeparator" : "RepetitionMandatory", plus2.idx)] = loop;
    epsilon(blkEnd, loop);
    if (sep === void 0) {
      epsilon(loop, blkStart);
      epsilon(loop, end);
    } else {
      epsilon(loop, end);
      epsilon(loop, sep.left);
      epsilon(sep.right, blkStart);
    }
    return {
      left: blkStart,
      right: end
    };
  }
  function star(atn, rule, star2, handle, sep) {
    const start = handle.left;
    const end = handle.right;
    const entry = newState(atn, rule, star2, {
      type: ATN_STAR_LOOP_ENTRY
    });
    defineDecisionState(atn, entry);
    const loopEnd = newState(atn, rule, star2, {
      type: ATN_LOOP_END
    });
    const loop = newState(atn, rule, star2, {
      type: ATN_STAR_LOOP_BACK
    });
    entry.loopback = loop;
    loopEnd.loopback = loop;
    epsilon(entry, start);
    epsilon(entry, loopEnd);
    epsilon(end, loop);
    if (sep !== void 0) {
      epsilon(loop, loopEnd);
      epsilon(loop, sep.left);
      epsilon(sep.right, start);
    } else {
      epsilon(loop, entry);
    }
    atn.decisionMap[buildATNKey(rule, sep ? "RepetitionWithSeparator" : "Repetition", star2.idx)] = entry;
    return {
      left: entry,
      right: loopEnd
    };
  }
  function optional(atn, rule, optional2, handle) {
    const start = handle.left;
    const end = handle.right;
    epsilon(start, end);
    atn.decisionMap[buildATNKey(rule, "Option", optional2.idx)] = start;
    return handle;
  }
  function defineDecisionState(atn, state) {
    atn.decisionStates.push(state);
    state.decision = atn.decisionStates.length - 1;
    return state.decision;
  }
  function makeAlts(atn, rule, start, production, ...alts) {
    const end = newState(atn, rule, production, {
      type: ATN_BLOCK_END,
      start
    });
    start.end = end;
    for (const alt of alts) {
      if (alt !== void 0) {
        epsilon(start, alt.left);
        epsilon(alt.right, end);
      } else {
        epsilon(start, end);
      }
    }
    const handle = {
      left: start,
      right: end
    };
    atn.decisionMap[buildATNKey(rule, getProdType2(production), production.idx)] = start;
    return handle;
  }
  function getProdType2(production) {
    if (production instanceof Alternation) {
      return "Alternation";
    } else if (production instanceof Option) {
      return "Option";
    } else if (production instanceof Repetition) {
      return "Repetition";
    } else if (production instanceof RepetitionWithSeparator) {
      return "RepetitionWithSeparator";
    } else if (production instanceof RepetitionMandatory) {
      return "RepetitionMandatory";
    } else if (production instanceof RepetitionMandatoryWithSeparator) {
      return "RepetitionMandatoryWithSeparator";
    } else {
      throw new Error("Invalid production type encountered");
    }
  }
  function makeBlock(atn, alts) {
    const altsLength = alts.length;
    for (let i = 0; i < altsLength - 1; i++) {
      const handle = alts[i];
      let transition;
      if (handle.left.transitions.length === 1) {
        transition = handle.left.transitions[0];
      }
      const isRuleTransition = transition instanceof RuleTransition;
      const ruleTransition = transition;
      const next = alts[i + 1].left;
      if (handle.left.type === ATN_BASIC && handle.right.type === ATN_BASIC && transition !== void 0 && (isRuleTransition && ruleTransition.followState === handle.right || transition.target === handle.right)) {
        if (isRuleTransition) {
          ruleTransition.followState = next;
        } else {
          transition.target = next;
        }
        removeState(atn, handle.right);
      } else {
        epsilon(handle.right, next);
      }
    }
    const first2 = alts[0];
    const last2 = alts[altsLength - 1];
    return {
      left: first2.left,
      right: last2.right
    };
  }
  function tokenRef(atn, rule, tokenType, production) {
    const left = newState(atn, rule, production, {
      type: ATN_BASIC
    });
    const right = newState(atn, rule, production, {
      type: ATN_BASIC
    });
    addTransition(left, new AtomTransition(right, tokenType));
    return {
      left,
      right
    };
  }
  function ruleRef(atn, currentRule, nonTerminal) {
    const rule = nonTerminal.referencedRule;
    const start = atn.ruleToStartState.get(rule);
    const left = newState(atn, currentRule, nonTerminal, {
      type: ATN_BASIC
    });
    const right = newState(atn, currentRule, nonTerminal, {
      type: ATN_BASIC
    });
    const call = new RuleTransition(start, rule, right);
    addTransition(left, call);
    return {
      left,
      right
    };
  }
  function buildRuleHandle(atn, rule, block2) {
    const start = atn.ruleToStartState.get(rule);
    epsilon(start, block2.left);
    const stop = atn.ruleToStopState.get(rule);
    epsilon(block2.right, stop);
    const handle = {
      left: start,
      right: stop
    };
    return handle;
  }
  function epsilon(a2, b) {
    const transition = new EpsilonTransition(b);
    addTransition(a2, transition);
  }
  function newState(atn, rule, production, partial) {
    const t = Object.assign({
      atn,
      production,
      epsilonOnlyTransitions: false,
      rule,
      transitions: [],
      nextTokenWithinRule: [],
      stateNumber: atn.states.length
    }, partial);
    atn.states.push(t);
    return t;
  }
  function addTransition(state, transition) {
    if (state.transitions.length === 0) {
      state.epsilonOnlyTransitions = transition.isEpsilon();
    }
    state.transitions.push(transition);
  }
  function removeState(atn, state) {
    atn.states.splice(atn.states.indexOf(state), 1);
  }

  // ../node_modules/chevrotain-allstar/lib/dfa.js
  var DFA_ERROR = {};
  var ATNConfigSet = class {
    constructor() {
      this.map = {};
      this.configs = [];
    }
    get size() {
      return this.configs.length;
    }
    finalize() {
      this.map = {};
    }
    add(config) {
      const key = getATNConfigKey(config);
      if (!(key in this.map)) {
        this.map[key] = this.configs.length;
        this.configs.push(config);
      }
    }
    get elements() {
      return this.configs;
    }
    get alts() {
      return map_default(this.configs, (e) => e.alt);
    }
    get key() {
      let value = "";
      for (const k in this.map) {
        value += k + ":";
      }
      return value;
    }
  };
  function getATNConfigKey(config, alt = true) {
    return `${alt ? `a${config.alt}` : ""}s${config.state.stateNumber}:${config.stack.map((e) => e.stateNumber.toString()).join("_")}`;
  }

  // ../node_modules/chevrotain-allstar/lib/all-star-lookahead.js
  function createDFACache(startState, decision) {
    const map2 = {};
    return (predicateSet) => {
      const key = predicateSet.toString();
      let existing = map2[key];
      if (existing !== void 0) {
        return existing;
      } else {
        existing = {
          atnStartState: startState,
          decision,
          states: {}
        };
        map2[key] = existing;
        return existing;
      }
    };
  }
  var PredicateSet = class {
    constructor() {
      this.predicates = [];
    }
    is(index) {
      return index >= this.predicates.length || this.predicates[index];
    }
    set(index, value) {
      this.predicates[index] = value;
    }
    toString() {
      let value = "";
      const size = this.predicates.length;
      for (let i = 0; i < size; i++) {
        value += this.predicates[i] === true ? "1" : "0";
      }
      return value;
    }
  };
  var EMPTY_PREDICATES = new PredicateSet();
  var LLStarLookaheadStrategy = class extends LLkLookaheadStrategy {
    constructor(options) {
      var _a;
      super();
      this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : (message) => console.log(message);
    }
    initialize(options) {
      this.atn = createATN(options.rules);
      this.dfas = initATNSimulator(this.atn);
    }
    validateAmbiguousAlternationAlternatives() {
      return [];
    }
    validateEmptyOrAlternatives() {
      return [];
    }
    buildLookaheadForAlternation(options) {
      const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;
      const dfas = this.dfas;
      const logging = this.logging;
      const key = buildATNKey(rule, "Alternation", prodOccurrence);
      const decisionState = this.atn.decisionMap[key];
      const decisionIndex = decisionState.decision;
      const partialAlts = map_default(getLookaheadPaths({
        maxLookahead: 1,
        occurrence: prodOccurrence,
        prodType: "Alternation",
        rule
      }), (currAlt) => map_default(currAlt, (path) => path[0]));
      if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {
        const choiceToAlt = reduce_default(partialAlts, (result, currAlt, idx) => {
          forEach_default(currAlt, (currTokType) => {
            if (currTokType) {
              result[currTokType.tokenTypeIdx] = idx;
              forEach_default(currTokType.categoryMatches, (currExtendingType) => {
                result[currExtendingType] = idx;
              });
            }
          });
          return result;
        }, {});
        if (hasPredicates) {
          return function(orAlts) {
            var _a;
            const nextToken = this.LA(1);
            const prediction = choiceToAlt[nextToken.tokenTypeIdx];
            if (orAlts !== void 0 && prediction !== void 0) {
              const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;
              if (gate !== void 0 && gate.call(this) === false) {
                return void 0;
              }
            }
            return prediction;
          };
        } else {
          return function() {
            const nextToken = this.LA(1);
            return choiceToAlt[nextToken.tokenTypeIdx];
          };
        }
      } else if (hasPredicates) {
        return function(orAlts) {
          const predicates = new PredicateSet();
          const length = orAlts === void 0 ? 0 : orAlts.length;
          for (let i = 0; i < length; i++) {
            const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;
            predicates.set(i, gate === void 0 || gate.call(this));
          }
          const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);
          return typeof result === "number" ? result : void 0;
        };
      } else {
        return function() {
          const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);
          return typeof result === "number" ? result : void 0;
        };
      }
    }
    buildLookaheadForOptional(options) {
      const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;
      const dfas = this.dfas;
      const logging = this.logging;
      const key = buildATNKey(rule, prodType, prodOccurrence);
      const decisionState = this.atn.decisionMap[key];
      const decisionIndex = decisionState.decision;
      const alts = map_default(getLookaheadPaths({
        maxLookahead: 1,
        occurrence: prodOccurrence,
        prodType,
        rule
      }), (e) => {
        return map_default(e, (g) => g[0]);
      });
      if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {
        const alt = alts[0];
        const singleTokensTypes = flatten_default(alt);
        if (singleTokensTypes.length === 1 && isEmpty_default(singleTokensTypes[0].categoryMatches)) {
          const expectedTokenType = singleTokensTypes[0];
          const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;
          return function() {
            return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;
          };
        } else {
          const choiceToAlt = reduce_default(singleTokensTypes, (result, currTokType) => {
            if (currTokType !== void 0) {
              result[currTokType.tokenTypeIdx] = true;
              forEach_default(currTokType.categoryMatches, (currExtendingType) => {
                result[currExtendingType] = true;
              });
            }
            return result;
          }, {});
          return function() {
            const nextToken = this.LA(1);
            return choiceToAlt[nextToken.tokenTypeIdx] === true;
          };
        }
      }
      return function() {
        const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);
        return typeof result === "object" ? false : result === 0;
      };
    }
  };
  function isLL1Sequence(sequences, allowEmpty = true) {
    const fullSet = /* @__PURE__ */ new Set();
    for (const alt of sequences) {
      const altSet = /* @__PURE__ */ new Set();
      for (const tokType of alt) {
        if (tokType === void 0) {
          if (allowEmpty) {
            break;
          } else {
            return false;
          }
        }
        const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);
        for (const index of indices) {
          if (fullSet.has(index)) {
            if (!altSet.has(index)) {
              return false;
            }
          } else {
            fullSet.add(index);
            altSet.add(index);
          }
        }
      }
    }
    return true;
  }
  function initATNSimulator(atn) {
    const decisionLength = atn.decisionStates.length;
    const decisionToDFA = Array(decisionLength);
    for (let i = 0; i < decisionLength; i++) {
      decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);
    }
    return decisionToDFA;
  }
  function adaptivePredict(dfaCaches, decision, predicateSet, logging) {
    const dfa = dfaCaches[decision](predicateSet);
    let start = dfa.start;
    if (start === void 0) {
      const closure2 = computeStartState(dfa.atnStartState);
      start = addDFAState(dfa, newDFAState(closure2));
      dfa.start = start;
    }
    const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);
    return alt;
  }
  function performLookahead(dfa, s0, predicateSet, logging) {
    let previousD = s0;
    let i = 1;
    const path = [];
    let t = this.LA(i++);
    while (true) {
      let d = getExistingTargetState(previousD, t);
      if (d === void 0) {
        d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);
      }
      if (d === DFA_ERROR) {
        return buildAdaptivePredictError(path, previousD, t);
      }
      if (d.isAcceptState === true) {
        return d.prediction;
      }
      previousD = d;
      path.push(t);
      t = this.LA(i++);
    }
  }
  function computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {
    const reach = computeReachSet(previousD.configs, token, predicateSet);
    if (reach.size === 0) {
      addDFAEdge(dfa, previousD, token, DFA_ERROR);
      return DFA_ERROR;
    }
    let newState2 = newDFAState(reach);
    const predictedAlt = getUniqueAlt(reach, predicateSet);
    if (predictedAlt !== void 0) {
      newState2.isAcceptState = true;
      newState2.prediction = predictedAlt;
      newState2.configs.uniqueAlt = predictedAlt;
    } else if (hasConflictTerminatingPrediction(reach)) {
      const prediction = min_default(reach.alts);
      newState2.isAcceptState = true;
      newState2.prediction = prediction;
      newState2.configs.uniqueAlt = prediction;
      reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);
    }
    newState2 = addDFAEdge(dfa, previousD, token, newState2);
    return newState2;
  }
  function reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {
    const prefixPath = [];
    for (let i = 1; i <= lookahead; i++) {
      prefixPath.push(this.LA(i).tokenType);
    }
    const atnState = dfa.atnStartState;
    const topLevelRule = atnState.rule;
    const production = atnState.production;
    const message = buildAmbiguityError({
      topLevelRule,
      ambiguityIndices,
      production,
      prefixPath
    });
    logging(message);
  }
  function buildAmbiguityError(options) {
    const pathMsg = map_default(options.prefixPath, (currtok) => tokenLabel2(currtok)).join(", ");
    const occurrence = options.production.idx === 0 ? "" : options.production.idx;
    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(", ")}> in <${getProductionDslName2(options.production)}${occurrence}> inside <${options.topLevelRule.name}> Rule,
<${pathMsg}> may appears as a prefix path in all these alternatives.
`;
    currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`;
    return currMessage;
  }
  function getProductionDslName2(prod) {
    if (prod instanceof NonTerminal) {
      return "SUBRULE";
    } else if (prod instanceof Option) {
      return "OPTION";
    } else if (prod instanceof Alternation) {
      return "OR";
    } else if (prod instanceof RepetitionMandatory) {
      return "AT_LEAST_ONE";
    } else if (prod instanceof RepetitionMandatoryWithSeparator) {
      return "AT_LEAST_ONE_SEP";
    } else if (prod instanceof RepetitionWithSeparator) {
      return "MANY_SEP";
    } else if (prod instanceof Repetition) {
      return "MANY";
    } else if (prod instanceof Terminal) {
      return "CONSUME";
    } else {
      throw Error("non exhaustive match");
    }
  }
  function buildAdaptivePredictError(path, previous, current) {
    const nextTransitions = flatMap_default(previous.configs.elements, (e) => e.state.transitions);
    const nextTokenTypes = uniqBy_default(nextTransitions.filter((e) => e instanceof AtomTransition).map((e) => e.tokenType), (e) => e.tokenTypeIdx);
    return {
      actualToken: current,
      possibleTokenTypes: nextTokenTypes,
      tokenPath: path
    };
  }
  function getExistingTargetState(state, token) {
    return state.edges[token.tokenTypeIdx];
  }
  function computeReachSet(configs, token, predicateSet) {
    const intermediate = new ATNConfigSet();
    const skippedStopStates = [];
    for (const c of configs.elements) {
      if (predicateSet.is(c.alt) === false) {
        continue;
      }
      if (c.state.type === ATN_RULE_STOP) {
        skippedStopStates.push(c);
        continue;
      }
      const transitionLength = c.state.transitions.length;
      for (let i = 0; i < transitionLength; i++) {
        const transition = c.state.transitions[i];
        const target = getReachableTarget(transition, token);
        if (target !== void 0) {
          intermediate.add({
            state: target,
            alt: c.alt,
            stack: c.stack
          });
        }
      }
    }
    let reach;
    if (skippedStopStates.length === 0 && intermediate.size === 1) {
      reach = intermediate;
    }
    if (reach === void 0) {
      reach = new ATNConfigSet();
      for (const c of intermediate.elements) {
        closure(c, reach);
      }
    }
    if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {
      for (const c of skippedStopStates) {
        reach.add(c);
      }
    }
    return reach;
  }
  function getReachableTarget(transition, token) {
    if (transition instanceof AtomTransition && tokenMatcher(token, transition.tokenType)) {
      return transition.target;
    }
    return void 0;
  }
  function getUniqueAlt(configs, predicateSet) {
    let alt;
    for (const c of configs.elements) {
      if (predicateSet.is(c.alt) === true) {
        if (alt === void 0) {
          alt = c.alt;
        } else if (alt !== c.alt) {
          return void 0;
        }
      }
    }
    return alt;
  }
  function newDFAState(closure2) {
    return {
      configs: closure2,
      edges: {},
      isAcceptState: false,
      prediction: -1
    };
  }
  function addDFAEdge(dfa, from, token, to) {
    to = addDFAState(dfa, to);
    from.edges[token.tokenTypeIdx] = to;
    return to;
  }
  function addDFAState(dfa, state) {
    if (state === DFA_ERROR) {
      return state;
    }
    const mapKey = state.configs.key;
    const existing = dfa.states[mapKey];
    if (existing !== void 0) {
      return existing;
    }
    state.configs.finalize();
    dfa.states[mapKey] = state;
    return state;
  }
  function computeStartState(atnState) {
    const configs = new ATNConfigSet();
    const numberOfTransitions = atnState.transitions.length;
    for (let i = 0; i < numberOfTransitions; i++) {
      const target = atnState.transitions[i].target;
      const config = {
        state: target,
        alt: i,
        stack: []
      };
      closure(config, configs);
    }
    return configs;
  }
  function closure(config, configs) {
    const p = config.state;
    if (p.type === ATN_RULE_STOP) {
      if (config.stack.length > 0) {
        const atnStack = [...config.stack];
        const followState = atnStack.pop();
        const followConfig = {
          state: followState,
          alt: config.alt,
          stack: atnStack
        };
        closure(followConfig, configs);
      } else {
        configs.add(config);
      }
      return;
    }
    if (!p.epsilonOnlyTransitions) {
      configs.add(config);
    }
    const transitionLength = p.transitions.length;
    for (let i = 0; i < transitionLength; i++) {
      const transition = p.transitions[i];
      const c = getEpsilonTarget(config, transition);
      if (c !== void 0) {
        closure(c, configs);
      }
    }
  }
  function getEpsilonTarget(config, transition) {
    if (transition instanceof EpsilonTransition) {
      return {
        state: transition.target,
        alt: config.alt,
        stack: config.stack
      };
    } else if (transition instanceof RuleTransition) {
      const stack = [...config.stack, transition.followState];
      return {
        state: transition.target,
        alt: config.alt,
        stack
      };
    }
    return void 0;
  }
  function hasConfigInRuleStopState(configs) {
    for (const c of configs.elements) {
      if (c.state.type === ATN_RULE_STOP) {
        return true;
      }
    }
    return false;
  }
  function allConfigsInRuleStopStates(configs) {
    for (const c of configs.elements) {
      if (c.state.type !== ATN_RULE_STOP) {
        return false;
      }
    }
    return true;
  }
  function hasConflictTerminatingPrediction(configs) {
    if (allConfigsInRuleStopStates(configs)) {
      return true;
    }
    const altSets = getConflictingAltSets(configs.elements);
    const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);
    return heuristic;
  }
  function getConflictingAltSets(configs) {
    const configToAlts = /* @__PURE__ */ new Map();
    for (const c of configs) {
      const key = getATNConfigKey(c, false);
      let alts = configToAlts.get(key);
      if (alts === void 0) {
        alts = {};
        configToAlts.set(key, alts);
      }
      alts[c.alt] = true;
    }
    return configToAlts;
  }
  function hasConflictingAltSet(altSets) {
    for (const value of Array.from(altSets.values())) {
      if (Object.keys(value).length > 1) {
        return true;
      }
    }
    return false;
  }
  function hasStateAssociatedWithOneAlt(altSets) {
    for (const value of Array.from(altSets.values())) {
      if (Object.keys(value).length === 1) {
        return true;
      }
    }
    return false;
  }

  // ../node_modules/langium/lib/parser/cst-node-builder.js
  init_main();
  var CstNodeBuilder = class {
    constructor() {
      this.nodeStack = [];
    }
    get current() {
      return this.nodeStack[this.nodeStack.length - 1];
    }
    buildRootNode(input) {
      this.rootNode = new RootCstNodeImpl(input);
      this.rootNode.root = this.rootNode;
      this.nodeStack = [this.rootNode];
      return this.rootNode;
    }
    buildCompositeNode(feature) {
      const compositeNode = new CompositeCstNodeImpl();
      compositeNode.grammarSource = feature;
      compositeNode.root = this.rootNode;
      this.current.content.push(compositeNode);
      this.nodeStack.push(compositeNode);
      return compositeNode;
    }
    buildLeafNode(token, feature) {
      const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, false);
      leafNode.grammarSource = feature;
      leafNode.root = this.rootNode;
      this.current.content.push(leafNode);
      return leafNode;
    }
    removeNode(node) {
      const parent = node.container;
      if (parent) {
        const index = parent.content.indexOf(node);
        if (index >= 0) {
          parent.content.splice(index, 1);
        }
      }
    }
    construct(item) {
      const current = this.current;
      if (typeof item.$type === "string") {
        this.current.astNode = item;
      }
      item.$cstNode = current;
      const node = this.nodeStack.pop();
      if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) {
        this.removeNode(node);
      }
    }
    addHiddenTokens(hiddenTokens) {
      for (const token of hiddenTokens) {
        const hiddenNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);
        hiddenNode.root = this.rootNode;
        this.addHiddenToken(this.rootNode, hiddenNode);
      }
    }
    addHiddenToken(node, token) {
      const { offset: tokenStart, end: tokenEnd } = token;
      for (let i = 0; i < node.content.length; i++) {
        const child = node.content[i];
        const { offset: childStart, end: childEnd } = child;
        if (isCompositeCstNode(child) && tokenStart > childStart && tokenEnd < childEnd) {
          this.addHiddenToken(child, token);
          return;
        } else if (tokenEnd <= childStart) {
          node.content.splice(i, 0, token);
          return;
        }
      }
      node.content.push(token);
    }
  };
  var AbstractCstNode = class {
    /** @deprecated use `container` instead. */
    get parent() {
      return this.container;
    }
    /** @deprecated use `grammarSource` instead. */
    get feature() {
      return this.grammarSource;
    }
    get hidden() {
      return false;
    }
    get astNode() {
      var _a, _b;
      const node = typeof ((_a = this._astNode) === null || _a === void 0 ? void 0 : _a.$type) === "string" ? this._astNode : (_b = this.container) === null || _b === void 0 ? void 0 : _b.astNode;
      if (!node) {
        throw new Error("This node has no associated AST element");
      }
      return node;
    }
    set astNode(value) {
      this._astNode = value;
    }
    /** @deprecated use `astNode` instead. */
    get element() {
      return this.astNode;
    }
    get text() {
      return this.root.fullText.substring(this.offset, this.end);
    }
  };
  var LeafCstNodeImpl = class extends AbstractCstNode {
    get offset() {
      return this._offset;
    }
    get length() {
      return this._length;
    }
    get end() {
      return this._offset + this._length;
    }
    get hidden() {
      return this._hidden;
    }
    get tokenType() {
      return this._tokenType;
    }
    get range() {
      return this._range;
    }
    constructor(offset, length, range, tokenType, hidden = false) {
      super();
      this._hidden = hidden;
      this._offset = offset;
      this._tokenType = tokenType;
      this._length = length;
      this._range = range;
    }
  };
  var CompositeCstNodeImpl = class extends AbstractCstNode {
    constructor() {
      super(...arguments);
      this.content = new CstNodeContainer(this);
    }
    /** @deprecated use `content` instead. */
    get children() {
      return this.content;
    }
    get offset() {
      var _a, _b;
      return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;
    }
    get length() {
      return this.end - this.offset;
    }
    get end() {
      var _a, _b;
      return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;
    }
    get range() {
      const firstNode = this.firstNonHiddenNode;
      const lastNode = this.lastNonHiddenNode;
      if (firstNode && lastNode) {
        if (this._rangeCache === void 0) {
          const { range: firstRange } = firstNode;
          const { range: lastRange } = lastNode;
          this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };
        }
        return this._rangeCache;
      } else {
        return { start: Position.create(0, 0), end: Position.create(0, 0) };
      }
    }
    get firstNonHiddenNode() {
      for (const child of this.content) {
        if (!child.hidden) {
          return child;
        }
      }
      return this.content[0];
    }
    get lastNonHiddenNode() {
      for (let i = this.content.length - 1; i >= 0; i--) {
        const child = this.content[i];
        if (!child.hidden) {
          return child;
        }
      }
      return this.content[this.content.length - 1];
    }
  };
  var CstNodeContainer = class _CstNodeContainer extends Array {
    constructor(parent) {
      super();
      this.parent = parent;
      Object.setPrototypeOf(this, _CstNodeContainer.prototype);
    }
    push(...items) {
      this.addParents(items);
      return super.push(...items);
    }
    unshift(...items) {
      this.addParents(items);
      return super.unshift(...items);
    }
    splice(start, count, ...items) {
      this.addParents(items);
      return super.splice(start, count, ...items);
    }
    addParents(items) {
      for (const item of items) {
        item.container = this.parent;
      }
    }
  };
  var RootCstNodeImpl = class extends CompositeCstNodeImpl {
    get text() {
      return this._text.substring(this.offset, this.end);
    }
    get fullText() {
      return this._text;
    }
    constructor(input) {
      super();
      this._text = "";
      this._text = input !== null && input !== void 0 ? input : "";
    }
  };

  // ../node_modules/langium/lib/parser/langium-parser.js
  var DatatypeSymbol = Symbol("Datatype");
  function isDataTypeNode(node) {
    return node.$type === DatatypeSymbol;
  }
  var ruleSuffix = "\u200B";
  var withRuleSuffix = (name) => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;
  var AbstractLangiumParser = class {
    constructor(services) {
      this._unorderedGroups = /* @__PURE__ */ new Map();
      this.lexer = services.parser.Lexer;
      const tokens = this.lexer.definition;
      this.wrapper = new ChevrotainWrapper(tokens, Object.assign(Object.assign({}, services.parser.ParserConfig), { errorMessageProvider: services.parser.ParserErrorMessageProvider }));
    }
    alternatives(idx, choices) {
      this.wrapper.wrapOr(idx, choices);
    }
    optional(idx, callback) {
      this.wrapper.wrapOption(idx, callback);
    }
    many(idx, callback) {
      this.wrapper.wrapMany(idx, callback);
    }
    atLeastOne(idx, callback) {
      this.wrapper.wrapAtLeastOne(idx, callback);
    }
    isRecording() {
      return this.wrapper.IS_RECORDING;
    }
    get unorderedGroups() {
      return this._unorderedGroups;
    }
    getRuleStack() {
      return this.wrapper.RULE_STACK;
    }
    finalize() {
      this.wrapper.wrapSelfAnalysis();
    }
  };
  var LangiumParser = class extends AbstractLangiumParser {
    get current() {
      return this.stack[this.stack.length - 1];
    }
    constructor(services) {
      super(services);
      this.nodeBuilder = new CstNodeBuilder();
      this.stack = [];
      this.assignmentMap = /* @__PURE__ */ new Map();
      this.linker = services.references.Linker;
      this.converter = services.parser.ValueConverter;
      this.astReflection = services.shared.AstReflection;
    }
    rule(rule, impl) {
      const type = rule.fragment ? void 0 : isDataTypeRule(rule) ? DatatypeSymbol : getTypeName(rule);
      const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));
      if (rule.entry) {
        this.mainRule = ruleMethod;
      }
      return ruleMethod;
    }
    parse(input) {
      this.nodeBuilder.buildRootNode(input);
      const lexerResult = this.lexer.tokenize(input);
      this.wrapper.input = lexerResult.tokens;
      const result = this.mainRule.call(this.wrapper, {});
      this.nodeBuilder.addHiddenTokens(lexerResult.hidden);
      this.unorderedGroups.clear();
      return {
        value: result,
        lexerErrors: lexerResult.errors,
        parserErrors: this.wrapper.errors
      };
    }
    startImplementation($type, implementation) {
      return (args) => {
        if (!this.isRecording()) {
          const node = { $type };
          this.stack.push(node);
          if ($type === DatatypeSymbol) {
            node.value = "";
          }
        }
        let result;
        try {
          result = implementation(args);
        } catch (err) {
          result = void 0;
        }
        if (!this.isRecording() && result === void 0) {
          result = this.construct();
        }
        return result;
      };
    }
    consume(idx, tokenType, feature) {
      const token = this.wrapper.wrapConsume(idx, tokenType);
      if (!this.isRecording() && this.isValidToken(token)) {
        const leafNode = this.nodeBuilder.buildLeafNode(token, feature);
        const { assignment, isCrossRef } = this.getAssignment(feature);
        const current = this.current;
        if (assignment) {
          const convertedValue = isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);
          this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);
        } else if (isDataTypeNode(current)) {
          let text = token.image;
          if (!isKeyword(feature)) {
            text = this.converter.convert(text, leafNode).toString();
          }
          current.value += text;
        }
      }
    }
    /**
     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:
     *
     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed
     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.
     */
    isValidToken(token) {
      return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === "number" && !isNaN(token.endOffset);
    }
    subrule(idx, rule, feature, args) {
      let cstNode;
      if (!this.isRecording()) {
        cstNode = this.nodeBuilder.buildCompositeNode(feature);
      }
      const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);
      if (!this.isRecording() && cstNode && cstNode.length > 0) {
        this.performSubruleAssignment(subruleResult, feature, cstNode);
      }
    }
    performSubruleAssignment(result, feature, cstNode) {
      const { assignment, isCrossRef } = this.getAssignment(feature);
      if (assignment) {
        this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);
      } else if (!assignment) {
        const current = this.current;
        if (isDataTypeNode(current)) {
          current.value += result.toString();
        } else if (typeof result === "object" && result) {
          const resultKind = result.$type;
          const object = this.assignWithoutOverride(result, current);
          if (resultKind) {
            object.$type = resultKind;
          }
          const newItem = object;
          this.stack.pop();
          this.stack.push(newItem);
        }
      }
    }
    action($type, action) {
      if (!this.isRecording()) {
        let last2 = this.current;
        if (!last2.$cstNode && action.feature && action.operator) {
          last2 = this.construct(false);
          const feature = last2.$cstNode.feature;
          this.nodeBuilder.buildCompositeNode(feature);
        }
        const newItem = { $type };
        this.stack.pop();
        this.stack.push(newItem);
        if (action.feature && action.operator) {
          this.assign(action.operator, action.feature, last2, last2.$cstNode, false);
        }
      }
    }
    construct(pop = true) {
      if (this.isRecording()) {
        return void 0;
      }
      const obj = this.current;
      linkContentToContainer(obj);
      this.nodeBuilder.construct(obj);
      if (pop) {
        this.stack.pop();
      }
      if (isDataTypeNode(obj)) {
        return this.converter.convert(obj.value, obj.$cstNode);
      } else {
        assignMandatoryProperties(this.astReflection, obj);
      }
      return obj;
    }
    getAssignment(feature) {
      if (!this.assignmentMap.has(feature)) {
        const assignment = getContainerOfType(feature, isAssignment);
        this.assignmentMap.set(feature, {
          assignment,
          isCrossRef: assignment ? isCrossReference(assignment.terminal) : false
        });
      }
      return this.assignmentMap.get(feature);
    }
    assign(operator, feature, value, cstNode, isCrossRef) {
      const obj = this.current;
      let item;
      if (isCrossRef && typeof value === "string") {
        item = this.linker.buildReference(obj, feature, cstNode, value);
      } else {
        item = value;
      }
      switch (operator) {
        case "=": {
          obj[feature] = item;
          break;
        }
        case "?=": {
          obj[feature] = true;
          break;
        }
        case "+=": {
          if (!Array.isArray(obj[feature])) {
            obj[feature] = [];
          }
          obj[feature].push(item);
        }
      }
    }
    assignWithoutOverride(target, source) {
      for (const [name, existingValue] of Object.entries(source)) {
        const newValue = target[name];
        if (newValue === void 0) {
          target[name] = existingValue;
        } else if (Array.isArray(newValue) && Array.isArray(existingValue)) {
          existingValue.push(...newValue);
          target[name] = existingValue;
        }
      }
      return target;
    }
    get definitionErrors() {
      return this.wrapper.definitionErrors;
    }
  };
  var AbstractParserErrorMessageProvider = class {
    buildMismatchTokenMessage(options) {
      return defaultParserErrorProvider.buildMismatchTokenMessage(options);
    }
    buildNotAllInputParsedMessage(options) {
      return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);
    }
    buildNoViableAltMessage(options) {
      return defaultParserErrorProvider.buildNoViableAltMessage(options);
    }
    buildEarlyExitMessage(options) {
      return defaultParserErrorProvider.buildEarlyExitMessage(options);
    }
  };
  var LangiumParserErrorMessageProvider = class extends AbstractParserErrorMessageProvider {
    buildMismatchTokenMessage({ expected, actual }) {
      const expectedMsg = expected.LABEL ? "`" + expected.LABEL + "`" : expected.name.endsWith(":KW") ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'` : `token of type '${expected.name}'`;
      return `Expecting ${expectedMsg} but found \`${actual.image}\`.`;
    }
    buildNotAllInputParsedMessage({ firstRedundant }) {
      return `Expecting end of file but found \`${firstRedundant.image}\`.`;
    }
  };
  var LangiumCompletionParser = class extends AbstractLangiumParser {
    constructor() {
      super(...arguments);
      this.tokens = [];
      this.elementStack = [];
      this.lastElementStack = [];
      this.nextTokenIndex = 0;
      this.stackSize = 0;
    }
    action() {
    }
    construct() {
      return void 0;
    }
    parse(input) {
      this.resetState();
      const tokens = this.lexer.tokenize(input);
      this.tokens = tokens.tokens;
      this.wrapper.input = [...this.tokens];
      this.mainRule.call(this.wrapper, {});
      this.unorderedGroups.clear();
      return {
        tokens: this.tokens,
        elementStack: [...this.lastElementStack],
        tokenIndex: this.nextTokenIndex
      };
    }
    rule(rule, impl) {
      const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));
      if (rule.entry) {
        this.mainRule = ruleMethod;
      }
      return ruleMethod;
    }
    resetState() {
      this.elementStack = [];
      this.lastElementStack = [];
      this.nextTokenIndex = 0;
      this.stackSize = 0;
    }
    startImplementation(implementation) {
      return (args) => {
        const size = this.keepStackSize();
        try {
          implementation(args);
        } finally {
          this.resetStackSize(size);
        }
      };
    }
    removeUnexpectedElements() {
      this.elementStack.splice(this.stackSize);
    }
    keepStackSize() {
      const size = this.elementStack.length;
      this.stackSize = size;
      return size;
    }
    resetStackSize(size) {
      this.removeUnexpectedElements();
      this.stackSize = size;
    }
    consume(idx, tokenType, feature) {
      this.wrapper.wrapConsume(idx, tokenType);
      if (!this.isRecording()) {
        this.lastElementStack = [...this.elementStack, feature];
        this.nextTokenIndex = this.currIdx + 1;
      }
    }
    subrule(idx, rule, feature, args) {
      this.before(feature);
      this.wrapper.wrapSubrule(idx, rule, args);
      this.after(feature);
    }
    before(element) {
      if (!this.isRecording()) {
        this.elementStack.push(element);
      }
    }
    after(element) {
      if (!this.isRecording()) {
        const index = this.elementStack.lastIndexOf(element);
        if (index >= 0) {
          this.elementStack.splice(index);
        }
      }
    }
    get currIdx() {
      return this.wrapper.currIdx;
    }
  };
  var defaultConfig = {
    recoveryEnabled: true,
    nodeLocationTracking: "full",
    skipValidations: true,
    errorMessageProvider: new LangiumParserErrorMessageProvider()
  };
  var ChevrotainWrapper = class extends EmbeddedActionsParser {
    constructor(tokens, config) {
      const useDefaultLookahead = config && "maxLookahead" in config;
      super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig), { lookaheadStrategy: useDefaultLookahead ? new LLkLookaheadStrategy({ maxLookahead: config.maxLookahead }) : new LLStarLookaheadStrategy() }), config));
    }
    get IS_RECORDING() {
      return this.RECORDING_PHASE;
    }
    DEFINE_RULE(name, impl) {
      return this.RULE(name, impl);
    }
    wrapSelfAnalysis() {
      this.performSelfAnalysis();
    }
    wrapConsume(idx, tokenType) {
      return this.consume(idx, tokenType);
    }
    wrapSubrule(idx, rule, args) {
      return this.subrule(idx, rule, {
        ARGS: [args]
      });
    }
    wrapOr(idx, choices) {
      this.or(idx, choices);
    }
    wrapOption(idx, callback) {
      this.option(idx, callback);
    }
    wrapMany(idx, callback) {
      this.many(idx, callback);
    }
    wrapAtLeastOne(idx, callback) {
      this.atLeastOne(idx, callback);
    }
  };

  // ../node_modules/langium/lib/parser/parser-builder-base.js
  function createParser(grammar, parser, tokens) {
    const rules = /* @__PURE__ */ new Map();
    const parserContext = {
      parser,
      tokens,
      rules,
      ruleNames: /* @__PURE__ */ new Map()
    };
    buildRules(parserContext, grammar);
    return parser;
  }
  function buildRules(parserContext, grammar) {
    const reachable = getAllReachableRules(grammar, false);
    const parserRules = stream(grammar.rules).filter(isParserRule).filter((rule) => reachable.has(rule));
    for (const rule of parserRules) {
      const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });
      ctx.rules.set(rule.name, parserContext.parser.rule(rule, buildElement(ctx, rule.definition)));
    }
  }
  function buildElement(ctx, element, ignoreGuard = false) {
    let method;
    if (isKeyword(element)) {
      method = buildKeyword(ctx, element);
    } else if (isAction(element)) {
      method = buildAction(ctx, element);
    } else if (isAssignment(element)) {
      method = buildElement(ctx, element.terminal);
    } else if (isCrossReference(element)) {
      method = buildCrossReference(ctx, element);
    } else if (isRuleCall(element)) {
      method = buildRuleCall(ctx, element);
    } else if (isAlternatives(element)) {
      method = buildAlternatives(ctx, element);
    } else if (isUnorderedGroup(element)) {
      method = buildUnorderedGroup(ctx, element);
    } else if (isGroup(element)) {
      method = buildGroup(ctx, element);
    } else if (isEndOfFile(element)) {
      const idx = ctx.consume++;
      method = () => ctx.parser.consume(idx, EOF, element);
    } else {
      throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);
    }
    return wrap(ctx, ignoreGuard ? void 0 : getGuardCondition(element), method, element.cardinality);
  }
  function buildAction(ctx, action) {
    const actionType = getTypeName(action);
    return () => ctx.parser.action(actionType, action);
  }
  function buildRuleCall(ctx, ruleCall) {
    const rule = ruleCall.rule.ref;
    if (isParserRule(rule)) {
      const idx = ctx.subrule++;
      const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});
      return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), ruleCall, predicate(args));
    } else if (isTerminalRule(rule)) {
      const idx = ctx.consume++;
      const method = getToken(ctx, rule.name);
      return () => ctx.parser.consume(idx, method, ruleCall);
    } else if (!rule) {
      throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule type: ${ruleCall.$type}`);
    } else {
      assertUnreachable(rule);
    }
  }
  function buildRuleCallPredicate(rule, namedArgs) {
    const predicates = namedArgs.map((e) => buildPredicate(e.value));
    return (args) => {
      const ruleArgs = {};
      for (let i = 0; i < predicates.length; i++) {
        const ruleTarget = rule.parameters[i];
        const predicate = predicates[i];
        ruleArgs[ruleTarget.name] = predicate(args);
      }
      return ruleArgs;
    };
  }
  function buildPredicate(condition) {
    if (isDisjunction(condition)) {
      const left = buildPredicate(condition.left);
      const right = buildPredicate(condition.right);
      return (args) => left(args) || right(args);
    } else if (isConjunction(condition)) {
      const left = buildPredicate(condition.left);
      const right = buildPredicate(condition.right);
      return (args) => left(args) && right(args);
    } else if (isNegation(condition)) {
      const value = buildPredicate(condition.value);
      return (args) => !value(args);
    } else if (isParameterReference(condition)) {
      const name = condition.parameter.ref.name;
      return (args) => args !== void 0 && args[name] === true;
    } else if (isBooleanLiteral(condition)) {
      const value = Boolean(condition.true);
      return () => value;
    }
    assertUnreachable(condition);
  }
  function buildAlternatives(ctx, alternatives) {
    if (alternatives.elements.length === 1) {
      return buildElement(ctx, alternatives.elements[0]);
    } else {
      const methods = [];
      for (const element of alternatives.elements) {
        const predicatedMethod = {
          // Since we handle the guard condition in the alternative already
          // We can ignore the group guard condition inside
          ALT: buildElement(ctx, element, true)
        };
        const guard = getGuardCondition(element);
        if (guard) {
          predicatedMethod.GATE = buildPredicate(guard);
        }
        methods.push(predicatedMethod);
      }
      const idx = ctx.or++;
      return (args) => ctx.parser.alternatives(idx, methods.map((method) => {
        const alt = {
          ALT: () => method.ALT(args)
        };
        const gate = method.GATE;
        if (gate) {
          alt.GATE = () => gate(args);
        }
        return alt;
      }));
    }
  }
  function buildUnorderedGroup(ctx, group) {
    if (group.elements.length === 1) {
      return buildElement(ctx, group.elements[0]);
    }
    const methods = [];
    for (const element of group.elements) {
      const predicatedMethod = {
        // Since we handle the guard condition in the alternative already
        // We can ignore the group guard condition inside
        ALT: buildElement(ctx, element, true)
      };
      const guard = getGuardCondition(element);
      if (guard) {
        predicatedMethod.GATE = buildPredicate(guard);
      }
      methods.push(predicatedMethod);
    }
    const orIdx = ctx.or++;
    const idFunc = (groupIdx, lParser) => {
      const stackId = lParser.getRuleStack().join("-");
      return `uGroup_${groupIdx}_${stackId}`;
    };
    const alternatives = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {
      const alt = { ALT: () => true };
      const parser = ctx.parser;
      alt.ALT = () => {
        method.ALT(args);
        if (!parser.isRecording()) {
          const key = idFunc(orIdx, parser);
          if (!parser.unorderedGroups.get(key)) {
            parser.unorderedGroups.set(key, []);
          }
          const groupState = parser.unorderedGroups.get(key);
          if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === "undefined") {
            groupState[idx] = true;
          }
        }
      };
      const gate = method.GATE;
      if (gate) {
        alt.GATE = () => gate(args);
      } else {
        alt.GATE = () => {
          const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));
          const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);
          return allow;
        };
      }
      return alt;
    }));
    const wrapped = wrap(ctx, getGuardCondition(group), alternatives, "*");
    return (args) => {
      wrapped(args);
      if (!ctx.parser.isRecording()) {
        ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));
      }
    };
  }
  function buildGroup(ctx, group) {
    const methods = group.elements.map((e) => buildElement(ctx, e));
    return (args) => methods.forEach((method) => method(args));
  }
  function getGuardCondition(element) {
    if (isGroup(element)) {
      return element.guardCondition;
    }
    return void 0;
  }
  function buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {
    if (!terminal) {
      if (!crossRef.type.ref) {
        throw new Error("Could not resolve reference to type: " + crossRef.type.$refText);
      }
      const assignment = findNameAssignment(crossRef.type.ref);
      const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;
      if (!assignTerminal) {
        throw new Error("Could not find name assignment for type: " + getTypeName(crossRef.type.ref));
      }
      return buildCrossReference(ctx, crossRef, assignTerminal);
    } else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {
      const idx = ctx.subrule++;
      return (args) => ctx.parser.subrule(idx, getRule(ctx, terminal.rule.ref), crossRef, args);
    } else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {
      const idx = ctx.consume++;
      const terminalRule = getToken(ctx, terminal.rule.ref.name);
      return () => ctx.parser.consume(idx, terminalRule, crossRef);
    } else if (isKeyword(terminal)) {
      const idx = ctx.consume++;
      const keyword = getToken(ctx, terminal.value);
      return () => ctx.parser.consume(idx, keyword, crossRef);
    } else {
      throw new Error("Could not build cross reference parser");
    }
  }
  function buildKeyword(ctx, keyword) {
    const idx = ctx.consume++;
    const token = ctx.tokens[keyword.value];
    if (!token) {
      throw new Error("Could not find token for keyword: " + keyword.value);
    }
    return () => ctx.parser.consume(idx, token, keyword);
  }
  function wrap(ctx, guard, method, cardinality) {
    const gate = guard && buildPredicate(guard);
    if (!cardinality) {
      if (gate) {
        const idx = ctx.or++;
        return (args) => ctx.parser.alternatives(idx, [
          {
            ALT: () => method(args),
            GATE: () => gate(args)
          },
          {
            ALT: EMPTY_ALT(),
            GATE: () => !gate(args)
          }
        ]);
      } else {
        return method;
      }
    }
    if (cardinality === "*") {
      const idx = ctx.many++;
      return (args) => ctx.parser.many(idx, {
        DEF: () => method(args),
        GATE: gate ? () => gate(args) : void 0
      });
    } else if (cardinality === "+") {
      const idx = ctx.many++;
      if (gate) {
        const orIdx = ctx.or++;
        return (args) => ctx.parser.alternatives(orIdx, [
          {
            ALT: () => ctx.parser.atLeastOne(idx, {
              DEF: () => method(args)
            }),
            GATE: () => gate(args)
          },
          {
            ALT: EMPTY_ALT(),
            GATE: () => !gate(args)
          }
        ]);
      } else {
        return (args) => ctx.parser.atLeastOne(idx, {
          DEF: () => method(args)
        });
      }
    } else if (cardinality === "?") {
      const idx = ctx.optional++;
      return (args) => ctx.parser.optional(idx, {
        DEF: () => method(args),
        GATE: gate ? () => gate(args) : void 0
      });
    } else {
      assertUnreachable(cardinality);
    }
  }
  function getRule(ctx, element) {
    const name = getRuleName(ctx, element);
    const rule = ctx.rules.get(name);
    if (!rule)
      throw new Error(`Rule "${name}" not found."`);
    return rule;
  }
  function getRuleName(ctx, element) {
    if (isParserRule(element)) {
      return element.name;
    } else if (ctx.ruleNames.has(element)) {
      return ctx.ruleNames.get(element);
    } else {
      let item = element;
      let parent = item.$container;
      let ruleName = element.$type;
      while (!isParserRule(parent)) {
        if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {
          const index = parent.elements.indexOf(item);
          ruleName = index.toString() + ":" + ruleName;
        }
        item = parent;
        parent = parent.$container;
      }
      const rule = parent;
      ruleName = rule.name + ":" + ruleName;
      ctx.ruleNames.set(element, ruleName);
      return ruleName;
    }
  }
  function getToken(ctx, name) {
    const token = ctx.tokens[name];
    if (!token)
      throw new Error(`Token "${name}" not found."`);
    return token;
  }

  // ../node_modules/langium/lib/parser/completion-parser-builder.js
  function createCompletionParser(services) {
    const grammar = services.Grammar;
    const lexer = services.parser.Lexer;
    const parser = new LangiumCompletionParser(services);
    createParser(grammar, parser, lexer.definition);
    parser.finalize();
    return parser;
  }

  // ../node_modules/langium/lib/parser/langium-parser-builder.js
  function createLangiumParser(services) {
    const parser = prepareLangiumParser(services);
    parser.finalize();
    return parser;
  }
  function prepareLangiumParser(services) {
    const grammar = services.Grammar;
    const lexer = services.parser.Lexer;
    const parser = new LangiumParser(services);
    return createParser(grammar, parser, lexer.definition);
  }

  // ../node_modules/langium/lib/parser/token-builder.js
  var DefaultTokenBuilder = class {
    buildTokens(grammar, options) {
      const reachableRules = stream(getAllReachableRules(grammar, false));
      const terminalTokens = this.buildTerminalTokens(reachableRules);
      const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);
      terminalTokens.forEach((terminalToken) => {
        const pattern = terminalToken.PATTERN;
        if (typeof pattern === "object" && pattern && "test" in pattern && isWhitespace(pattern)) {
          tokens.unshift(terminalToken);
        } else {
          tokens.push(terminalToken);
        }
      });
      return tokens;
    }
    buildTerminalTokens(rules) {
      return rules.filter(isTerminalRule).filter((e) => !e.fragment).map((terminal) => this.buildTerminalToken(terminal)).toArray();
    }
    buildTerminalToken(terminal) {
      const regex = terminalRegex(terminal);
      const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;
      const tokenType = {
        name: terminal.name,
        PATTERN: pattern,
        LINE_BREAKS: true
      };
      if (terminal.hidden) {
        tokenType.GROUP = isWhitespace(regex) ? Lexer.SKIPPED : "hidden";
      }
      return tokenType;
    }
    requiresCustomPattern(regex) {
      if (regex.flags.includes("u")) {
        return true;
      } else if (regex.source.includes("?<=") || regex.source.includes("?<!")) {
        return true;
      } else {
        return false;
      }
    }
    regexPatternFunction(regex) {
      const stickyRegex = new RegExp(regex, regex.flags + "y");
      return (text, offset) => {
        stickyRegex.lastIndex = offset;
        const execResult = stickyRegex.exec(text);
        return execResult;
      };
    }
    buildKeywordTokens(rules, terminalTokens, options) {
      return rules.filter(isParserRule).flatMap((rule) => streamAllContents(rule).filter(isKeyword)).distinct((e) => e.value).toArray().sort((a2, b) => b.value.length - a2.value.length).map((keyword) => this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));
    }
    buildKeywordToken(keyword, terminalTokens, caseInsensitive) {
      return {
        name: keyword.value,
        PATTERN: this.buildKeywordPattern(keyword, caseInsensitive),
        LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)
      };
    }
    buildKeywordPattern(keyword, caseInsensitive) {
      return caseInsensitive ? new RegExp(getCaseInsensitivePattern(keyword.value)) : keyword.value;
    }
    findLongerAlt(keyword, terminalTokens) {
      return terminalTokens.reduce((longerAlts, token) => {
        const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;
        if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && partialMatches("^" + pattern.source + "$", keyword.value)) {
          longerAlts.push(token);
        }
        return longerAlts;
      }, []);
    }
  };

  // ../node_modules/langium/lib/parser/value-converter.js
  var DefaultValueConverter = class {
    convert(input, cstNode) {
      let feature = cstNode.grammarSource;
      if (isCrossReference(feature)) {
        feature = getCrossReferenceTerminal(feature);
      }
      if (isRuleCall(feature)) {
        const rule = feature.rule.ref;
        if (!rule) {
          throw new Error("This cst node was not parsed by a rule.");
        }
        return this.runConverter(rule, input, cstNode);
      }
      return input;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    runConverter(rule, input, cstNode) {
      var _a;
      switch (rule.name.toUpperCase()) {
        case "INT":
          return ValueConverter.convertInt(input);
        case "STRING":
          return ValueConverter.convertString(input);
        case "ID":
          return ValueConverter.convertID(input);
      }
      switch ((_a = getRuleType(rule)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {
        case "number":
          return ValueConverter.convertNumber(input);
        case "boolean":
          return ValueConverter.convertBoolean(input);
        case "bigint":
          return ValueConverter.convertBigint(input);
        case "date":
          return ValueConverter.convertDate(input);
        default:
          return input;
      }
    }
  };
  var ValueConverter;
  (function(ValueConverter2) {
    function convertString(input) {
      let result = "";
      for (let i = 1; i < input.length - 1; i++) {
        const c = input.charAt(i);
        if (c === "\\") {
          const c1 = input.charAt(++i);
          result += convertEscapeCharacter(c1);
        } else {
          result += c;
        }
      }
      return result;
    }
    ValueConverter2.convertString = convertString;
    function convertEscapeCharacter(char) {
      switch (char) {
        case "b":
          return "\b";
        case "f":
          return "\f";
        case "n":
          return "\n";
        case "r":
          return "\r";
        case "t":
          return "	";
        case "v":
          return "\v";
        case "0":
          return "\0";
        default:
          return char;
      }
    }
    function convertID(input) {
      if (input.charAt(0) === "^") {
        return input.substring(1);
      } else {
        return input;
      }
    }
    ValueConverter2.convertID = convertID;
    function convertInt(input) {
      return parseInt(input);
    }
    ValueConverter2.convertInt = convertInt;
    function convertBigint(input) {
      return BigInt(input);
    }
    ValueConverter2.convertBigint = convertBigint;
    function convertDate(input) {
      return new Date(input);
    }
    ValueConverter2.convertDate = convertDate;
    function convertNumber(input) {
      return Number(input);
    }
    ValueConverter2.convertNumber = convertNumber;
    function convertBoolean(input) {
      return input.toLowerCase() === "true";
    }
    ValueConverter2.convertBoolean = convertBoolean;
  })(ValueConverter || (ValueConverter = {}));

  // ../node_modules/langium/lib/utils/cancellation.js
  var cancellation_exports = {};
  __reExport(cancellation_exports, __toESM(require_cancellation(), 1));

  // ../node_modules/langium/lib/utils/promise-utils.js
  function delayNextTick() {
    return new Promise((resolve) => {
      if (typeof setImmediate === "undefined") {
        setTimeout(resolve, 0);
      } else {
        setImmediate(resolve);
      }
    });
  }
  var lastTick = 0;
  var globalInterruptionPeriod = 10;
  function startCancelableOperation() {
    lastTick = Date.now();
    return new cancellation_exports.CancellationTokenSource();
  }
  function setInterruptionPeriod(period) {
    globalInterruptionPeriod = period;
  }
  var OperationCancelled = Symbol("OperationCancelled");
  function isOperationCancelled(err) {
    return err === OperationCancelled;
  }
  async function interruptAndCheck(token) {
    if (token === cancellation_exports.CancellationToken.None) {
      return;
    }
    const current = Date.now();
    if (current - lastTick >= globalInterruptionPeriod) {
      lastTick = current;
      await delayNextTick();
    }
    if (token.isCancellationRequested) {
      throw OperationCancelled;
    }
  }
  var Deferred = class {
    constructor() {
      this.promise = new Promise((resolve, reject2) => {
        this.resolve = (arg) => {
          resolve(arg);
          return this;
        };
        this.reject = (err) => {
          reject2(err);
          return this;
        };
      });
    }
  };

  // ../node_modules/vscode-languageserver-textdocument/lib/esm/main.js
  var FullTextDocument2 = class _FullTextDocument {
    constructor(uri, languageId, version, content) {
      this._uri = uri;
      this._languageId = languageId;
      this._version = version;
      this._content = content;
      this._lineOffsets = void 0;
    }
    get uri() {
      return this._uri;
    }
    get languageId() {
      return this._languageId;
    }
    get version() {
      return this._version;
    }
    getText(range) {
      if (range) {
        const start = this.offsetAt(range.start);
        const end = this.offsetAt(range.end);
        return this._content.substring(start, end);
      }
      return this._content;
    }
    update(changes, version) {
      for (let change of changes) {
        if (_FullTextDocument.isIncremental(change)) {
          const range = getWellformedRange(change.range);
          const startOffset = this.offsetAt(range.start);
          const endOffset = this.offsetAt(range.end);
          this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
          const startLine = Math.max(range.start.line, 0);
          const endLine = Math.max(range.end.line, 0);
          let lineOffsets = this._lineOffsets;
          const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
          if (endLine - startLine === addedLineOffsets.length) {
            for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
              lineOffsets[i + startLine + 1] = addedLineOffsets[i];
            }
          } else {
            if (addedLineOffsets.length < 1e4) {
              lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
            } else {
              this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
            }
          }
          const diff = change.text.length - (endOffset - startOffset);
          if (diff !== 0) {
            for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
              lineOffsets[i] = lineOffsets[i] + diff;
            }
          }
        } else if (_FullTextDocument.isFull(change)) {
          this._content = change.text;
          this._lineOffsets = void 0;
        } else {
          throw new Error("Unknown change event received");
        }
      }
      this._version = version;
    }
    getLineOffsets() {
      if (this._lineOffsets === void 0) {
        this._lineOffsets = computeLineOffsets(this._content, true);
      }
      return this._lineOffsets;
    }
    positionAt(offset) {
      offset = Math.max(Math.min(offset, this._content.length), 0);
      let lineOffsets = this.getLineOffsets();
      let low = 0, high = lineOffsets.length;
      if (high === 0) {
        return { line: 0, character: offset };
      }
      while (low < high) {
        let mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
          high = mid;
        } else {
          low = mid + 1;
        }
      }
      let line = low - 1;
      return { line, character: offset - lineOffsets[line] };
    }
    offsetAt(position) {
      let lineOffsets = this.getLineOffsets();
      if (position.line >= lineOffsets.length) {
        return this._content.length;
      } else if (position.line < 0) {
        return 0;
      }
      let lineOffset = lineOffsets[position.line];
      let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
      return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    }
    get lineCount() {
      return this.getLineOffsets().length;
    }
    static isIncremental(event) {
      let candidate = event;
      return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
    }
    static isFull(event) {
      let candidate = event;
      return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
    }
  };
  var TextDocument2;
  (function(TextDocument4) {
    function create(uri, languageId, version, content) {
      return new FullTextDocument2(uri, languageId, version, content);
    }
    TextDocument4.create = create;
    function update(document, changes, version) {
      if (document instanceof FullTextDocument2) {
        document.update(changes, version);
        return document;
      } else {
        throw new Error("TextDocument.update: document must be created by TextDocument.create");
      }
    }
    TextDocument4.update = update;
    function applyEdits(document, edits) {
      let text = document.getText();
      let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a2, b) => {
        let diff = a2.range.start.line - b.range.start.line;
        if (diff === 0) {
          return a2.range.start.character - b.range.start.character;
        }
        return diff;
      });
      let lastModifiedOffset = 0;
      const spans = [];
      for (const e of sortedEdits) {
        let startOffset = document.offsetAt(e.range.start);
        if (startOffset < lastModifiedOffset) {
          throw new Error("Overlapping edit");
        } else if (startOffset > lastModifiedOffset) {
          spans.push(text.substring(lastModifiedOffset, startOffset));
        }
        if (e.newText.length) {
          spans.push(e.newText);
        }
        lastModifiedOffset = document.offsetAt(e.range.end);
      }
      spans.push(text.substr(lastModifiedOffset));
      return spans.join("");
    }
    TextDocument4.applyEdits = applyEdits;
  })(TextDocument2 || (TextDocument2 = {}));
  function mergeSort(data, compare) {
    if (data.length <= 1) {
      return data;
    }
    const p = data.length / 2 | 0;
    const left = data.slice(0, p);
    const right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
      let ret = compare(left[leftIdx], right[rightIdx]);
      if (ret <= 0) {
        data[i++] = left[leftIdx++];
      } else {
        data[i++] = right[rightIdx++];
      }
    }
    while (leftIdx < left.length) {
      data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
      data[i++] = right[rightIdx++];
    }
    return data;
  }
  function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
    const result = isAtLineStart ? [textOffset] : [];
    for (let i = 0; i < text.length; i++) {
      let ch = text.charCodeAt(i);
      if (ch === 13 || ch === 10) {
        if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
          i++;
        }
        result.push(textOffset + i + 1);
      }
    }
    return result;
  }
  function getWellformedRange(range) {
    const start = range.start;
    const end = range.end;
    if (start.line > end.line || start.line === end.line && start.character > end.character) {
      return { start: end, end: start };
    }
    return range;
  }
  function getWellformedEdit(textEdit) {
    const range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
      return { newText: textEdit.newText, range };
    }
    return textEdit;
  }

  // ../node_modules/vscode-uri/lib/esm/index.mjs
  var LIB;
  (() => {
    "use strict";
    var t = { 470: (t2) => {
      function e2(t3) {
        if ("string" != typeof t3)
          throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
      }
      function r2(t3, e3) {
        for (var r3, n3 = "", i = 0, o = -1, s = 0, h = 0; h <= t3.length; ++h) {
          if (h < t3.length)
            r3 = t3.charCodeAt(h);
          else {
            if (47 === r3)
              break;
            r3 = 47;
          }
          if (47 === r3) {
            if (o === h - 1 || 1 === s)
              ;
            else if (o !== h - 1 && 2 === s) {
              if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                if (n3.length > 2) {
                  var a2 = n3.lastIndexOf("/");
                  if (a2 !== n3.length - 1) {
                    -1 === a2 ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), o = h, s = 0;
                    continue;
                  }
                } else if (2 === n3.length || 1 === n3.length) {
                  n3 = "", i = 0, o = h, s = 0;
                  continue;
                }
              }
              e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
            } else
              n3.length > 0 ? n3 += "/" + t3.slice(o + 1, h) : n3 = t3.slice(o + 1, h), i = h - o - 1;
            o = h, s = 0;
          } else
            46 === r3 && -1 !== s ? ++s : s = -1;
        }
        return n3;
      }
      var n2 = { resolve: function() {
        for (var t3, n3 = "", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {
          var s;
          o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + "/" + n3, i = 47 === s.charCodeAt(0));
        }
        return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
      }, normalize: function(t3) {
        if (e2(t3), 0 === t3.length)
          return ".";
        var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);
        return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
      }, isAbsolute: function(t3) {
        return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
      }, join: function() {
        if (0 === arguments.length)
          return ".";
        for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
          var i = arguments[r3];
          e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += "/" + i);
        }
        return void 0 === t3 ? "." : n2.normalize(t3);
      }, relative: function(t3, r3) {
        if (e2(t3), e2(r3), t3 === r3)
          return "";
        if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
          return "";
        for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i)
          ;
        for (var o = t3.length, s = o - i, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h)
          ;
        for (var a2 = r3.length - h, c = s < a2 ? s : a2, f = -1, u = 0; u <= c; ++u) {
          if (u === c) {
            if (a2 > c) {
              if (47 === r3.charCodeAt(h + u))
                return r3.slice(h + u + 1);
              if (0 === u)
                return r3.slice(h + u);
            } else
              s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
            break;
          }
          var l = t3.charCodeAt(i + u);
          if (l !== r3.charCodeAt(h + u))
            break;
          47 === l && (f = u);
        }
        var g = "";
        for (u = i + f + 1; u <= o; ++u)
          u !== o && 47 !== t3.charCodeAt(u) || (0 === g.length ? g += ".." : g += "/..");
        return g.length > 0 ? g + r3.slice(h + f) : (h += f, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));
      }, _makeLong: function(t3) {
        return t3;
      }, dirname: function(t3) {
        if (e2(t3), 0 === t3.length)
          return ".";
        for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s)
          if (47 === (r3 = t3.charCodeAt(s))) {
            if (!o) {
              i = s;
              break;
            }
          } else
            o = false;
        return -1 === i ? n3 ? "/" : "." : n3 && 1 === i ? "//" : t3.slice(0, i);
      }, basename: function(t3, r3) {
        if (void 0 !== r3 && "string" != typeof r3)
          throw new TypeError('"ext" argument must be a string');
        e2(t3);
        var n3, i = 0, o = -1, s = true;
        if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
          if (r3.length === t3.length && r3 === t3)
            return "";
          var h = r3.length - 1, a2 = -1;
          for (n3 = t3.length - 1; n3 >= 0; --n3) {
            var c = t3.charCodeAt(n3);
            if (47 === c) {
              if (!s) {
                i = n3 + 1;
                break;
              }
            } else
              -1 === a2 && (s = false, a2 = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (o = n3) : (h = -1, o = a2));
          }
          return i === o ? o = a2 : -1 === o && (o = t3.length), t3.slice(i, o);
        }
        for (n3 = t3.length - 1; n3 >= 0; --n3)
          if (47 === t3.charCodeAt(n3)) {
            if (!s) {
              i = n3 + 1;
              break;
            }
          } else
            -1 === o && (s = false, o = n3 + 1);
        return -1 === o ? "" : t3.slice(i, o);
      }, extname: function(t3) {
        e2(t3);
        for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, h = t3.length - 1; h >= 0; --h) {
          var a2 = t3.charCodeAt(h);
          if (47 !== a2)
            -1 === i && (o = false, i = h + 1), 46 === a2 ? -1 === r3 ? r3 = h : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
          else if (!o) {
            n3 = h + 1;
            break;
          }
        }
        return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
      }, format: function(t3) {
        if (null === t3 || "object" != typeof t3)
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
        return function(t4, e3) {
          var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
          return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
        }(0, t3);
      }, parse: function(t3) {
        e2(t3);
        var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
        if (0 === t3.length)
          return r3;
        var n3, i = t3.charCodeAt(0), o = 47 === i;
        o ? (r3.root = "/", n3 = 1) : n3 = 0;
        for (var s = -1, h = 0, a2 = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f)
          if (47 !== (i = t3.charCodeAt(f)))
            -1 === a2 && (c = false, a2 = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
          else if (!c) {
            h = f + 1;
            break;
          }
        return -1 === s || -1 === a2 || 0 === u || 1 === u && s === a2 - 1 && s === h + 1 ? -1 !== a2 && (r3.base = r3.name = 0 === h && o ? t3.slice(1, a2) : t3.slice(h, a2)) : (0 === h && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, a2)) : (r3.name = t3.slice(h, s), r3.base = t3.slice(h, a2)), r3.ext = t3.slice(s, a2)), h > 0 ? r3.dir = t3.slice(0, h - 1) : o && (r3.dir = "/"), r3;
      }, sep: "/", delimiter: ":", win32: null, posix: null };
      n2.posix = n2, t2.exports = n2;
    } }, e = {};
    function r(n2) {
      var i = e[n2];
      if (void 0 !== i)
        return i.exports;
      var o = e[n2] = { exports: {} };
      return t[n2](o, o.exports, r), o.exports;
    }
    r.d = (t2, e2) => {
      for (var n2 in e2)
        r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
    }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    };
    var n = {};
    (() => {
      let t2;
      if (r.r(n), r.d(n, { URI: () => f, Utils: () => P }), "object" == typeof process)
        t2 = "win32" === process.platform;
      else if ("object" == typeof navigator) {
        let e3 = navigator.userAgent;
        t2 = e3.indexOf("Windows") >= 0;
      }
      const e2 = /^\w[\w\d+.-]*$/, i = /^\//, o = /^\/\//;
      function s(t3, r2) {
        if (!t3.scheme && r2)
          throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
        if (t3.scheme && !e2.test(t3.scheme))
          throw new Error("[UriError]: Scheme contains illegal characters.");
        if (t3.path) {
          if (t3.authority) {
            if (!i.test(t3.path))
              throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
          } else if (o.test(t3.path))
            throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
      const h = "", a2 = "/", c = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
      class f {
        static isUri(t3) {
          return t3 instanceof f || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
        }
        scheme;
        authority;
        path;
        query;
        fragment;
        constructor(t3, e3, r2, n2, i2, o2 = false) {
          "object" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = function(t4, e4) {
            return t4 || e4 ? t4 : "file";
          }(t3, o2), this.authority = e3 || h, this.path = function(t4, e4) {
            switch (t4) {
              case "https":
              case "http":
              case "file":
                e4 ? e4[0] !== a2 && (e4 = a2 + e4) : e4 = a2;
            }
            return e4;
          }(this.scheme, r2 || h), this.query = n2 || h, this.fragment = i2 || h, s(this, o2));
        }
        get fsPath() {
          return m(this, false);
        }
        with(t3) {
          if (!t3)
            return this;
          let { scheme: e3, authority: r2, path: n2, query: i2, fragment: o2 } = t3;
          return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = h), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new l(e3, r2, n2, i2, o2);
        }
        static parse(t3, e3 = false) {
          const r2 = c.exec(t3);
          return r2 ? new l(r2[2] || h, C(r2[4] || h), C(r2[5] || h), C(r2[7] || h), C(r2[9] || h), e3) : new l(h, h, h, h, h);
        }
        static file(e3) {
          let r2 = h;
          if (t2 && (e3 = e3.replace(/\\/g, a2)), e3[0] === a2 && e3[1] === a2) {
            const t3 = e3.indexOf(a2, 2);
            -1 === t3 ? (r2 = e3.substring(2), e3 = a2) : (r2 = e3.substring(2, t3), e3 = e3.substring(t3) || a2);
          }
          return new l("file", r2, e3, h, h);
        }
        static from(t3) {
          const e3 = new l(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
          return s(e3, true), e3;
        }
        toString(t3 = false) {
          return y(this, t3);
        }
        toJSON() {
          return this;
        }
        static revive(t3) {
          if (t3) {
            if (t3 instanceof f)
              return t3;
            {
              const e3 = new l(t3);
              return e3._formatted = t3.external, e3._fsPath = t3._sep === u ? t3.fsPath : null, e3;
            }
          }
          return t3;
        }
      }
      const u = t2 ? 1 : void 0;
      class l extends f {
        _formatted = null;
        _fsPath = null;
        get fsPath() {
          return this._fsPath || (this._fsPath = m(this, false)), this._fsPath;
        }
        toString(t3 = false) {
          return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
        }
        toJSON() {
          const t3 = { $mid: 1 };
          return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = u), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
        }
      }
      const g = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
      function d(t3, e3, r2) {
        let n2, i2 = -1;
        for (let o2 = 0; o2 < t3.length; o2++) {
          const s2 = t3.charCodeAt(o2);
          if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2)
            -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t3.charAt(o2));
          else {
            void 0 === n2 && (n2 = t3.substr(0, o2));
            const e4 = g[s2];
            void 0 !== e4 ? (-1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n2 += e4) : -1 === i2 && (i2 = o2);
          }
        }
        return -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2))), void 0 !== n2 ? n2 : t3;
      }
      function p(t3) {
        let e3;
        for (let r2 = 0; r2 < t3.length; r2++) {
          const n2 = t3.charCodeAt(r2);
          35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t3.substr(0, r2)), e3 += g[n2]) : void 0 !== e3 && (e3 += t3[r2]);
        }
        return void 0 !== e3 ? e3 : t3;
      }
      function m(e3, r2) {
        let n2;
        return n2 = e3.authority && e3.path.length > 1 && "file" === e3.scheme ? `//${e3.authority}${e3.path}` : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\//g, "\\")), n2;
      }
      function y(t3, e3) {
        const r2 = e3 ? p : d;
        let n2 = "", { scheme: i2, authority: o2, path: s2, query: h2, fragment: c2 } = t3;
        if (i2 && (n2 += i2, n2 += ":"), (o2 || "file" === i2) && (n2 += a2, n2 += a2), o2) {
          let t4 = o2.indexOf("@");
          if (-1 !== t4) {
            const e4 = o2.substr(0, t4);
            o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), -1 === t4 ? n2 += r2(e4, false, false) : (n2 += r2(e4.substr(0, t4), false, false), n2 += ":", n2 += r2(e4.substr(t4 + 1), false, true)), n2 += "@";
          }
          o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), -1 === t4 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t4), false, true), n2 += o2.substr(t4));
        }
        if (s2) {
          if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
            const t4 = s2.charCodeAt(1);
            t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
          } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
            const t4 = s2.charCodeAt(0);
            t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
          }
          n2 += r2(s2, true, false);
        }
        return h2 && (n2 += "?", n2 += r2(h2, false, false)), c2 && (n2 += "#", n2 += e3 ? c2 : d(c2, false, false)), n2;
      }
      function v(t3) {
        try {
          return decodeURIComponent(t3);
        } catch {
          return t3.length > 3 ? t3.substr(0, 3) + v(t3.substr(3)) : t3;
        }
      }
      const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
      function C(t3) {
        return t3.match(b) ? t3.replace(b, (t4) => v(t4)) : t3;
      }
      var A2 = r(470);
      const w = A2.posix || A2, x = "/";
      var P;
      !function(t3) {
        t3.joinPath = function(t4, ...e3) {
          return t4.with({ path: w.join(t4.path, ...e3) });
        }, t3.resolvePath = function(t4, ...e3) {
          let r2 = t4.path, n2 = false;
          r2[0] !== x && (r2 = x + r2, n2 = true);
          let i2 = w.resolve(r2, ...e3);
          return n2 && i2[0] === x && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
        }, t3.dirname = function(t4) {
          if (0 === t4.path.length || t4.path === x)
            return t4;
          let e3 = w.dirname(t4.path);
          return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
        }, t3.basename = function(t4) {
          return w.basename(t4.path);
        }, t3.extname = function(t4) {
          return w.extname(t4.path);
        };
      }(P || (P = {}));
    })(), LIB = n;
  })();
  var { URI: URI2, Utils } = LIB;

  // ../node_modules/langium/lib/utils/uri-utils.js
  var UriUtils;
  (function(UriUtils2) {
    UriUtils2.basename = Utils.basename;
    UriUtils2.dirname = Utils.dirname;
    UriUtils2.extname = Utils.extname;
    UriUtils2.joinPath = Utils.joinPath;
    UriUtils2.resolvePath = Utils.resolvePath;
    function equals(a2, b) {
      return (a2 === null || a2 === void 0 ? void 0 : a2.toString()) === (b === null || b === void 0 ? void 0 : b.toString());
    }
    UriUtils2.equals = equals;
    function relative(from, to) {
      const fromPath = typeof from === "string" ? from : from.path;
      const toPath = typeof to === "string" ? to : to.path;
      const fromParts = fromPath.split("/").filter((e) => e.length > 0);
      const toParts = toPath.split("/").filter((e) => e.length > 0);
      let i = 0;
      for (; i < fromParts.length; i++) {
        if (fromParts[i] !== toParts[i]) {
          break;
        }
      }
      const backPart = "../".repeat(fromParts.length - i);
      const toPart = toParts.slice(i).join("/");
      return backPart + toPart;
    }
    UriUtils2.relative = relative;
  })(UriUtils || (UriUtils = {}));

  // ../node_modules/langium/lib/workspace/documents.js
  var DocumentState;
  (function(DocumentState2) {
    DocumentState2[DocumentState2["Changed"] = 0] = "Changed";
    DocumentState2[DocumentState2["Parsed"] = 1] = "Parsed";
    DocumentState2[DocumentState2["IndexedContent"] = 2] = "IndexedContent";
    DocumentState2[DocumentState2["ComputedScopes"] = 3] = "ComputedScopes";
    DocumentState2[DocumentState2["Linked"] = 4] = "Linked";
    DocumentState2[DocumentState2["IndexedReferences"] = 5] = "IndexedReferences";
    DocumentState2[DocumentState2["Validated"] = 6] = "Validated";
  })(DocumentState || (DocumentState = {}));
  var DefaultLangiumDocumentFactory = class {
    constructor(services) {
      this.serviceRegistry = services.ServiceRegistry;
      this.textDocuments = services.workspace.TextDocuments;
      this.fileSystemProvider = services.workspace.FileSystemProvider;
    }
    async fromUri(uri, cancellationToken = cancellation_exports.CancellationToken.None) {
      const content = await this.fileSystemProvider.readFile(uri);
      return this.createAsync(uri, content, cancellationToken);
    }
    fromTextDocument(textDocument, uri, cancellationToken) {
      uri = uri !== null && uri !== void 0 ? uri : URI2.parse(textDocument.uri);
      if (cancellationToken) {
        return this.createAsync(uri, textDocument, cancellationToken);
      } else {
        return this.create(uri, textDocument);
      }
    }
    fromString(text, uri, cancellationToken) {
      if (cancellationToken) {
        return this.createAsync(uri, text, cancellationToken);
      } else {
        return this.create(uri, text);
      }
    }
    fromModel(model, uri) {
      return this.create(uri, { $model: model });
    }
    create(uri, content) {
      if (typeof content === "string") {
        const parseResult = this.parse(uri, content);
        return this.createLangiumDocument(parseResult, uri, void 0, content);
      } else if ("$model" in content) {
        const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };
        return this.createLangiumDocument(parseResult, uri);
      } else {
        const parseResult = this.parse(uri, content.getText());
        return this.createLangiumDocument(parseResult, uri, content);
      }
    }
    async createAsync(uri, content, cancelToken) {
      if (typeof content === "string") {
        const parseResult = await this.parseAsync(uri, content, cancelToken);
        return this.createLangiumDocument(parseResult, uri, void 0, content);
      } else {
        const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);
        return this.createLangiumDocument(parseResult, uri, content);
      }
    }
    /**
     * Create a LangiumDocument from a given parse result.
     *
     * A TextDocument is created on demand if it is not provided as argument here. Usually this
     * should not be necessary because the main purpose of the TextDocument is to convert between
     * text ranges and offsets, which is done solely in LSP request handling.
     *
     * With the introduction of {@link update} below this method is supposed to be mainly called
     * during workspace initialization and on addition/recognition of new files, while changes in
     * existing documents are processed via {@link update}.
     */
    createLangiumDocument(parseResult, uri, textDocument, text) {
      let document;
      if (textDocument) {
        document = {
          parseResult,
          uri,
          state: DocumentState.Parsed,
          references: [],
          textDocument
        };
      } else {
        const textDocumentGetter = this.createTextDocumentGetter(uri, text);
        document = {
          parseResult,
          uri,
          state: DocumentState.Parsed,
          references: [],
          get textDocument() {
            return textDocumentGetter();
          }
        };
      }
      parseResult.value.$document = document;
      return document;
    }
    async update(document, cancellationToken) {
      var _a, _b;
      const oldText = (_a = document.parseResult.value.$cstNode) === null || _a === void 0 ? void 0 : _a.root.fullText;
      const textDocument = (_b = this.textDocuments) === null || _b === void 0 ? void 0 : _b.get(document.uri.toString());
      const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);
      if (textDocument) {
        Object.defineProperty(document, "textDocument", {
          value: textDocument
        });
      } else {
        const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);
        Object.defineProperty(document, "textDocument", {
          get: textDocumentGetter
        });
      }
      if (oldText !== text) {
        document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);
        document.parseResult.value.$document = document;
      }
      document.state = DocumentState.Parsed;
      return document;
    }
    parse(uri, text) {
      const services = this.serviceRegistry.getServices(uri);
      return services.parser.LangiumParser.parse(text);
    }
    parseAsync(uri, text, cancellationToken) {
      const services = this.serviceRegistry.getServices(uri);
      return services.parser.AsyncParser.parse(text, cancellationToken);
    }
    createTextDocumentGetter(uri, text) {
      const serviceRegistry = this.serviceRegistry;
      let textDoc = void 0;
      return () => {
        return textDoc !== null && textDoc !== void 0 ? textDoc : textDoc = TextDocument2.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : "");
      };
    }
  };
  var DefaultLangiumDocuments = class {
    constructor(services) {
      this.documentMap = /* @__PURE__ */ new Map();
      this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;
    }
    get all() {
      return stream(this.documentMap.values());
    }
    addDocument(document) {
      const uriString = document.uri.toString();
      if (this.documentMap.has(uriString)) {
        throw new Error(`A document with the URI '${uriString}' is already present.`);
      }
      this.documentMap.set(uriString, document);
    }
    getDocument(uri) {
      const uriString = uri.toString();
      return this.documentMap.get(uriString);
    }
    async getOrCreateDocument(uri, cancellationToken) {
      let document = this.getDocument(uri);
      if (document) {
        return document;
      }
      document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);
      this.addDocument(document);
      return document;
    }
    createDocument(uri, text, cancellationToken) {
      if (cancellationToken) {
        return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then((document) => {
          this.addDocument(document);
          return document;
        });
      } else {
        const document = this.langiumDocumentFactory.fromString(text, uri);
        this.addDocument(document);
        return document;
      }
    }
    hasDocument(uri) {
      return this.documentMap.has(uri.toString());
    }
    invalidateDocument(uri) {
      const uriString = uri.toString();
      const langiumDoc = this.documentMap.get(uriString);
      if (langiumDoc) {
        langiumDoc.state = DocumentState.Changed;
        langiumDoc.precomputedScopes = void 0;
        langiumDoc.references = [];
        langiumDoc.diagnostics = void 0;
      }
      return langiumDoc;
    }
    deleteDocument(uri) {
      const uriString = uri.toString();
      const langiumDoc = this.documentMap.get(uriString);
      if (langiumDoc) {
        langiumDoc.state = DocumentState.Changed;
        this.documentMap.delete(uriString);
      }
      return langiumDoc;
    }
  };

  // ../node_modules/langium/lib/references/linker.js
  var DefaultLinker = class {
    constructor(services) {
      this.reflection = services.shared.AstReflection;
      this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;
      this.scopeProvider = services.references.ScopeProvider;
      this.astNodeLocator = services.workspace.AstNodeLocator;
    }
    async link(document, cancelToken = cancellation_exports.CancellationToken.None) {
      for (const node of streamAst(document.parseResult.value)) {
        await interruptAndCheck(cancelToken);
        streamReferences(node).forEach((ref) => this.doLink(ref, document));
      }
    }
    doLink(refInfo, document) {
      const ref = refInfo.reference;
      if (ref._ref === void 0) {
        try {
          const description = this.getCandidate(refInfo);
          if (isLinkingError(description)) {
            ref._ref = description;
          } else {
            ref._nodeDescription = description;
            if (this.langiumDocuments().hasDocument(description.documentUri)) {
              const linkedNode = this.loadAstNode(description);
              ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);
            }
          }
        } catch (err) {
          ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${ref.$refText}': ${err}` });
        }
      }
      document.references.push(ref);
    }
    unlink(document) {
      for (const ref of document.references) {
        delete ref._ref;
        delete ref._nodeDescription;
      }
      document.references = [];
    }
    getCandidate(refInfo) {
      const scope = this.scopeProvider.getScope(refInfo);
      const description = scope.getElement(refInfo.reference.$refText);
      return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);
    }
    buildReference(node, property2, refNode, refText) {
      const linker = this;
      const reference = {
        $refNode: refNode,
        $refText: refText,
        get ref() {
          var _a;
          if (isAstNode(this._ref)) {
            return this._ref;
          } else if (isAstNodeDescription(this._nodeDescription)) {
            const linkedNode = linker.loadAstNode(this._nodeDescription);
            this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property: property2 }, this._nodeDescription);
          } else if (this._ref === void 0) {
            const refData = linker.getLinkedNode({ reference, container: node, property: property2 });
            if (refData.error && getDocument(node).state < DocumentState.ComputedScopes) {
              return void 0;
            }
            this._ref = (_a = refData.node) !== null && _a !== void 0 ? _a : refData.error;
            this._nodeDescription = refData.descr;
          }
          return isAstNode(this._ref) ? this._ref : void 0;
        },
        get $nodeDescription() {
          return this._nodeDescription;
        },
        get error() {
          return isLinkingError(this._ref) ? this._ref : void 0;
        }
      };
      return reference;
    }
    getLinkedNode(refInfo) {
      try {
        const description = this.getCandidate(refInfo);
        if (isLinkingError(description)) {
          return { error: description };
        }
        const linkedNode = this.loadAstNode(description);
        if (linkedNode) {
          return { node: linkedNode, descr: description };
        } else {
          return {
            descr: description,
            error: this.createLinkingError(refInfo, description)
          };
        }
      } catch (err) {
        return {
          error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${err}` })
        };
      }
    }
    loadAstNode(nodeDescription) {
      if (nodeDescription.node) {
        return nodeDescription.node;
      }
      const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);
      if (!doc) {
        return void 0;
      }
      return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);
    }
    createLinkingError(refInfo, targetDescription) {
      const document = getDocument(refInfo.container);
      if (document.state < DocumentState.ComputedScopes) {
        console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);
      }
      const referenceType = this.reflection.getReferenceType(refInfo);
      return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`, targetDescription });
    }
  };

  // ../node_modules/langium/lib/references/name-provider.js
  function isNamed(node) {
    return typeof node.name === "string";
  }
  var DefaultNameProvider = class {
    getName(node) {
      if (isNamed(node)) {
        return node.name;
      }
      return void 0;
    }
    getNameNode(node) {
      return findNodeForProperty(node.$cstNode, "name");
    }
  };

  // ../node_modules/langium/lib/references/references.js
  var DefaultReferences = class {
    constructor(services) {
      this.nameProvider = services.references.NameProvider;
      this.index = services.shared.workspace.IndexManager;
      this.nodeLocator = services.workspace.AstNodeLocator;
    }
    findDeclaration(sourceCstNode) {
      if (sourceCstNode) {
        const assignment = findAssignment(sourceCstNode);
        const nodeElem = sourceCstNode.astNode;
        if (assignment && nodeElem) {
          const reference = nodeElem[assignment.feature];
          if (isReference(reference)) {
            return reference.ref;
          } else if (Array.isArray(reference)) {
            for (const ref of reference) {
              if (isReference(ref) && ref.$refNode && ref.$refNode.offset <= sourceCstNode.offset && ref.$refNode.end >= sourceCstNode.end) {
                return ref.ref;
              }
            }
          }
        }
        if (nodeElem) {
          const nameNode = this.nameProvider.getNameNode(nodeElem);
          if (nameNode && (nameNode === sourceCstNode || isChildNode(sourceCstNode, nameNode))) {
            return nodeElem;
          }
        }
      }
      return void 0;
    }
    findDeclarationNode(sourceCstNode) {
      const astNode = this.findDeclaration(sourceCstNode);
      if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {
        const targetNode = this.nameProvider.getNameNode(astNode);
        return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;
      }
      return void 0;
    }
    findReferences(targetNode, options) {
      const refs = [];
      if (options.includeDeclaration) {
        const ref = this.getReferenceToSelf(targetNode);
        if (ref) {
          refs.push(ref);
        }
      }
      let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));
      if (options.documentUri) {
        indexReferences = indexReferences.filter((ref) => UriUtils.equals(ref.sourceUri, options.documentUri));
      }
      refs.push(...indexReferences);
      return stream(refs);
    }
    getReferenceToSelf(targetNode) {
      const nameNode = this.nameProvider.getNameNode(targetNode);
      if (nameNode) {
        const doc = getDocument(targetNode);
        const path = this.nodeLocator.getAstNodePath(targetNode);
        return {
          sourceUri: doc.uri,
          sourcePath: path,
          targetUri: doc.uri,
          targetPath: path,
          segment: toDocumentSegment(nameNode),
          local: true
        };
      }
      return void 0;
    }
  };

  // ../node_modules/langium/lib/utils/collections.js
  var MultiMap = class {
    constructor(elements) {
      this.map = /* @__PURE__ */ new Map();
      if (elements) {
        for (const [key, value] of elements) {
          this.add(key, value);
        }
      }
    }
    /**
     * The total number of values in the multimap.
     */
    get size() {
      return Reduction.sum(stream(this.map.values()).map((a2) => a2.length));
    }
    /**
     * Clear all entries in the multimap.
     */
    clear() {
      this.map.clear();
    }
    /**
     * Operates differently depending on whether a `value` is given:
     *  * With a value, this method deletes the specific key / value pair from the multimap.
     *  * Without a value, all values associated with the given key are deleted.
     *
     * @returns `true` if a value existed and has been removed, or `false` if the specified
     *     key / value does not exist.
     */
    delete(key, value) {
      if (value === void 0) {
        return this.map.delete(key);
      } else {
        const values2 = this.map.get(key);
        if (values2) {
          const index = values2.indexOf(value);
          if (index >= 0) {
            if (values2.length === 1) {
              this.map.delete(key);
            } else {
              values2.splice(index, 1);
            }
            return true;
          }
        }
        return false;
      }
    }
    /**
     * Returns an array of all values associated with the given key. If no value exists,
     * an empty array is returned.
     *
     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a
     * value and `delete` to remove a value from the multimap.
     */
    get(key) {
      var _a;
      return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Operates differently depending on whether a `value` is given:
     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.
     *  * Without a value, this method returns `true` if the given key is present in the multimap.
     */
    has(key, value) {
      if (value === void 0) {
        return this.map.has(key);
      } else {
        const values2 = this.map.get(key);
        if (values2) {
          return values2.indexOf(value) >= 0;
        }
        return false;
      }
    }
    /**
     * Add the given key / value pair to the multimap.
     */
    add(key, value) {
      if (this.map.has(key)) {
        this.map.get(key).push(value);
      } else {
        this.map.set(key, [value]);
      }
      return this;
    }
    /**
     * Add the given set of key / value pairs to the multimap.
     */
    addAll(key, values2) {
      if (this.map.has(key)) {
        this.map.get(key).push(...values2);
      } else {
        this.map.set(key, Array.from(values2));
      }
      return this;
    }
    /**
     * Invokes the given callback function for every key / value pair in the multimap.
     */
    forEach(callbackfn) {
      this.map.forEach((array, key) => array.forEach((value) => callbackfn(value, key, this)));
    }
    /**
     * Returns an iterator of key, value pairs for every entry in the map.
     */
    [Symbol.iterator]() {
      return this.entries().iterator();
    }
    /**
     * Returns a stream of key, value pairs for every entry in the map.
     */
    entries() {
      return stream(this.map.entries()).flatMap(([key, array]) => array.map((value) => [key, value]));
    }
    /**
     * Returns a stream of keys in the map.
     */
    keys() {
      return stream(this.map.keys());
    }
    /**
     * Returns a stream of values in the map.
     */
    values() {
      return stream(this.map.values()).flat();
    }
    /**
     * Returns a stream of key, value set pairs for every key in the map.
     */
    entriesGroupedByKey() {
      return stream(this.map.entries());
    }
  };
  var BiMap = class {
    get size() {
      return this.map.size;
    }
    constructor(elements) {
      this.map = /* @__PURE__ */ new Map();
      this.inverse = /* @__PURE__ */ new Map();
      if (elements) {
        for (const [key, value] of elements) {
          this.set(key, value);
        }
      }
    }
    clear() {
      this.map.clear();
      this.inverse.clear();
    }
    set(key, value) {
      this.map.set(key, value);
      this.inverse.set(value, key);
      return this;
    }
    get(key) {
      return this.map.get(key);
    }
    getKey(value) {
      return this.inverse.get(value);
    }
    delete(key) {
      const value = this.map.get(key);
      if (value !== void 0) {
        this.map.delete(key);
        this.inverse.delete(value);
        return true;
      }
      return false;
    }
  };

  // ../node_modules/langium/lib/references/scope-computation.js
  var DefaultScopeComputation = class {
    constructor(services) {
      this.nameProvider = services.references.NameProvider;
      this.descriptions = services.workspace.AstNodeDescriptionProvider;
    }
    async computeExports(document, cancelToken = cancellation_exports.CancellationToken.None) {
      return this.computeExportsForNode(document.parseResult.value, document, void 0, cancelToken);
    }
    /**
     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.
     * The list of children to be considered is determined by the function parameter {@link children}.
     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.
     *
     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.
     * @param document The document containing the AST node to be exported.
     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution.
     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.
     */
    async computeExportsForNode(parentNode, document, children = streamContents, cancelToken = cancellation_exports.CancellationToken.None) {
      const exports2 = [];
      this.exportNode(parentNode, exports2, document);
      for (const node of children(parentNode)) {
        await interruptAndCheck(cancelToken);
        this.exportNode(node, exports2, document);
      }
      return exports2;
    }
    /**
     * Add a single node to the list of exports if it has a name. Override this method to change how
     * symbols are exported, e.g. by modifying their exported name.
     */
    exportNode(node, exports2, document) {
      const name = this.nameProvider.getName(node);
      if (name) {
        exports2.push(this.descriptions.createDescription(node, name, document));
      }
    }
    async computeLocalScopes(document, cancelToken = cancellation_exports.CancellationToken.None) {
      const rootNode = document.parseResult.value;
      const scopes = new MultiMap();
      for (const node of streamAllContents(rootNode)) {
        await interruptAndCheck(cancelToken);
        this.processNode(node, document, scopes);
      }
      return scopes;
    }
    /**
     * Process a single node during scopes computation. The default implementation makes the node visible
     * in the subtree of its container (if the node has a name). Override this method to change this,
     * e.g. by increasing the visibility to a higher level in the AST.
     */
    processNode(node, document, scopes) {
      const container = node.$container;
      if (container) {
        const name = this.nameProvider.getName(node);
        if (name) {
          scopes.add(container, this.descriptions.createDescription(node, name, document));
        }
      }
    }
  };

  // ../node_modules/langium/lib/references/scope.js
  var StreamScope = class {
    constructor(elements, outerScope, options) {
      var _a;
      this.elements = elements;
      this.outerScope = outerScope;
      this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;
    }
    getAllElements() {
      if (this.outerScope) {
        return this.elements.concat(this.outerScope.getAllElements());
      } else {
        return this.elements;
      }
    }
    getElement(name) {
      const local = this.caseInsensitive ? this.elements.find((e) => e.name.toLowerCase() === name.toLowerCase()) : this.elements.find((e) => e.name === name);
      if (local) {
        return local;
      }
      if (this.outerScope) {
        return this.outerScope.getElement(name);
      }
      return void 0;
    }
  };
  var MapScope = class {
    constructor(elements, outerScope, options) {
      var _a;
      this.elements = /* @__PURE__ */ new Map();
      this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;
      for (const element of elements) {
        const name = this.caseInsensitive ? element.name.toLowerCase() : element.name;
        this.elements.set(name, element);
      }
      this.outerScope = outerScope;
    }
    getElement(name) {
      const localName = this.caseInsensitive ? name.toLowerCase() : name;
      const local = this.elements.get(localName);
      if (local) {
        return local;
      }
      if (this.outerScope) {
        return this.outerScope.getElement(name);
      }
      return void 0;
    }
    getAllElements() {
      let elementStream = stream(this.elements.values());
      if (this.outerScope) {
        elementStream = elementStream.concat(this.outerScope.getAllElements());
      }
      return elementStream;
    }
  };
  var EMPTY_SCOPE = {
    getElement() {
      return void 0;
    },
    getAllElements() {
      return EMPTY_STREAM;
    }
  };

  // ../node_modules/langium/lib/utils/caching.js
  var DisposableCache = class {
    constructor() {
      this.toDispose = [];
      this.isDisposed = false;
    }
    onDispose(disposable) {
      this.toDispose.push(disposable);
    }
    dispose() {
      this.throwIfDisposed();
      this.clear();
      this.isDisposed = true;
      this.toDispose.forEach((disposable) => disposable.dispose());
    }
    throwIfDisposed() {
      if (this.isDisposed) {
        throw new Error("This cache has already been disposed");
      }
    }
  };
  var SimpleCache = class extends DisposableCache {
    constructor() {
      super(...arguments);
      this.cache = /* @__PURE__ */ new Map();
    }
    has(key) {
      this.throwIfDisposed();
      return this.cache.has(key);
    }
    set(key, value) {
      this.throwIfDisposed();
      this.cache.set(key, value);
    }
    get(key, provider) {
      this.throwIfDisposed();
      if (this.cache.has(key)) {
        return this.cache.get(key);
      } else if (provider) {
        const value = provider();
        this.cache.set(key, value);
        return value;
      } else {
        return void 0;
      }
    }
    delete(key) {
      this.throwIfDisposed();
      return this.cache.delete(key);
    }
    clear() {
      this.throwIfDisposed();
      this.cache.clear();
    }
  };
  var ContextCache = class extends DisposableCache {
    constructor(converter) {
      super();
      this.cache = /* @__PURE__ */ new Map();
      this.converter = converter !== null && converter !== void 0 ? converter : (value) => value;
    }
    has(contextKey, key) {
      this.throwIfDisposed();
      return this.cacheForContext(contextKey).has(key);
    }
    set(contextKey, key, value) {
      this.throwIfDisposed();
      this.cacheForContext(contextKey).set(key, value);
    }
    get(contextKey, key, provider) {
      this.throwIfDisposed();
      const contextCache = this.cacheForContext(contextKey);
      if (contextCache.has(key)) {
        return contextCache.get(key);
      } else if (provider) {
        const value = provider();
        contextCache.set(key, value);
        return value;
      } else {
        return void 0;
      }
    }
    delete(contextKey, key) {
      this.throwIfDisposed();
      return this.cacheForContext(contextKey).delete(key);
    }
    clear(contextKey) {
      this.throwIfDisposed();
      if (contextKey) {
        const mapKey = this.converter(contextKey);
        this.cache.delete(mapKey);
      } else {
        this.cache.clear();
      }
    }
    cacheForContext(contextKey) {
      const mapKey = this.converter(contextKey);
      let documentCache = this.cache.get(mapKey);
      if (!documentCache) {
        documentCache = /* @__PURE__ */ new Map();
        this.cache.set(mapKey, documentCache);
      }
      return documentCache;
    }
  };
  var DocumentCache = class extends ContextCache {
    constructor(sharedServices) {
      super((uri) => uri.toString());
      this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) => {
        const allUris = changed.concat(deleted);
        for (const uri of allUris) {
          this.clear(uri);
        }
      }));
    }
  };
  var WorkspaceCache = class extends SimpleCache {
    constructor(sharedServices) {
      super();
      this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate(() => {
        this.clear();
      }));
    }
  };

  // ../node_modules/langium/lib/references/scope-provider.js
  var DefaultScopeProvider = class {
    constructor(services) {
      this.reflection = services.shared.AstReflection;
      this.nameProvider = services.references.NameProvider;
      this.descriptions = services.workspace.AstNodeDescriptionProvider;
      this.indexManager = services.shared.workspace.IndexManager;
      this.globalScopeCache = new WorkspaceCache(services.shared);
    }
    getScope(context) {
      const scopes = [];
      const referenceType = this.reflection.getReferenceType(context);
      const precomputed = getDocument(context.container).precomputedScopes;
      if (precomputed) {
        let currentNode = context.container;
        do {
          const allDescriptions = precomputed.get(currentNode);
          if (allDescriptions.length > 0) {
            scopes.push(stream(allDescriptions).filter((desc) => this.reflection.isSubtype(desc.type, referenceType)));
          }
          currentNode = currentNode.$container;
        } while (currentNode);
      }
      let result = this.getGlobalScope(referenceType, context);
      for (let i = scopes.length - 1; i >= 0; i--) {
        result = this.createScope(scopes[i], result);
      }
      return result;
    }
    /**
     * Create a scope for the given collection of AST node descriptions.
     */
    createScope(elements, outerScope, options) {
      return new StreamScope(stream(elements), outerScope, options);
    }
    /**
     * Create a scope for the given collection of AST nodes, which need to be transformed into respective
     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.
     */
    createScopeForNodes(elements, outerScope, options) {
      const s = stream(elements).map((e) => {
        const name = this.nameProvider.getName(e);
        if (name) {
          return this.descriptions.createDescription(e, name);
        }
        return void 0;
      }).nonNullable();
      return new StreamScope(s, outerScope, options);
    }
    /**
     * Create a global scope filtered for the given reference type.
     */
    getGlobalScope(referenceType, _context) {
      return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));
    }
  };

  // ../node_modules/langium/lib/serializer/json-serializer.js
  function isAstNodeWithComment(node) {
    return typeof node.$comment === "string";
  }
  function isIntermediateReference(obj) {
    return typeof obj === "object" && !!obj && ("$ref" in obj || "$error" in obj);
  }
  var DefaultJsonSerializer = class {
    constructor(services) {
      this.ignoreProperties = /* @__PURE__ */ new Set(["$container", "$containerProperty", "$containerIndex", "$document", "$cstNode"]);
      this.langiumDocuments = services.shared.workspace.LangiumDocuments;
      this.astNodeLocator = services.workspace.AstNodeLocator;
      this.nameProvider = services.references.NameProvider;
      this.commentProvider = services.documentation.CommentProvider;
    }
    serialize(node, options = {}) {
      const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;
      const defaultReplacer = (key, value) => this.replacer(key, value, options);
      const replacer = specificReplacer ? (key, value) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;
      try {
        this.currentDocument = getDocument(node);
        return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);
      } finally {
        this.currentDocument = void 0;
      }
    }
    deserialize(content, options = {}) {
      const root2 = JSON.parse(content);
      this.linkNode(root2, root2, options);
      return root2;
    }
    replacer(key, value, { refText, sourceText, textRegions, comments, uriConverter }) {
      var _a, _b, _c, _d;
      if (this.ignoreProperties.has(key)) {
        return void 0;
      } else if (isReference(value)) {
        const refValue = value.ref;
        const $refText = refText ? value.$refText : void 0;
        if (refValue) {
          const targetDocument = getDocument(refValue);
          let targetUri = "";
          if (this.currentDocument && this.currentDocument !== targetDocument) {
            if (uriConverter) {
              targetUri = uriConverter(targetDocument.uri, value);
            } else {
              targetUri = targetDocument.uri.toString();
            }
          }
          const targetPath = this.astNodeLocator.getAstNodePath(refValue);
          return {
            $ref: `${targetUri}#${targetPath}`,
            $refText
          };
        } else {
          return {
            $error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : "Could not resolve reference",
            $refText
          };
        }
      } else if (isAstNode(value)) {
        let astNode = void 0;
        if (textRegions) {
          astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));
          if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {
            astNode.$textRegion.documentURI = (_c = this.currentDocument) === null || _c === void 0 ? void 0 : _c.uri.toString();
          }
        }
        if (sourceText && !key) {
          astNode !== null && astNode !== void 0 ? astNode : astNode = Object.assign({}, value);
          astNode.$sourceText = (_d = value.$cstNode) === null || _d === void 0 ? void 0 : _d.text;
        }
        if (comments) {
          astNode !== null && astNode !== void 0 ? astNode : astNode = Object.assign({}, value);
          const comment = this.commentProvider.getComment(value);
          if (comment) {
            astNode.$comment = comment.replace(/\r/g, "");
          }
        }
        return astNode !== null && astNode !== void 0 ? astNode : value;
      } else {
        return value;
      }
    }
    addAstNodeRegionWithAssignmentsTo(node) {
      const createDocumentSegment = (cstNode) => ({
        offset: cstNode.offset,
        end: cstNode.end,
        length: cstNode.length,
        range: cstNode.range
      });
      if (node.$cstNode) {
        const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);
        const assignments = textRegion.assignments = {};
        Object.keys(node).filter((key) => !key.startsWith("$")).forEach((key) => {
          const propertyAssignments = findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);
          if (propertyAssignments.length !== 0) {
            assignments[key] = propertyAssignments;
          }
        });
        return node;
      }
      return void 0;
    }
    linkNode(node, root2, options, container, containerProperty, containerIndex) {
      for (const [propertyName, item] of Object.entries(node)) {
        if (Array.isArray(item)) {
          for (let index = 0; index < item.length; index++) {
            const element = item[index];
            if (isIntermediateReference(element)) {
              item[index] = this.reviveReference(node, propertyName, root2, element, options);
            } else if (isAstNode(element)) {
              this.linkNode(element, root2, options, node, propertyName, index);
            }
          }
        } else if (isIntermediateReference(item)) {
          node[propertyName] = this.reviveReference(node, propertyName, root2, item, options);
        } else if (isAstNode(item)) {
          this.linkNode(item, root2, options, node, propertyName);
        }
      }
      const mutable = node;
      mutable.$container = container;
      mutable.$containerProperty = containerProperty;
      mutable.$containerIndex = containerIndex;
    }
    reviveReference(container, property2, root2, reference, options) {
      let refText = reference.$refText;
      let error = reference.$error;
      if (reference.$ref) {
        const ref = this.getRefNode(root2, reference.$ref, options.uriConverter);
        if (isAstNode(ref)) {
          if (!refText) {
            refText = this.nameProvider.getName(ref);
          }
          return {
            $refText: refText !== null && refText !== void 0 ? refText : "",
            ref
          };
        } else {
          error = ref;
        }
      }
      if (error) {
        const ref = {
          $refText: refText !== null && refText !== void 0 ? refText : ""
        };
        ref.error = {
          container,
          property: property2,
          message: error,
          reference: ref
        };
        return ref;
      } else {
        return void 0;
      }
    }
    getRefNode(root2, uri, uriConverter) {
      try {
        const fragmentIndex = uri.indexOf("#");
        if (fragmentIndex === 0) {
          const node2 = this.astNodeLocator.getAstNode(root2, uri.substring(1));
          if (!node2) {
            return "Could not resolve path: " + uri;
          }
          return node2;
        }
        if (fragmentIndex < 0) {
          const documentUri2 = uriConverter ? uriConverter(uri) : URI2.parse(uri);
          const document2 = this.langiumDocuments.getDocument(documentUri2);
          if (!document2) {
            return "Could not find document for URI: " + uri;
          }
          return document2.parseResult.value;
        }
        const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : URI2.parse(uri.substring(0, fragmentIndex));
        const document = this.langiumDocuments.getDocument(documentUri);
        if (!document) {
          return "Could not find document for URI: " + uri;
        }
        if (fragmentIndex === uri.length - 1) {
          return document.parseResult.value;
        }
        const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));
        if (!node) {
          return "Could not resolve URI: " + uri;
        }
        return node;
      } catch (err) {
        return String(err);
      }
    }
  };

  // ../node_modules/langium/lib/service-registry.js
  var DefaultServiceRegistry = class {
    register(language) {
      if (!this.singleton && !this.map) {
        this.singleton = language;
        return;
      }
      if (!this.map) {
        this.map = {};
        if (this.singleton) {
          for (const ext of this.singleton.LanguageMetaData.fileExtensions) {
            this.map[ext] = this.singleton;
          }
          this.singleton = void 0;
        }
      }
      for (const ext of language.LanguageMetaData.fileExtensions) {
        if (this.map[ext] !== void 0 && this.map[ext] !== language) {
          console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${language.LanguageMetaData.languageId}'.`);
        }
        this.map[ext] = language;
      }
    }
    getServices(uri) {
      if (this.singleton !== void 0) {
        return this.singleton;
      }
      if (this.map === void 0) {
        throw new Error("The service registry is empty. Use `register` to register the services of a language.");
      }
      const ext = UriUtils.extname(uri);
      const services = this.map[ext];
      if (!services) {
        throw new Error(`The service registry contains no services for the extension '${ext}'.`);
      }
      return services;
    }
    get all() {
      if (this.singleton !== void 0) {
        return [this.singleton];
      }
      if (this.map !== void 0) {
        return Object.values(this.map);
      }
      return [];
    }
  };

  // ../node_modules/langium/lib/validation/validation-registry.js
  function diagnosticData(code) {
    return { code };
  }
  var ValidationCategory;
  (function(ValidationCategory2) {
    ValidationCategory2.all = ["fast", "slow", "built-in"];
  })(ValidationCategory || (ValidationCategory = {}));
  var ValidationRegistry = class {
    constructor(services) {
      this.entries = new MultiMap();
      this.reflection = services.shared.AstReflection;
    }
    /**
     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)
     * or an array of validation checks.
     *
     * @param checksRecord Set of validation checks to register.
     * @param category Optional category for the validation checks (defaults to `'fast'`).
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    register(checksRecord, thisObj = this, category = "fast") {
      if (category === "built-in") {
        throw new Error("The 'built-in' category is reserved for lexer, parser, and linker errors.");
      }
      for (const [type, ch] of Object.entries(checksRecord)) {
        const callbacks = ch;
        if (Array.isArray(callbacks)) {
          for (const check of callbacks) {
            const entry = {
              check: this.wrapValidationException(check, thisObj),
              category
            };
            this.addEntry(type, entry);
          }
        } else if (typeof callbacks === "function") {
          const entry = {
            check: this.wrapValidationException(callbacks, thisObj),
            category
          };
          this.addEntry(type, entry);
        }
      }
    }
    wrapValidationException(check, thisObj) {
      return async (node, accept, cancelToken) => {
        try {
          await check.call(thisObj, node, accept, cancelToken);
        } catch (err) {
          if (isOperationCancelled(err)) {
            throw err;
          }
          console.error("An error occurred during validation:", err);
          const message = err instanceof Error ? err.message : String(err);
          if (err instanceof Error && err.stack) {
            console.error(err.stack);
          }
          accept("error", "An error occurred during validation: " + message, { node });
        }
      };
    }
    addEntry(type, entry) {
      if (type === "AstNode") {
        this.entries.add("AstNode", entry);
        return;
      }
      for (const subtype of this.reflection.getAllSubTypes(type)) {
        this.entries.add(subtype, entry);
      }
    }
    getChecks(type, categories) {
      let checks = stream(this.entries.get(type)).concat(this.entries.get("AstNode"));
      if (categories) {
        checks = checks.filter((entry) => categories.includes(entry.category));
      }
      return checks.map((entry) => entry.check);
    }
  };

  // ../node_modules/langium/lib/validation/document-validator.js
  var DefaultDocumentValidator = class {
    constructor(services) {
      this.validationRegistry = services.validation.ValidationRegistry;
      this.metadata = services.LanguageMetaData;
    }
    async validateDocument(document, options = {}, cancelToken = cancellation_exports.CancellationToken.None) {
      const parseResult = document.parseResult;
      const diagnostics = [];
      await interruptAndCheck(cancelToken);
      if (!options.categories || options.categories.includes("built-in")) {
        this.processLexingErrors(parseResult, diagnostics, options);
        if (options.stopAfterLexingErrors && diagnostics.some((d) => {
          var _a;
          return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LexingError;
        })) {
          return diagnostics;
        }
        this.processParsingErrors(parseResult, diagnostics, options);
        if (options.stopAfterParsingErrors && diagnostics.some((d) => {
          var _a;
          return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.ParsingError;
        })) {
          return diagnostics;
        }
        this.processLinkingErrors(document, diagnostics, options);
        if (options.stopAfterLinkingErrors && diagnostics.some((d) => {
          var _a;
          return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LinkingError;
        })) {
          return diagnostics;
        }
      }
      try {
        diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));
      } catch (err) {
        if (isOperationCancelled(err)) {
          throw err;
        }
        console.error("An error occurred during validation:", err);
      }
      await interruptAndCheck(cancelToken);
      return diagnostics;
    }
    processLexingErrors(parseResult, diagnostics, _options) {
      for (const lexerError of parseResult.lexerErrors) {
        const diagnostic = {
          severity: toDiagnosticSeverity("error"),
          range: {
            start: {
              line: lexerError.line - 1,
              character: lexerError.column - 1
            },
            end: {
              line: lexerError.line - 1,
              character: lexerError.column + lexerError.length - 1
            }
          },
          message: lexerError.message,
          data: diagnosticData(DocumentValidator.LexingError),
          source: this.getSource()
        };
        diagnostics.push(diagnostic);
      }
    }
    processParsingErrors(parseResult, diagnostics, _options) {
      for (const parserError of parseResult.parserErrors) {
        let range = void 0;
        if (isNaN(parserError.token.startOffset)) {
          if ("previousToken" in parserError) {
            const token = parserError.previousToken;
            if (!isNaN(token.startOffset)) {
              const position = { line: token.endLine - 1, character: token.endColumn };
              range = { start: position, end: position };
            } else {
              const position = { line: 0, character: 0 };
              range = { start: position, end: position };
            }
          }
        } else {
          range = tokenToRange(parserError.token);
        }
        if (range) {
          const diagnostic = {
            severity: toDiagnosticSeverity("error"),
            range,
            message: parserError.message,
            data: diagnosticData(DocumentValidator.ParsingError),
            source: this.getSource()
          };
          diagnostics.push(diagnostic);
        }
      }
    }
    processLinkingErrors(document, diagnostics, _options) {
      for (const reference of document.references) {
        const linkingError = reference.error;
        if (linkingError) {
          const info = {
            node: linkingError.container,
            property: linkingError.property,
            index: linkingError.index,
            data: {
              code: DocumentValidator.LinkingError,
              containerType: linkingError.container.$type,
              property: linkingError.property,
              refText: linkingError.reference.$refText
            }
          };
          diagnostics.push(this.toDiagnostic("error", linkingError.message, info));
        }
      }
    }
    async validateAst(rootNode, options, cancelToken = cancellation_exports.CancellationToken.None) {
      const validationItems = [];
      const acceptor = (severity, message, info) => {
        validationItems.push(this.toDiagnostic(severity, message, info));
      };
      await Promise.all(streamAst(rootNode).map(async (node) => {
        await interruptAndCheck(cancelToken);
        const checks = this.validationRegistry.getChecks(node.$type, options.categories);
        for (const check of checks) {
          await check(node, acceptor, cancelToken);
        }
      }));
      return validationItems;
    }
    toDiagnostic(severity, message, info) {
      return {
        message,
        range: getDiagnosticRange(info),
        severity: toDiagnosticSeverity(severity),
        code: info.code,
        codeDescription: info.codeDescription,
        tags: info.tags,
        relatedInformation: info.relatedInformation,
        data: info.data,
        source: this.getSource()
      };
    }
    getSource() {
      return this.metadata.languageId;
    }
  };
  function getDiagnosticRange(info) {
    if (info.range) {
      return info.range;
    }
    let cstNode;
    if (typeof info.property === "string") {
      cstNode = findNodeForProperty(info.node.$cstNode, info.property, info.index);
    } else if (typeof info.keyword === "string") {
      cstNode = findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);
    }
    cstNode !== null && cstNode !== void 0 ? cstNode : cstNode = info.node.$cstNode;
    if (!cstNode) {
      return {
        start: { line: 0, character: 0 },
        end: { line: 0, character: 0 }
      };
    }
    return cstNode.range;
  }
  function toDiagnosticSeverity(severity) {
    switch (severity) {
      case "error":
        return 1;
      case "warning":
        return 2;
      case "info":
        return 3;
      case "hint":
        return 4;
      default:
        throw new Error("Invalid diagnostic severity: " + severity);
    }
  }
  var DocumentValidator;
  (function(DocumentValidator2) {
    DocumentValidator2.LexingError = "lexing-error";
    DocumentValidator2.ParsingError = "parsing-error";
    DocumentValidator2.LinkingError = "linking-error";
  })(DocumentValidator || (DocumentValidator = {}));

  // ../node_modules/langium/lib/workspace/ast-descriptions.js
  var DefaultAstNodeDescriptionProvider = class {
    constructor(services) {
      this.astNodeLocator = services.workspace.AstNodeLocator;
      this.nameProvider = services.references.NameProvider;
    }
    createDescription(node, name, document = getDocument(node)) {
      name !== null && name !== void 0 ? name : name = this.nameProvider.getName(node);
      const path = this.astNodeLocator.getAstNodePath(node);
      if (!name) {
        throw new Error(`Node at path ${path} has no name.`);
      }
      let nameNodeSegment;
      const nameSegmentGetter = () => {
        var _a;
        return nameNodeSegment !== null && nameNodeSegment !== void 0 ? nameNodeSegment : nameNodeSegment = toDocumentSegment((_a = this.nameProvider.getNameNode(node)) !== null && _a !== void 0 ? _a : node.$cstNode);
      };
      return {
        node,
        name,
        get nameSegment() {
          return nameSegmentGetter();
        },
        selectionSegment: toDocumentSegment(node.$cstNode),
        type: node.$type,
        documentUri: document.uri,
        path
      };
    }
  };
  var DefaultReferenceDescriptionProvider = class {
    constructor(services) {
      this.nodeLocator = services.workspace.AstNodeLocator;
    }
    async createDescriptions(document, cancelToken = cancellation_exports.CancellationToken.None) {
      const descr = [];
      const rootNode = document.parseResult.value;
      for (const astNode of streamAst(rootNode)) {
        await interruptAndCheck(cancelToken);
        streamReferences(astNode).filter((refInfo) => !isLinkingError(refInfo)).forEach((refInfo) => {
          const description = this.createDescription(refInfo);
          if (description) {
            descr.push(description);
          }
        });
      }
      return descr;
    }
    createDescription(refInfo) {
      const targetNodeDescr = refInfo.reference.$nodeDescription;
      const refCstNode = refInfo.reference.$refNode;
      if (!targetNodeDescr || !refCstNode) {
        return void 0;
      }
      const docUri = getDocument(refInfo.container).uri;
      return {
        sourceUri: docUri,
        sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),
        targetUri: targetNodeDescr.documentUri,
        targetPath: targetNodeDescr.path,
        segment: toDocumentSegment(refCstNode),
        local: UriUtils.equals(targetNodeDescr.documentUri, docUri)
      };
    }
  };

  // ../node_modules/langium/lib/workspace/ast-node-locator.js
  var DefaultAstNodeLocator = class {
    constructor() {
      this.segmentSeparator = "/";
      this.indexSeparator = "@";
    }
    getAstNodePath(node) {
      if (node.$container) {
        const containerPath = this.getAstNodePath(node.$container);
        const newSegment = this.getPathSegment(node);
        const nodePath = containerPath + this.segmentSeparator + newSegment;
        return nodePath;
      }
      return "";
    }
    getPathSegment({ $containerProperty, $containerIndex }) {
      if (!$containerProperty) {
        throw new Error("Missing '$containerProperty' in AST node.");
      }
      if ($containerIndex !== void 0) {
        return $containerProperty + this.indexSeparator + $containerIndex;
      }
      return $containerProperty;
    }
    getAstNode(node, path) {
      const segments = path.split(this.segmentSeparator);
      return segments.reduce((previousValue, currentValue) => {
        if (!previousValue || currentValue.length === 0) {
          return previousValue;
        }
        const propertyIndex = currentValue.indexOf(this.indexSeparator);
        if (propertyIndex > 0) {
          const property2 = currentValue.substring(0, propertyIndex);
          const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));
          const array = previousValue[property2];
          return array === null || array === void 0 ? void 0 : array[arrayIndex];
        }
        return previousValue[currentValue];
      }, node);
    }
  };

  // ../node_modules/langium/lib/workspace/configuration.js
  var DefaultConfigurationProvider = class {
    constructor(services) {
      this._ready = new Deferred();
      this.settings = {};
      this.workspaceConfig = false;
      this.serviceRegistry = services.ServiceRegistry;
    }
    get ready() {
      return this._ready.promise;
    }
    initialize(params) {
      var _a, _b;
      this.workspaceConfig = (_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : false;
    }
    async initialized(params) {
      if (this.workspaceConfig) {
        if (params.register) {
          const languages = this.serviceRegistry.all;
          params.register({
            // Listen to configuration changes for all languages
            section: languages.map((lang) => this.toSectionName(lang.LanguageMetaData.languageId))
          });
        }
        if (params.fetchConfiguration) {
          const configToUpdate = this.serviceRegistry.all.map((lang) => ({
            // Fetch the configuration changes for all languages
            section: this.toSectionName(lang.LanguageMetaData.languageId)
          }));
          const configs = await params.fetchConfiguration(configToUpdate);
          configToUpdate.forEach((conf, idx) => {
            this.updateSectionConfiguration(conf.section, configs[idx]);
          });
        }
      }
      this._ready.resolve();
    }
    /**
     *  Updates the cached configurations using the `change` notification parameters.
     *
     * @param change The parameters of a change configuration notification.
     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`
     */
    updateConfiguration(change) {
      if (!change.settings) {
        return;
      }
      Object.keys(change.settings).forEach((section) => {
        this.updateSectionConfiguration(section, change.settings[section]);
      });
    }
    updateSectionConfiguration(section, configuration) {
      this.settings[section] = configuration;
    }
    /**
    * Returns a configuration value stored for the given language.
    *
    * @param language The language id
    * @param configuration Configuration name
    */
    async getConfiguration(language, configuration) {
      await this.ready;
      const sectionName = this.toSectionName(language);
      if (this.settings[sectionName]) {
        return this.settings[sectionName][configuration];
      }
    }
    toSectionName(languageId) {
      return `${languageId}`;
    }
  };

  // ../node_modules/langium/lib/utils/disposable.js
  var Disposable;
  (function(Disposable2) {
    function create(callback) {
      return {
        dispose: async () => await callback()
      };
    }
    Disposable2.create = create;
  })(Disposable || (Disposable = {}));

  // ../node_modules/langium/lib/workspace/document-builder.js
  var DefaultDocumentBuilder = class {
    constructor(services) {
      this.updateBuildOptions = {
        // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)
        validation: {
          categories: ["built-in", "fast"]
        }
      };
      this.updateListeners = [];
      this.buildPhaseListeners = new MultiMap();
      this.buildState = /* @__PURE__ */ new Map();
      this.documentBuildWaiters = /* @__PURE__ */ new Map();
      this.currentState = DocumentState.Changed;
      this.langiumDocuments = services.workspace.LangiumDocuments;
      this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;
      this.indexManager = services.workspace.IndexManager;
      this.serviceRegistry = services.ServiceRegistry;
    }
    async build(documents, options = {}, cancelToken = cancellation_exports.CancellationToken.None) {
      var _a, _b;
      for (const document of documents) {
        const key = document.uri.toString();
        if (document.state === DocumentState.Validated) {
          if (typeof options.validation === "boolean" && options.validation) {
            document.state = DocumentState.IndexedReferences;
            document.diagnostics = void 0;
            this.buildState.delete(key);
          } else if (typeof options.validation === "object") {
            const buildState = this.buildState.get(key);
            const previousCategories = (_a = buildState === null || buildState === void 0 ? void 0 : buildState.result) === null || _a === void 0 ? void 0 : _a.validationChecks;
            if (previousCategories) {
              const newCategories = (_b = options.validation.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;
              const categories = newCategories.filter((c) => !previousCategories.includes(c));
              if (categories.length > 0) {
                this.buildState.set(key, {
                  completed: false,
                  options: {
                    validation: Object.assign(Object.assign({}, options.validation), { categories })
                  },
                  result: buildState.result
                });
                document.state = DocumentState.IndexedReferences;
              }
            }
          }
        } else {
          this.buildState.delete(key);
        }
      }
      this.currentState = DocumentState.Changed;
      await this.emitUpdate(documents.map((e) => e.uri), []);
      await this.buildDocuments(documents, options, cancelToken);
    }
    async update(changed, deleted, cancelToken = cancellation_exports.CancellationToken.None) {
      this.currentState = DocumentState.Changed;
      for (const deletedUri of deleted) {
        this.langiumDocuments.deleteDocument(deletedUri);
        this.buildState.delete(deletedUri.toString());
        this.indexManager.remove(deletedUri);
      }
      for (const changedUri of changed) {
        const invalidated = this.langiumDocuments.invalidateDocument(changedUri);
        if (!invalidated) {
          const newDocument = this.langiumDocumentFactory.fromModel({ $type: "INVALID" }, changedUri);
          newDocument.state = DocumentState.Changed;
          this.langiumDocuments.addDocument(newDocument);
        }
        this.buildState.delete(changedUri.toString());
      }
      const allChangedUris = stream(changed).concat(deleted).map((uri) => uri.toString()).toSet();
      this.langiumDocuments.all.filter((doc) => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris)).forEach((doc) => {
        const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;
        linker.unlink(doc);
        doc.state = Math.min(doc.state, DocumentState.ComputedScopes);
        doc.diagnostics = void 0;
      });
      await this.emitUpdate(changed, deleted);
      await interruptAndCheck(cancelToken);
      const rebuildDocuments = this.langiumDocuments.all.filter((doc) => {
        var _a;
        return doc.state < DocumentState.Linked || !((_a = this.buildState.get(doc.uri.toString())) === null || _a === void 0 ? void 0 : _a.completed);
      }).toArray();
      await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);
    }
    async emitUpdate(changed, deleted) {
      await Promise.all(this.updateListeners.map((listener) => listener(changed, deleted)));
    }
    /**
     * Check whether the given document should be relinked after changes were found in the given URIs.
     */
    shouldRelink(document, changedUris) {
      if (document.references.some((ref) => ref.error !== void 0)) {
        return true;
      }
      return this.indexManager.isAffected(document, changedUris);
    }
    onUpdate(callback) {
      this.updateListeners.push(callback);
      return Disposable.create(() => {
        const index = this.updateListeners.indexOf(callback);
        if (index >= 0) {
          this.updateListeners.splice(index, 1);
        }
      });
    }
    /**
     * Build the given documents by stepping through all build phases. If a document's state indicates
     * that a certain build phase is already done, the phase is skipped for that document.
     */
    async buildDocuments(documents, options, cancelToken) {
      this.prepareBuild(documents, options);
      await this.runCancelable(documents, DocumentState.Parsed, cancelToken, (doc) => this.langiumDocumentFactory.update(doc, cancelToken));
      await this.runCancelable(documents, DocumentState.IndexedContent, cancelToken, (doc) => this.indexManager.updateContent(doc, cancelToken));
      await this.runCancelable(documents, DocumentState.ComputedScopes, cancelToken, async (doc) => {
        const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;
        doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);
      });
      await this.runCancelable(documents, DocumentState.Linked, cancelToken, (doc) => {
        const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;
        return linker.link(doc, cancelToken);
      });
      await this.runCancelable(documents, DocumentState.IndexedReferences, cancelToken, (doc) => this.indexManager.updateReferences(doc, cancelToken));
      const toBeValidated = documents.filter((doc) => this.shouldValidate(doc));
      await this.runCancelable(toBeValidated, DocumentState.Validated, cancelToken, (doc) => this.validate(doc, cancelToken));
      for (const doc of documents) {
        const state = this.buildState.get(doc.uri.toString());
        if (state) {
          state.completed = true;
        }
      }
    }
    prepareBuild(documents, options) {
      for (const doc of documents) {
        const key = doc.uri.toString();
        const state = this.buildState.get(key);
        if (!state || state.completed) {
          this.buildState.set(key, {
            completed: false,
            options,
            result: state === null || state === void 0 ? void 0 : state.result
          });
        }
      }
    }
    async runCancelable(documents, targetState, cancelToken, callback) {
      const filtered = documents.filter((e) => e.state < targetState);
      for (const document of filtered) {
        await interruptAndCheck(cancelToken);
        await callback(document);
        document.state = targetState;
      }
      await this.notifyBuildPhase(filtered, targetState, cancelToken);
      this.currentState = targetState;
    }
    onBuildPhase(targetState, callback) {
      this.buildPhaseListeners.add(targetState, callback);
      return Disposable.create(() => {
        this.buildPhaseListeners.delete(targetState, callback);
      });
    }
    waitUntil(state, uriOrToken, cancelToken) {
      let uri = void 0;
      if (uriOrToken && "path" in uriOrToken) {
        uri = uriOrToken;
      } else {
        cancelToken = uriOrToken;
      }
      cancelToken !== null && cancelToken !== void 0 ? cancelToken : cancelToken = cancellation_exports.CancellationToken.None;
      if (uri) {
        const document = this.langiumDocuments.getDocument(uri);
        if (document && document.state > state) {
          return Promise.resolve(uri);
        }
      }
      if (this.currentState >= state) {
        return Promise.resolve(void 0);
      } else if (cancelToken.isCancellationRequested) {
        return Promise.reject(OperationCancelled);
      }
      return new Promise((resolve, reject2) => {
        const buildDisposable = this.onBuildPhase(state, () => {
          buildDisposable.dispose();
          cancelDisposable.dispose();
          if (uri) {
            const document = this.langiumDocuments.getDocument(uri);
            resolve(document === null || document === void 0 ? void 0 : document.uri);
          } else {
            resolve(void 0);
          }
        });
        const cancelDisposable = cancelToken.onCancellationRequested(() => {
          buildDisposable.dispose();
          cancelDisposable.dispose();
          reject2(OperationCancelled);
        });
      });
    }
    async notifyBuildPhase(documents, state, cancelToken) {
      if (documents.length === 0) {
        return;
      }
      const listeners = this.buildPhaseListeners.get(state);
      for (const listener of listeners) {
        await interruptAndCheck(cancelToken);
        await listener(documents, cancelToken);
      }
    }
    /**
     * Determine whether the given document should be validated during a build. The default
     * implementation checks the `validation` property of the build options. If it's set to `true`
     * or a `ValidationOptions` object, the document is included in the validation phase.
     */
    shouldValidate(document) {
      return Boolean(this.getBuildOptions(document).validation);
    }
    /**
     * Run validation checks on the given document and store the resulting diagnostics in the document.
     * If the document already contains diagnostics, the new ones are added to the list.
     */
    async validate(document, cancelToken) {
      var _a, _b;
      const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;
      const validationSetting = this.getBuildOptions(document).validation;
      const options = typeof validationSetting === "object" ? validationSetting : void 0;
      const diagnostics = await validator.validateDocument(document, options, cancelToken);
      if (document.diagnostics) {
        document.diagnostics.push(...diagnostics);
      } else {
        document.diagnostics = diagnostics;
      }
      const state = this.buildState.get(document.uri.toString());
      if (state) {
        (_a = state.result) !== null && _a !== void 0 ? _a : state.result = {};
        const newCategories = (_b = options === null || options === void 0 ? void 0 : options.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;
        if (state.result.validationChecks) {
          state.result.validationChecks.push(...newCategories);
        } else {
          state.result.validationChecks = [...newCategories];
        }
      }
    }
    getBuildOptions(document) {
      var _a, _b;
      return (_b = (_a = this.buildState.get(document.uri.toString())) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {};
    }
  };

  // ../node_modules/langium/lib/workspace/index-manager.js
  var DefaultIndexManager = class {
    constructor(services) {
      this.symbolIndex = /* @__PURE__ */ new Map();
      this.symbolByTypeIndex = new ContextCache();
      this.referenceIndex = /* @__PURE__ */ new Map();
      this.documents = services.workspace.LangiumDocuments;
      this.serviceRegistry = services.ServiceRegistry;
      this.astReflection = services.AstReflection;
    }
    findAllReferences(targetNode, astNodePath) {
      const targetDocUri = getDocument(targetNode).uri;
      const result = [];
      this.referenceIndex.forEach((docRefs) => {
        docRefs.forEach((refDescr) => {
          if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {
            result.push(refDescr);
          }
        });
      });
      return stream(result);
    }
    allElements(nodeType, uris) {
      let documentUris = stream(this.symbolIndex.keys());
      if (uris) {
        documentUris = documentUris.filter((uri) => !uris || uris.has(uri));
      }
      return documentUris.map((uri) => this.getFileDescriptions(uri, nodeType)).flat();
    }
    getFileDescriptions(uri, nodeType) {
      var _a;
      if (!nodeType) {
        return (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];
      }
      const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {
        var _a2;
        const allFileDescriptions = (_a2 = this.symbolIndex.get(uri)) !== null && _a2 !== void 0 ? _a2 : [];
        return allFileDescriptions.filter((e) => this.astReflection.isSubtype(e.type, nodeType));
      });
      return descriptions;
    }
    remove(uri) {
      const uriString = uri.toString();
      this.symbolIndex.delete(uriString);
      this.symbolByTypeIndex.clear(uriString);
      this.referenceIndex.delete(uriString);
    }
    async updateContent(document, cancelToken = cancellation_exports.CancellationToken.None) {
      const services = this.serviceRegistry.getServices(document.uri);
      const exports2 = await services.references.ScopeComputation.computeExports(document, cancelToken);
      const uri = document.uri.toString();
      this.symbolIndex.set(uri, exports2);
      this.symbolByTypeIndex.clear(uri);
    }
    async updateReferences(document, cancelToken = cancellation_exports.CancellationToken.None) {
      const services = this.serviceRegistry.getServices(document.uri);
      const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);
      this.referenceIndex.set(document.uri.toString(), indexData);
    }
    isAffected(document, changedUris) {
      const references = this.referenceIndex.get(document.uri.toString());
      if (!references) {
        return false;
      }
      return references.some((ref) => !ref.local && changedUris.has(ref.targetUri.toString()));
    }
  };

  // ../node_modules/langium/lib/workspace/workspace-manager.js
  var DefaultWorkspaceManager = class {
    constructor(services) {
      this.initialBuildOptions = {};
      this._ready = new Deferred();
      this.serviceRegistry = services.ServiceRegistry;
      this.langiumDocuments = services.workspace.LangiumDocuments;
      this.documentBuilder = services.workspace.DocumentBuilder;
      this.fileSystemProvider = services.workspace.FileSystemProvider;
      this.mutex = services.workspace.WorkspaceLock;
    }
    get ready() {
      return this._ready.promise;
    }
    initialize(params) {
      var _a;
      this.folders = (_a = params.workspaceFolders) !== null && _a !== void 0 ? _a : void 0;
    }
    initialized(_params) {
      return this.mutex.write((token) => {
        var _a;
        return this.initializeWorkspace((_a = this.folders) !== null && _a !== void 0 ? _a : [], token);
      });
    }
    async initializeWorkspace(folders, cancelToken = cancellation_exports.CancellationToken.None) {
      const documents = await this.performStartup(folders);
      await interruptAndCheck(cancelToken);
      await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);
    }
    /**
     * Performs the uninterruptable startup sequence of the workspace manager.
     * This methods loads all documents in the workspace and other documents and returns them.
     */
    async performStartup(folders) {
      const fileExtensions = this.serviceRegistry.all.flatMap((e) => e.LanguageMetaData.fileExtensions);
      const documents = [];
      const collector = (document) => {
        documents.push(document);
        if (!this.langiumDocuments.hasDocument(document.uri)) {
          this.langiumDocuments.addDocument(document);
        }
      };
      await this.loadAdditionalDocuments(folders, collector);
      await Promise.all(folders.map((wf) => [wf, this.getRootFolder(wf)]).map(async (entry) => this.traverseFolder(...entry, fileExtensions, collector)));
      this._ready.resolve();
      return documents;
    }
    /**
     * Load all additional documents that shall be visible in the context of the given workspace
     * folders and add them to the collector. This can be used to include built-in libraries of
     * your language, which can be either loaded from provided files or constructed in memory.
     */
    loadAdditionalDocuments(_folders, _collector) {
      return Promise.resolve();
    }
    /**
     * Determine the root folder of the source documents in the given workspace folder.
     * The default implementation returns the URI of the workspace folder, but you can override
     * this to return a subfolder like `src` instead.
     */
    getRootFolder(workspaceFolder) {
      return URI2.parse(workspaceFolder.uri);
    }
    /**
     * Traverse the file system folder identified by the given URI and its subfolders. All
     * contained files that match the file extensions are added to the collector.
     */
    async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {
      const content = await this.fileSystemProvider.readDirectory(folderPath);
      await Promise.all(content.map(async (entry) => {
        if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {
          if (entry.isDirectory) {
            await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);
          } else if (entry.isFile) {
            const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);
            collector(document);
          }
        }
      }));
    }
    /**
     * Determine whether the given folder entry shall be included while indexing the workspace.
     */
    includeEntry(_workspaceFolder, entry, fileExtensions) {
      const name = UriUtils.basename(entry.uri);
      if (name.startsWith(".")) {
        return false;
      }
      if (entry.isDirectory) {
        return name !== "node_modules" && name !== "out";
      } else if (entry.isFile) {
        const extname = UriUtils.extname(entry.uri);
        return fileExtensions.includes(extname);
      }
      return false;
    }
  };

  // ../node_modules/langium/lib/parser/lexer.js
  var DefaultLexer = class {
    constructor(services) {
      const tokens = services.parser.TokenBuilder.buildTokens(services.Grammar, {
        caseInsensitive: services.LanguageMetaData.caseInsensitive
      });
      this.tokenTypes = this.toTokenTypeDictionary(tokens);
      const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;
      this.chevrotainLexer = new Lexer(lexerTokens, {
        positionTracking: "full"
      });
    }
    get definition() {
      return this.tokenTypes;
    }
    tokenize(text) {
      var _a;
      const chevrotainResult = this.chevrotainLexer.tokenize(text);
      return {
        tokens: chevrotainResult.tokens,
        errors: chevrotainResult.errors,
        hidden: (_a = chevrotainResult.groups.hidden) !== null && _a !== void 0 ? _a : []
      };
    }
    toTokenTypeDictionary(buildTokens) {
      if (isTokenTypeDictionary(buildTokens))
        return buildTokens;
      const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;
      const res = {};
      tokens.forEach((token) => res[token.name] = token);
      return res;
    }
  };
  function isTokenTypeArray(tokenVocabulary) {
    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || "name" in tokenVocabulary[0]);
  }
  function isIMultiModeLexerDefinition(tokenVocabulary) {
    return tokenVocabulary && "modes" in tokenVocabulary && "defaultMode" in tokenVocabulary;
  }
  function isTokenTypeDictionary(tokenVocabulary) {
    return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);
  }

  // ../node_modules/langium/lib/documentation/jsdoc.js
  init_main();
  function parseJSDoc(node, start, options) {
    let opts;
    let position;
    if (typeof node === "string") {
      position = start;
      opts = options;
    } else {
      position = node.range.start;
      opts = start;
    }
    if (!position) {
      position = Position.create(0, 0);
    }
    const lines = getLines(node);
    const normalizedOptions = normalizeOptions(opts);
    const tokens = tokenize({
      lines,
      position,
      options: normalizedOptions
    });
    return parseJSDocComment({
      index: 0,
      tokens,
      position
    });
  }
  function isJSDoc(node, options) {
    const normalizedOptions = normalizeOptions(options);
    const lines = getLines(node);
    if (lines.length === 0) {
      return false;
    }
    const first2 = lines[0];
    const last2 = lines[lines.length - 1];
    const firstRegex = normalizedOptions.start;
    const lastRegex = normalizedOptions.end;
    return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first2)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last2));
  }
  function getLines(node) {
    let content = "";
    if (typeof node === "string") {
      content = node;
    } else {
      content = node.text;
    }
    const lines = content.split(NEWLINE_REGEXP);
    return lines;
  }
  var tagRegex = /\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy;
  var inlineTagRegex = /\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu;
  function tokenize(context) {
    var _a, _b, _c;
    const tokens = [];
    let currentLine = context.position.line;
    let currentCharacter = context.position.character;
    for (let i = 0; i < context.lines.length; i++) {
      const first2 = i === 0;
      const last2 = i === context.lines.length - 1;
      let line = context.lines[i];
      let index = 0;
      if (first2 && context.options.start) {
        const match = (_a = context.options.start) === null || _a === void 0 ? void 0 : _a.exec(line);
        if (match) {
          index = match.index + match[0].length;
        }
      } else {
        const match = (_b = context.options.line) === null || _b === void 0 ? void 0 : _b.exec(line);
        if (match) {
          index = match.index + match[0].length;
        }
      }
      if (last2) {
        const match = (_c = context.options.end) === null || _c === void 0 ? void 0 : _c.exec(line);
        if (match) {
          line = line.substring(0, match.index);
        }
      }
      line = line.substring(0, lastCharacter(line));
      const whitespaceEnd = skipWhitespace(line, index);
      if (whitespaceEnd >= line.length) {
        if (tokens.length > 0) {
          const position = Position.create(currentLine, currentCharacter);
          tokens.push({
            type: "break",
            content: "",
            range: Range.create(position, position)
          });
        }
      } else {
        tagRegex.lastIndex = index;
        const tagMatch = tagRegex.exec(line);
        if (tagMatch) {
          const fullMatch = tagMatch[0];
          const value = tagMatch[1];
          const start = Position.create(currentLine, currentCharacter + index);
          const end = Position.create(currentLine, currentCharacter + index + fullMatch.length);
          tokens.push({
            type: "tag",
            content: value,
            range: Range.create(start, end)
          });
          index += fullMatch.length;
          index = skipWhitespace(line, index);
        }
        if (index < line.length) {
          const rest = line.substring(index);
          const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));
          tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));
        }
      }
      currentLine++;
      currentCharacter = 0;
    }
    if (tokens.length > 0 && tokens[tokens.length - 1].type === "break") {
      return tokens.slice(0, -1);
    }
    return tokens;
  }
  function buildInlineTokens(tags, line, lineIndex, characterIndex) {
    const tokens = [];
    if (tags.length === 0) {
      const start = Position.create(lineIndex, characterIndex);
      const end = Position.create(lineIndex, characterIndex + line.length);
      tokens.push({
        type: "text",
        content: line,
        range: Range.create(start, end)
      });
    } else {
      let lastIndex = 0;
      for (const match of tags) {
        const matchIndex = match.index;
        const startContent = line.substring(lastIndex, matchIndex);
        if (startContent.length > 0) {
          tokens.push({
            type: "text",
            content: line.substring(lastIndex, matchIndex),
            range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, matchIndex + characterIndex))
          });
        }
        let offset = startContent.length + 1;
        const tagName = match[1];
        tokens.push({
          type: "inline-tag",
          content: tagName,
          range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))
        });
        offset += tagName.length;
        if (match.length === 4) {
          offset += match[2].length;
          const value = match[3];
          tokens.push({
            type: "text",
            content: value,
            range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))
          });
        } else {
          tokens.push({
            type: "text",
            content: "",
            range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + characterIndex))
          });
        }
        lastIndex = matchIndex + match[0].length;
      }
      const endContent = line.substring(lastIndex);
      if (endContent.length > 0) {
        tokens.push({
          type: "text",
          content: endContent,
          range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, lastIndex + characterIndex + endContent.length))
        });
      }
    }
    return tokens;
  }
  var nonWhitespaceRegex = /\S/;
  var whitespaceEndRegex = /\s*$/;
  function skipWhitespace(line, index) {
    const match = line.substring(index).match(nonWhitespaceRegex);
    if (match) {
      return index + match.index;
    } else {
      return line.length;
    }
  }
  function lastCharacter(line) {
    const match = line.match(whitespaceEndRegex);
    if (match && typeof match.index === "number") {
      return match.index;
    }
    return void 0;
  }
  function parseJSDocComment(context) {
    var _a, _b, _c, _d;
    const startPosition = Position.create(context.position.line, context.position.character);
    if (context.tokens.length === 0) {
      return new JSDocCommentImpl([], Range.create(startPosition, startPosition));
    }
    const elements = [];
    while (context.index < context.tokens.length) {
      const element = parseJSDocElement(context, elements[elements.length - 1]);
      if (element) {
        elements.push(element);
      }
    }
    const start = (_b = (_a = elements[0]) === null || _a === void 0 ? void 0 : _a.range.start) !== null && _b !== void 0 ? _b : startPosition;
    const end = (_d = (_c = elements[elements.length - 1]) === null || _c === void 0 ? void 0 : _c.range.end) !== null && _d !== void 0 ? _d : startPosition;
    return new JSDocCommentImpl(elements, Range.create(start, end));
  }
  function parseJSDocElement(context, last2) {
    const next = context.tokens[context.index];
    if (next.type === "tag") {
      return parseJSDocTag(context, false);
    } else if (next.type === "text" || next.type === "inline-tag") {
      return parseJSDocText(context);
    } else {
      appendEmptyLine(next, last2);
      context.index++;
      return void 0;
    }
  }
  function appendEmptyLine(token, element) {
    if (element) {
      const line = new JSDocLineImpl("", token.range);
      if ("inlines" in element) {
        element.inlines.push(line);
      } else {
        element.content.inlines.push(line);
      }
    }
  }
  function parseJSDocText(context) {
    let token = context.tokens[context.index];
    const firstToken = token;
    let lastToken = token;
    const lines = [];
    while (token && token.type !== "break" && token.type !== "tag") {
      lines.push(parseJSDocInline(context));
      lastToken = token;
      token = context.tokens[context.index];
    }
    return new JSDocTextImpl(lines, Range.create(firstToken.range.start, lastToken.range.end));
  }
  function parseJSDocInline(context) {
    const token = context.tokens[context.index];
    if (token.type === "inline-tag") {
      return parseJSDocTag(context, true);
    } else {
      return parseJSDocLine(context);
    }
  }
  function parseJSDocTag(context, inline) {
    const tagToken = context.tokens[context.index++];
    const name = tagToken.content.substring(1);
    const nextToken = context.tokens[context.index];
    if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === "text") {
      if (inline) {
        const docLine = parseJSDocLine(context);
        return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, Range.create(tagToken.range.start, docLine.range.end));
      } else {
        const textDoc = parseJSDocText(context);
        return new JSDocTagImpl(name, textDoc, inline, Range.create(tagToken.range.start, textDoc.range.end));
      }
    } else {
      const range = tagToken.range;
      return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);
    }
  }
  function parseJSDocLine(context) {
    const token = context.tokens[context.index++];
    return new JSDocLineImpl(token.content, token.range);
  }
  function normalizeOptions(options) {
    if (!options) {
      return normalizeOptions({
        start: "/**",
        end: "*/",
        line: "*"
      });
    }
    const { start, end, line } = options;
    return {
      start: normalizeOption(start, true),
      end: normalizeOption(end, false),
      line: normalizeOption(line, true)
    };
  }
  function normalizeOption(option2, start) {
    if (typeof option2 === "string" || typeof option2 === "object") {
      const escaped = typeof option2 === "string" ? escapeRegExp(option2) : option2.source;
      if (start) {
        return new RegExp(`^\\s*${escaped}`);
      } else {
        return new RegExp(`\\s*${escaped}\\s*$`);
      }
    } else {
      return option2;
    }
  }
  var JSDocCommentImpl = class {
    constructor(elements, range) {
      this.elements = elements;
      this.range = range;
    }
    getTag(name) {
      return this.getAllTags().find((e) => e.name === name);
    }
    getTags(name) {
      return this.getAllTags().filter((e) => e.name === name);
    }
    getAllTags() {
      return this.elements.filter((e) => "name" in e);
    }
    toString() {
      let value = "";
      for (const element of this.elements) {
        if (value.length === 0) {
          value = element.toString();
        } else {
          const text = element.toString();
          value += fillNewlines(value) + text;
        }
      }
      return value.trim();
    }
    toMarkdown(options) {
      let value = "";
      for (const element of this.elements) {
        if (value.length === 0) {
          value = element.toMarkdown(options);
        } else {
          const text = element.toMarkdown(options);
          value += fillNewlines(value) + text;
        }
      }
      return value.trim();
    }
  };
  var JSDocTagImpl = class {
    constructor(name, content, inline, range) {
      this.name = name;
      this.content = content;
      this.inline = inline;
      this.range = range;
    }
    toString() {
      let text = `@${this.name}`;
      const content = this.content.toString();
      if (this.content.inlines.length === 1) {
        text = `${text} ${content}`;
      } else if (this.content.inlines.length > 1) {
        text = `${text}
${content}`;
      }
      if (this.inline) {
        return `{${text}}`;
      } else {
        return text;
      }
    }
    toMarkdown(options) {
      var _a, _b;
      return (_b = (_a = options === null || options === void 0 ? void 0 : options.renderTag) === null || _a === void 0 ? void 0 : _a.call(options, this)) !== null && _b !== void 0 ? _b : this.toMarkdownDefault(options);
    }
    toMarkdownDefault(options) {
      const content = this.content.toMarkdown(options);
      if (this.inline) {
        const rendered = renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});
        if (typeof rendered === "string") {
          return rendered;
        }
      }
      let marker = "";
      if ((options === null || options === void 0 ? void 0 : options.tag) === "italic" || (options === null || options === void 0 ? void 0 : options.tag) === void 0) {
        marker = "*";
      } else if ((options === null || options === void 0 ? void 0 : options.tag) === "bold") {
        marker = "**";
      } else if ((options === null || options === void 0 ? void 0 : options.tag) === "bold-italic") {
        marker = "***";
      }
      let text = `${marker}@${this.name}${marker}`;
      if (this.content.inlines.length === 1) {
        text = `${text} \u2014 ${content}`;
      } else if (this.content.inlines.length > 1) {
        text = `${text}
${content}`;
      }
      if (this.inline) {
        return `{${text}}`;
      } else {
        return text;
      }
    }
  };
  function renderInlineTag(tag, content, options) {
    var _a, _b;
    if (tag === "linkplain" || tag === "linkcode" || tag === "link") {
      const index = content.indexOf(" ");
      let display = content;
      if (index > 0) {
        const displayStart = skipWhitespace(content, index);
        display = content.substring(displayStart);
        content = content.substring(0, index);
      }
      if (tag === "linkcode" || tag === "link" && options.link === "code") {
        display = `\`${display}\``;
      }
      const renderedLink = (_b = (_a = options.renderLink) === null || _a === void 0 ? void 0 : _a.call(options, content, display)) !== null && _b !== void 0 ? _b : renderLinkDefault(content, display);
      return renderedLink;
    }
    return void 0;
  }
  function renderLinkDefault(content, display) {
    try {
      URI2.parse(content, true);
      return `[${display}](${content})`;
    } catch (_a) {
      return content;
    }
  }
  var JSDocTextImpl = class {
    constructor(lines, range) {
      this.inlines = lines;
      this.range = range;
    }
    toString() {
      let text = "";
      for (let i = 0; i < this.inlines.length; i++) {
        const inline = this.inlines[i];
        const next = this.inlines[i + 1];
        text += inline.toString();
        if (next && next.range.start.line > inline.range.start.line) {
          text += "\n";
        }
      }
      return text;
    }
    toMarkdown(options) {
      let text = "";
      for (let i = 0; i < this.inlines.length; i++) {
        const inline = this.inlines[i];
        const next = this.inlines[i + 1];
        text += inline.toMarkdown(options);
        if (next && next.range.start.line > inline.range.start.line) {
          text += "\n";
        }
      }
      return text;
    }
  };
  var JSDocLineImpl = class {
    constructor(text, range) {
      this.text = text;
      this.range = range;
    }
    toString() {
      return this.text;
    }
    toMarkdown() {
      return this.text;
    }
  };
  function fillNewlines(text) {
    if (text.endsWith("\n")) {
      return "\n";
    } else {
      return "\n\n";
    }
  }

  // ../node_modules/langium/lib/documentation/documentation-provider.js
  var JSDocDocumentationProvider = class {
    constructor(services) {
      this.indexManager = services.shared.workspace.IndexManager;
      this.commentProvider = services.documentation.CommentProvider;
    }
    getDocumentation(node) {
      const comment = this.commentProvider.getComment(node);
      if (comment && isJSDoc(comment)) {
        const parsedJSDoc = parseJSDoc(comment);
        return parsedJSDoc.toMarkdown({
          renderLink: (link, display) => {
            return this.documentationLinkRenderer(node, link, display);
          },
          renderTag: (tag) => {
            return this.documentationTagRenderer(node, tag);
          }
        });
      }
      return void 0;
    }
    documentationLinkRenderer(node, name, display) {
      var _a;
      const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null && _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);
      if (description && description.nameSegment) {
        const line = description.nameSegment.range.start.line + 1;
        const character = description.nameSegment.range.start.character + 1;
        const uri = description.documentUri.with({ fragment: `L${line},${character}` });
        return `[${display}](${uri.toString()})`;
      } else {
        return void 0;
      }
    }
    documentationTagRenderer(_node, _tag) {
      return void 0;
    }
    findNameInPrecomputedScopes(node, name) {
      const document = getDocument(node);
      const precomputed = document.precomputedScopes;
      if (!precomputed) {
        return void 0;
      }
      let currentNode = node;
      do {
        const allDescriptions = precomputed.get(currentNode);
        const description = allDescriptions.find((e) => e.name === name);
        if (description) {
          return description;
        }
        currentNode = currentNode.$container;
      } while (currentNode);
      return void 0;
    }
    findNameInGlobalScope(node, name) {
      const description = this.indexManager.allElements().find((e) => e.name === name);
      return description;
    }
  };

  // ../node_modules/langium/lib/documentation/comment-provider.js
  var DefaultCommentProvider = class {
    constructor(services) {
      this.grammarConfig = () => services.parser.GrammarConfig;
    }
    getComment(node) {
      var _a;
      if (isAstNodeWithComment(node)) {
        return node.$comment;
      }
      return (_a = findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)) === null || _a === void 0 ? void 0 : _a.text;
    }
  };

  // ../node_modules/langium/lib/utils/event.js
  var event_exports = {};
  __reExport(event_exports, __toESM(require_events(), 1));

  // ../node_modules/langium/lib/parser/async-parser.js
  var DefaultAsyncParser = class {
    constructor(services) {
      this.syncParser = services.parser.LangiumParser;
    }
    parse(text) {
      return Promise.resolve(this.syncParser.parse(text));
    }
  };
  var AbstractThreadedAsyncParser = class {
    constructor(services) {
      this.threadCount = 8;
      this.terminationDelay = 200;
      this.workerPool = [];
      this.queue = [];
      this.hydrator = services.serializer.Hydrator;
    }
    initializeWorkers() {
      while (this.workerPool.length < this.threadCount) {
        const worker = this.createWorker();
        worker.onReady(() => {
          if (this.queue.length > 0) {
            const deferred = this.queue.shift();
            if (deferred) {
              worker.lock();
              deferred.resolve(worker);
            }
          }
        });
        this.workerPool.push(worker);
      }
    }
    async parse(text, cancelToken) {
      const worker = await this.acquireParserWorker(cancelToken);
      const deferred = new Deferred();
      let timeout;
      const cancellation = cancelToken.onCancellationRequested(() => {
        timeout = setTimeout(() => {
          this.terminateWorker(worker);
        }, this.terminationDelay);
      });
      worker.parse(text).then((result) => {
        const hydrated = this.hydrator.hydrate(result);
        deferred.resolve(hydrated);
      }).catch((err) => {
        deferred.reject(err);
      }).finally(() => {
        cancellation.dispose();
        clearTimeout(timeout);
      });
      return deferred.promise;
    }
    terminateWorker(worker) {
      worker.terminate();
      const index = this.workerPool.indexOf(worker);
      if (index >= 0) {
        this.workerPool.splice(index, 1);
      }
    }
    async acquireParserWorker(cancelToken) {
      this.initializeWorkers();
      for (const worker of this.workerPool) {
        if (worker.ready) {
          worker.lock();
          return worker;
        }
      }
      const deferred = new Deferred();
      cancelToken.onCancellationRequested(() => {
        const index = this.queue.indexOf(deferred);
        if (index >= 0) {
          this.queue.splice(index, 1);
        }
        deferred.reject(OperationCancelled);
      });
      this.queue.push(deferred);
      return deferred.promise;
    }
  };
  var ParserWorker = class {
    get ready() {
      return this._ready;
    }
    get onReady() {
      return this.onReadyEmitter.event;
    }
    constructor(sendMessage, onMessage, onError, terminate) {
      this.onReadyEmitter = new event_exports.Emitter();
      this.deferred = new Deferred();
      this._ready = true;
      this._parsing = false;
      this.sendMessage = sendMessage;
      this._terminate = terminate;
      onMessage((result) => {
        const parseResult = result;
        this.deferred.resolve(parseResult);
        this.unlock();
      });
      onError((error) => {
        this.deferred.reject(error);
        this.unlock();
      });
    }
    terminate() {
      this.deferred.reject(OperationCancelled);
      this._terminate();
    }
    lock() {
      this._ready = false;
    }
    unlock() {
      this._parsing = false;
      this._ready = true;
      this.onReadyEmitter.fire();
    }
    parse(text) {
      if (this._parsing) {
        throw new Error("Parser worker is busy");
      }
      this._parsing = true;
      this.deferred = new Deferred();
      this.sendMessage(text);
      return this.deferred.promise;
    }
  };

  // ../node_modules/langium/lib/workspace/workspace-lock.js
  var DefaultWorkspaceLock = class {
    constructor() {
      this.previousTokenSource = new cancellation_exports.CancellationTokenSource();
      this.writeQueue = [];
      this.readQueue = [];
      this.done = true;
    }
    write(action) {
      this.cancelWrite();
      const tokenSource = new cancellation_exports.CancellationTokenSource();
      this.previousTokenSource = tokenSource;
      return this.enqueue(this.writeQueue, action, tokenSource.token);
    }
    read(action) {
      return this.enqueue(this.readQueue, action);
    }
    enqueue(queue, action, cancellationToken) {
      const deferred = new Deferred();
      const entry = {
        action,
        deferred,
        cancellationToken: cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : cancellation_exports.CancellationToken.None
      };
      queue.push(entry);
      this.performNextOperation();
      return deferred.promise;
    }
    async performNextOperation() {
      if (!this.done) {
        return;
      }
      const entries = [];
      if (this.writeQueue.length > 0) {
        entries.push(this.writeQueue.shift());
      } else if (this.readQueue.length > 0) {
        entries.push(...this.readQueue.splice(0, this.readQueue.length));
      } else {
        return;
      }
      this.done = false;
      await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) => {
        try {
          const result = await Promise.resolve().then(() => action(cancellationToken));
          deferred.resolve(result);
        } catch (err) {
          if (isOperationCancelled(err)) {
            deferred.resolve(void 0);
          } else {
            deferred.reject(err);
          }
        }
      }));
      this.done = true;
      this.performNextOperation();
    }
    cancelWrite() {
      this.previousTokenSource.cancel();
    }
  };

  // ../node_modules/langium/lib/serializer/hydrator.js
  var DefaultHydrator = class {
    constructor(services) {
      this.grammarElementIdMap = new BiMap();
      this.tokenTypeIdMap = new BiMap();
      this.grammar = services.Grammar;
      this.lexer = services.parser.Lexer;
      this.linker = services.references.Linker;
    }
    dehydrate(result) {
      return {
        // We need to create shallow copies of the errors
        // The original errors inherit from the `Error` class, which is not transferable across worker threads
        lexerErrors: result.lexerErrors.map((e) => Object.assign({}, e)),
        parserErrors: result.parserErrors.map((e) => Object.assign({}, e)),
        value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))
      };
    }
    createDehyrationContext(node) {
      const astNodes = /* @__PURE__ */ new Map();
      const cstNodes = /* @__PURE__ */ new Map();
      for (const astNode of streamAst(node)) {
        astNodes.set(astNode, {});
      }
      if (node.$cstNode) {
        for (const cstNode of streamCst(node.$cstNode)) {
          cstNodes.set(cstNode, {});
        }
      }
      return {
        astNodes,
        cstNodes
      };
    }
    dehydrateAstNode(node, context) {
      const obj = context.astNodes.get(node);
      obj.$type = node.$type;
      obj.$containerIndex = node.$containerIndex;
      obj.$containerProperty = node.$containerProperty;
      if (node.$cstNode !== void 0) {
        obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);
      }
      for (const [name, value] of Object.entries(node)) {
        if (name.startsWith("$")) {
          continue;
        }
        if (Array.isArray(value)) {
          const arr = [];
          obj[name] = arr;
          for (const item of value) {
            if (isAstNode(item)) {
              arr.push(this.dehydrateAstNode(item, context));
            } else if (isReference(item)) {
              arr.push(this.dehydrateReference(item, context));
            } else {
              arr.push(item);
            }
          }
        } else if (isAstNode(value)) {
          obj[name] = this.dehydrateAstNode(value, context);
        } else if (isReference(value)) {
          obj[name] = this.dehydrateReference(value, context);
        } else if (value !== void 0) {
          obj[name] = value;
        }
      }
      return obj;
    }
    dehydrateReference(reference, context) {
      const obj = {};
      obj.$refText = reference.$refText;
      if (reference.$refNode) {
        obj.$refNode = context.cstNodes.get(reference.$refNode);
      }
      return obj;
    }
    dehydrateCstNode(node, context) {
      const cstNode = context.cstNodes.get(node);
      if (isRootCstNode(node)) {
        cstNode.fullText = node.fullText;
      } else {
        cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);
      }
      cstNode.hidden = node.hidden;
      cstNode.astNode = context.astNodes.get(node.astNode);
      if (isCompositeCstNode(node)) {
        cstNode.content = node.content.map((child) => this.dehydrateCstNode(child, context));
      } else if (isLeafCstNode(node)) {
        cstNode.tokenType = node.tokenType.name;
        cstNode.offset = node.offset;
        cstNode.length = node.length;
        cstNode.startLine = node.range.start.line;
        cstNode.startColumn = node.range.start.character;
        cstNode.endLine = node.range.end.line;
        cstNode.endColumn = node.range.end.character;
      }
      return cstNode;
    }
    hydrate(result) {
      const node = result.value;
      const context = this.createHydrationContext(node);
      if ("$cstNode" in node) {
        this.hydrateCstNode(node.$cstNode, context);
      }
      return {
        lexerErrors: result.lexerErrors,
        parserErrors: result.parserErrors,
        value: this.hydrateAstNode(node, context)
      };
    }
    createHydrationContext(node) {
      const astNodes = /* @__PURE__ */ new Map();
      const cstNodes = /* @__PURE__ */ new Map();
      for (const astNode of streamAst(node)) {
        astNodes.set(astNode, {});
      }
      let root2;
      if (node.$cstNode) {
        for (const cstNode of streamCst(node.$cstNode)) {
          let cst;
          if ("fullText" in cstNode) {
            cst = new RootCstNodeImpl(cstNode.fullText);
            root2 = cst;
          } else if ("content" in cstNode) {
            cst = new CompositeCstNodeImpl();
          } else if ("tokenType" in cstNode) {
            cst = this.hydrateCstLeafNode(cstNode);
          }
          if (cst) {
            cstNodes.set(cstNode, cst);
            cst.root = root2;
          }
        }
      }
      return {
        astNodes,
        cstNodes
      };
    }
    hydrateAstNode(node, context) {
      const astNode = context.astNodes.get(node);
      astNode.$type = node.$type;
      astNode.$containerIndex = node.$containerIndex;
      astNode.$containerProperty = node.$containerProperty;
      if (node.$cstNode) {
        astNode.$cstNode = context.cstNodes.get(node.$cstNode);
      }
      for (const [name, value] of Object.entries(node)) {
        if (name.startsWith("$")) {
          continue;
        }
        if (Array.isArray(value)) {
          const arr = [];
          astNode[name] = arr;
          for (const item of value) {
            if (isAstNode(item)) {
              arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));
            } else if (isReference(item)) {
              arr.push(this.hydrateReference(item, astNode, name, context));
            } else {
              arr.push(item);
            }
          }
        } else if (isAstNode(value)) {
          astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);
        } else if (isReference(value)) {
          astNode[name] = this.hydrateReference(value, astNode, name, context);
        } else if (value !== void 0) {
          astNode[name] = value;
        }
      }
      return astNode;
    }
    setParent(node, parent) {
      node.$container = parent;
      return node;
    }
    hydrateReference(reference, node, name, context) {
      return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode), reference.$refText);
    }
    hydrateCstNode(cstNode, context, num = 0) {
      const cstNodeObj = context.cstNodes.get(cstNode);
      if (typeof cstNode.grammarSource === "number") {
        cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);
      }
      cstNodeObj.astNode = context.astNodes.get(cstNode.astNode);
      if (isCompositeCstNode(cstNodeObj)) {
        for (const child of cstNode.content) {
          const hydrated = this.hydrateCstNode(child, context, num++);
          cstNodeObj.content.push(hydrated);
        }
      }
      return cstNodeObj;
    }
    hydrateCstLeafNode(cstNode) {
      const tokenType = this.getTokenType(cstNode.tokenType);
      const offset = cstNode.offset;
      const length = cstNode.length;
      const startLine = cstNode.startLine;
      const startColumn = cstNode.startColumn;
      const endLine = cstNode.endLine;
      const endColumn = cstNode.endColumn;
      const hidden = cstNode.hidden;
      const node = new LeafCstNodeImpl(offset, length, {
        start: {
          line: startLine,
          character: startColumn
        },
        end: {
          line: endLine,
          character: endColumn
        }
      }, tokenType, hidden);
      return node;
    }
    getTokenType(name) {
      return this.lexer.definition[name];
    }
    getGrammarElementId(node) {
      if (this.grammarElementIdMap.size === 0) {
        this.createGrammarElementIdMap();
      }
      return this.grammarElementIdMap.get(node);
    }
    getGrammarElement(id) {
      if (this.grammarElementIdMap.size === 0) {
        this.createGrammarElementIdMap();
      }
      const element = this.grammarElementIdMap.getKey(id);
      if (element) {
        return element;
      } else {
        throw new Error("Invalid grammar element id: " + id);
      }
    }
    createGrammarElementIdMap() {
      let id = 0;
      for (const element of streamAst(this.grammar)) {
        if (isAbstractElement(element)) {
          this.grammarElementIdMap.set(element, id++);
        }
      }
    }
  };

  // ../node_modules/langium/lib/default-module.js
  function createDefaultCoreModule(context) {
    return {
      documentation: {
        CommentProvider: (services) => new DefaultCommentProvider(services),
        DocumentationProvider: (services) => new JSDocDocumentationProvider(services)
      },
      parser: {
        AsyncParser: (services) => new DefaultAsyncParser(services),
        GrammarConfig: (services) => createGrammarConfig(services),
        LangiumParser: (services) => createLangiumParser(services),
        CompletionParser: (services) => createCompletionParser(services),
        ValueConverter: () => new DefaultValueConverter(),
        TokenBuilder: () => new DefaultTokenBuilder(),
        Lexer: (services) => new DefaultLexer(services),
        ParserErrorMessageProvider: () => new LangiumParserErrorMessageProvider()
      },
      workspace: {
        AstNodeLocator: () => new DefaultAstNodeLocator(),
        AstNodeDescriptionProvider: (services) => new DefaultAstNodeDescriptionProvider(services),
        ReferenceDescriptionProvider: (services) => new DefaultReferenceDescriptionProvider(services)
      },
      references: {
        Linker: (services) => new DefaultLinker(services),
        NameProvider: () => new DefaultNameProvider(),
        ScopeProvider: (services) => new DefaultScopeProvider(services),
        ScopeComputation: (services) => new DefaultScopeComputation(services),
        References: (services) => new DefaultReferences(services)
      },
      serializer: {
        Hydrator: (services) => new DefaultHydrator(services),
        JsonSerializer: (services) => new DefaultJsonSerializer(services)
      },
      validation: {
        DocumentValidator: (services) => new DefaultDocumentValidator(services),
        ValidationRegistry: (services) => new ValidationRegistry(services)
      },
      shared: () => context.shared
    };
  }
  function createDefaultSharedCoreModule(context) {
    return {
      ServiceRegistry: () => new DefaultServiceRegistry(),
      workspace: {
        LangiumDocuments: (services) => new DefaultLangiumDocuments(services),
        LangiumDocumentFactory: (services) => new DefaultLangiumDocumentFactory(services),
        DocumentBuilder: (services) => new DefaultDocumentBuilder(services),
        IndexManager: (services) => new DefaultIndexManager(services),
        WorkspaceManager: (services) => new DefaultWorkspaceManager(services),
        FileSystemProvider: (services) => context.fileSystemProvider(services),
        WorkspaceLock: () => new DefaultWorkspaceLock(),
        ConfigurationProvider: (services) => new DefaultConfigurationProvider(services)
      }
    };
  }

  // ../node_modules/langium/lib/dependency-injection.js
  var Module;
  (function(Module2) {
    Module2.merge = (m1, m2) => _merge(_merge({}, m1), m2);
  })(Module || (Module = {}));
  function inject(module1, module2, module3, module4, module5, module6, module7, module8, module9) {
    const module10 = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {});
    return _inject(module10);
  }
  var isProxy = Symbol("isProxy");
  function eagerLoad(item) {
    if (item && item[isProxy]) {
      for (const value of Object.values(item)) {
        eagerLoad(value);
      }
    }
    return item;
  }
  function _inject(module2, injector) {
    const proxy = new Proxy({}, {
      deleteProperty: () => false,
      get: (obj, prop) => _resolve(obj, prop, module2, injector || proxy),
      getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module2, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)),
      has: (_5, prop) => prop in module2,
      ownKeys: () => [...Reflect.ownKeys(module2), isProxy]
      // used by for..in
    });
    proxy[isProxy] = true;
    return proxy;
  }
  var __requested__ = Symbol();
  function _resolve(obj, prop, module2, injector) {
    if (prop in obj) {
      if (obj[prop] instanceof Error) {
        throw new Error("Construction failure. Please make sure that your dependencies are constructable.", { cause: obj[prop] });
      }
      if (obj[prop] === __requested__) {
        throw new Error('Cycle detected. Please make "' + String(prop) + '" lazy. See https://langium.org/docs/configuration-services/#resolving-cyclic-dependencies');
      }
      return obj[prop];
    } else if (prop in module2) {
      const value = module2[prop];
      obj[prop] = __requested__;
      try {
        obj[prop] = typeof value === "function" ? value(injector) : _inject(value, injector);
      } catch (error) {
        obj[prop] = error instanceof Error ? error : void 0;
        throw error;
      }
      return obj[prop];
    } else {
      return void 0;
    }
  }
  function _merge(target, source) {
    if (source) {
      for (const [key, value2] of Object.entries(source)) {
        if (value2 !== void 0) {
          const value1 = target[key];
          if (value1 !== null && value2 !== null && typeof value1 === "object" && typeof value2 === "object") {
            target[key] = _merge(value1, value2);
          } else {
            target[key] = value2;
          }
        }
      }
    }
    return target;
  }

  // ../node_modules/langium/lib/utils/index.js
  var utils_exports = {};
  __export(utils_exports, {
    AstUtils: () => ast_utils_exports,
    BiMap: () => BiMap,
    Cancellation: () => cancellation_exports,
    ContextCache: () => ContextCache,
    CstUtils: () => cst_utils_exports,
    DONE_RESULT: () => DONE_RESULT,
    Deferred: () => Deferred,
    Disposable: () => Disposable,
    DisposableCache: () => DisposableCache,
    DocumentCache: () => DocumentCache,
    EMPTY_STREAM: () => EMPTY_STREAM,
    ErrorWithLocation: () => ErrorWithLocation,
    GrammarUtils: () => grammar_utils_exports,
    MultiMap: () => MultiMap,
    OperationCancelled: () => OperationCancelled,
    Reduction: () => Reduction,
    RegExpUtils: () => regexp_utils_exports,
    SimpleCache: () => SimpleCache,
    StreamImpl: () => StreamImpl,
    TreeStreamImpl: () => TreeStreamImpl,
    URI: () => URI2,
    UriUtils: () => UriUtils,
    WorkspaceCache: () => WorkspaceCache,
    assertUnreachable: () => assertUnreachable,
    delayNextTick: () => delayNextTick,
    interruptAndCheck: () => interruptAndCheck,
    isOperationCancelled: () => isOperationCancelled,
    loadGrammarFromJson: () => loadGrammarFromJson,
    setInterruptionPeriod: () => setInterruptionPeriod,
    startCancelableOperation: () => startCancelableOperation,
    stream: () => stream
  });
  __reExport(utils_exports, event_exports);

  // ../node_modules/langium/lib/workspace/file-system-provider.js
  var EmptyFileSystemProvider = class {
    readFile() {
      throw new Error("No file system is available.");
    }
    async readDirectory() {
      return [];
    }
  };
  var EmptyFileSystem = {
    fileSystemProvider: () => new EmptyFileSystemProvider()
  };

  // ../node_modules/langium/lib/utils/grammar-loader.js
  var minimalGrammarModule = {
    Grammar: () => void 0,
    LanguageMetaData: () => ({
      caseInsensitive: false,
      fileExtensions: [".langium"],
      languageId: "langium"
    })
  };
  var minimalSharedGrammarModule = {
    AstReflection: () => new LangiumGrammarAstReflection()
  };
  function createMinimalGrammarServices() {
    const shared2 = inject(createDefaultSharedCoreModule(EmptyFileSystem), minimalSharedGrammarModule);
    const grammar = inject(createDefaultCoreModule({ shared: shared2 }), minimalGrammarModule);
    shared2.ServiceRegistry.register(grammar);
    return grammar;
  }
  function loadGrammarFromJson(json) {
    var _a;
    const services = createMinimalGrammarServices();
    const astNode = services.serializer.JsonSerializer.deserialize(json);
    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, URI2.parse(`memory://${(_a = astNode.name) !== null && _a !== void 0 ? _a : "grammar"}.langium`));
    return astNode;
  }

  // ../node_modules/langium/lib/index.js
  __reExport(lib_exports, utils_exports);

  // ../node_modules/langium/lib/lsp/completion/completion-provider.js
  var import_vscode_languageserver = __toESM(require_main3(), 1);

  // ../node_modules/langium/lib/lsp/completion/follow-element-computation.js
  function findNextFeatures(featureStack, unparsedTokens) {
    const context = {
      stacks: featureStack,
      tokens: unparsedTokens
    };
    interpretTokens(context);
    context.stacks.flat().forEach((feature) => {
      feature.property = void 0;
    });
    const nextStacks = findNextFeatureStacks(context.stacks);
    return nextStacks.map((e) => e[e.length - 1]);
  }
  function findNextFeaturesInternal(options) {
    const { next, cardinalities, visited, plus: plus2 } = options;
    const features = [];
    const feature = next.feature;
    if (visited.has(feature)) {
      return [];
    } else {
      visited.add(feature);
    }
    let parent;
    let item = feature;
    while (item.$container) {
      if (isGroup(item.$container)) {
        parent = item.$container;
        break;
      } else if (isAbstractElement(item.$container)) {
        item = item.$container;
      } else {
        break;
      }
    }
    if (isArrayCardinality(item.cardinality)) {
      const repeatingFeatures = findFirstFeaturesInternal({
        next: {
          feature: item,
          type: next.type
        },
        cardinalities,
        visited,
        plus: plus2
      });
      for (const repeatingFeature of repeatingFeatures) {
        plus2.add(repeatingFeature.feature);
      }
      features.push(...repeatingFeatures);
    }
    if (parent) {
      const ownIndex = parent.elements.indexOf(item);
      if (ownIndex !== void 0 && ownIndex < parent.elements.length - 1) {
        features.push(...findNextFeaturesInGroup({
          feature: parent,
          type: next.type
        }, ownIndex + 1, cardinalities, visited, plus2));
      }
      if (features.every((e) => isOptionalCardinality(e.feature.cardinality, e.feature) || isOptionalCardinality(cardinalities.get(e.feature)) || plus2.has(e.feature))) {
        features.push(...findNextFeaturesInternal({
          next: {
            feature: parent,
            type: next.type
          },
          cardinalities,
          visited,
          plus: plus2
        }));
      }
    }
    return features;
  }
  function findFirstFeatures(next) {
    if (isAstNode(next)) {
      next = { feature: next };
    }
    return findFirstFeaturesInternal({ next, cardinalities: /* @__PURE__ */ new Map(), visited: /* @__PURE__ */ new Set(), plus: /* @__PURE__ */ new Set() });
  }
  function findFirstFeaturesInternal(options) {
    var _a, _b, _c;
    const { next, cardinalities, visited, plus: plus2 } = options;
    if (next === void 0) {
      return [];
    }
    const { feature, type } = next;
    if (isGroup(feature)) {
      if (visited.has(feature)) {
        return [];
      } else {
        visited.add(feature);
      }
    }
    if (isGroup(feature)) {
      return findNextFeaturesInGroup(next, 0, cardinalities, visited, plus2).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
    } else if (isAlternatives(feature) || isUnorderedGroup(feature)) {
      return feature.elements.flatMap((e) => findFirstFeaturesInternal({
        next: {
          feature: e,
          type,
          property: next.property
        },
        cardinalities,
        visited,
        plus: plus2
      })).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
    } else if (isAssignment(feature)) {
      const assignmentNext = {
        feature: feature.terminal,
        type,
        property: (_a = next.property) !== null && _a !== void 0 ? _a : feature.feature
      };
      return findFirstFeaturesInternal({ next: assignmentNext, cardinalities, visited, plus: plus2 }).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
    } else if (isAction(feature)) {
      return findNextFeaturesInternal({
        next: {
          feature,
          type: getTypeName(feature),
          property: (_b = next.property) !== null && _b !== void 0 ? _b : feature.feature
        },
        cardinalities,
        visited,
        plus: plus2
      });
    } else if (isRuleCall(feature) && isParserRule(feature.rule.ref)) {
      const rule = feature.rule.ref;
      const ruleCallNext = {
        feature: rule.definition,
        type: rule.fragment || rule.dataType ? void 0 : (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name,
        property: next.property
      };
      return findFirstFeaturesInternal({ next: ruleCallNext, cardinalities, visited, plus: plus2 }).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
    } else {
      return [next];
    }
  }
  function modifyCardinality(next, cardinality, cardinalities) {
    cardinalities.set(next.feature, cardinality);
    return next;
  }
  function findNextFeaturesInGroup(next, index, cardinalities, visited, plus2) {
    var _a;
    const features = [];
    let firstFeature;
    while (index < next.feature.elements.length) {
      const feature = next.feature.elements[index++];
      firstFeature = {
        feature,
        type: next.type
      };
      features.push(...findFirstFeaturesInternal({
        next: firstFeature,
        cardinalities,
        visited,
        plus: plus2
      }));
      if (!isOptionalCardinality((_a = firstFeature.feature.cardinality) !== null && _a !== void 0 ? _a : cardinalities.get(firstFeature.feature), firstFeature.feature)) {
        break;
      }
    }
    return features;
  }
  function interpretTokens(context) {
    for (const token of context.tokens) {
      const nextFeatureStacks = findNextFeatureStacks(context.stacks, token);
      context.stacks = nextFeatureStacks;
    }
  }
  function findNextFeatureStacks(stacks, token) {
    const newStacks = [];
    for (const stack of stacks) {
      newStacks.push(...interpretStackToken(stack, token));
    }
    return newStacks;
  }
  function interpretStackToken(stack, token) {
    const cardinalities = /* @__PURE__ */ new Map();
    const plus2 = new Set(stack.map((e) => e.feature).filter(isPlusFeature));
    const newStacks = [];
    while (stack.length > 0) {
      const top = stack.pop();
      const allNextFeatures = findNextFeaturesInternal({
        next: top,
        cardinalities,
        plus: plus2,
        visited: /* @__PURE__ */ new Set()
      }).filter((next) => token ? featureMatches(next.feature, token) : true);
      for (const nextFeature of allNextFeatures) {
        newStacks.push([...stack, nextFeature]);
      }
      if (!allNextFeatures.every((e) => isOptionalCardinality(e.feature.cardinality, e.feature) || isOptionalCardinality(cardinalities.get(e.feature)))) {
        break;
      }
    }
    return newStacks;
  }
  function isPlusFeature(feature) {
    if (feature.cardinality === "+") {
      return true;
    }
    const assignment = getContainerOfType(feature, isAssignment);
    if (assignment && assignment.cardinality === "+") {
      return true;
    }
    return false;
  }
  function featureMatches(feature, token) {
    if (isKeyword(feature)) {
      const content = feature.value;
      return content === token.image;
    } else if (isRuleCall(feature)) {
      return ruleMatches(feature.rule.ref, token);
    } else if (isCrossReference(feature)) {
      const crossRefTerminal = getCrossReferenceTerminal(feature);
      if (crossRefTerminal) {
        return featureMatches(crossRefTerminal, token);
      }
    }
    return false;
  }
  function ruleMatches(rule, token) {
    if (isParserRule(rule)) {
      const ruleFeatures = findFirstFeatures(rule.definition);
      return ruleFeatures.some((e) => featureMatches(e.feature, token));
    } else if (isTerminalRule(rule)) {
      return terminalRegex(rule).test(token.image);
    } else {
      return false;
    }
  }

  // ../node_modules/langium/lib/lsp/completion/completion-provider.js
  function mergeCompletionProviderOptions(options) {
    const triggerCharacters = Array.from(new Set(options.flatMap((option2) => {
      var _a;
      return (_a = option2 === null || option2 === void 0 ? void 0 : option2.triggerCharacters) !== null && _a !== void 0 ? _a : [];
    })));
    const allCommitCharacters = Array.from(new Set(options.flatMap((option2) => {
      var _a;
      return (_a = option2 === null || option2 === void 0 ? void 0 : option2.allCommitCharacters) !== null && _a !== void 0 ? _a : [];
    })));
    return {
      triggerCharacters: triggerCharacters.length > 0 ? triggerCharacters : void 0,
      allCommitCharacters: allCommitCharacters.length > 0 ? allCommitCharacters : void 0
    };
  }
  var DefaultCompletionProvider = class {
    constructor(services) {
      this.scopeProvider = services.references.ScopeProvider;
      this.grammar = services.Grammar;
      this.completionParser = services.parser.CompletionParser;
      this.nameProvider = services.references.NameProvider;
      this.lexer = services.parser.Lexer;
      this.nodeKindProvider = services.shared.lsp.NodeKindProvider;
      this.fuzzyMatcher = services.shared.lsp.FuzzyMatcher;
      this.grammarConfig = services.parser.GrammarConfig;
      this.astReflection = services.shared.AstReflection;
    }
    async getCompletion(document, params) {
      const items = [];
      const contexts = this.buildContexts(document, params.position);
      const acceptor = (context, value) => {
        const completionItem = this.fillCompletionItem(context, value);
        if (completionItem) {
          items.push(completionItem);
        }
      };
      const distinctionFunction = (element) => {
        if (isKeyword(element.feature)) {
          return element.feature.value;
        } else {
          return element.feature;
        }
      };
      const completedFeatures = [];
      for (const context of contexts) {
        await Promise.all(stream(context.features).distinct(distinctionFunction).exclude(completedFeatures).map((e) => this.completionFor(context, e, acceptor)));
        completedFeatures.push(...context.features);
        if (!this.continueCompletion(items)) {
          break;
        }
      }
      return import_vscode_languageserver.CompletionList.create(this.deduplicateItems(items), true);
    }
    /**
     * The completion algorithm could yield the same reference/keyword multiple times.
     *
     * This methods deduplicates these items afterwards before returning to the client.
     * Unique items are identified as a combination of `kind`, `label` and `detail`.
     */
    deduplicateItems(items) {
      return stream(items).distinct((item) => `${item.kind}_${item.label}_${item.detail}`).toArray();
    }
    findFeaturesAt(document, offset) {
      const text = document.getText({
        start: import_vscode_languageserver.Position.create(0, 0),
        end: document.positionAt(offset)
      });
      const parserResult = this.completionParser.parse(text);
      const tokens = parserResult.tokens;
      if (parserResult.tokenIndex === 0) {
        const parserRule = getEntryRule(this.grammar);
        const firstFeatures = findFirstFeatures({
          feature: parserRule.definition,
          type: getExplicitRuleType(parserRule)
        });
        if (tokens.length > 0) {
          tokens.shift();
          return findNextFeatures(firstFeatures.map((e) => [e]), tokens);
        } else {
          return firstFeatures;
        }
      }
      const leftoverTokens = [...tokens].splice(parserResult.tokenIndex);
      const features = findNextFeatures([parserResult.elementStack.map((feature) => ({ feature }))], leftoverTokens);
      return features;
    }
    *buildContexts(document, position) {
      var _a, _b;
      const cst = document.parseResult.value.$cstNode;
      if (!cst) {
        return;
      }
      const textDocument = document.textDocument;
      const text = textDocument.getText();
      const offset = textDocument.offsetAt(position);
      const partialContext = {
        document,
        textDocument,
        offset,
        position
      };
      const dataTypeRuleOffsets = this.findDataTypeRuleStart(cst, offset);
      if (dataTypeRuleOffsets) {
        const [ruleStart, ruleEnd] = dataTypeRuleOffsets;
        const parentNode = (_a = findLeafNodeBeforeOffset(cst, ruleStart)) === null || _a === void 0 ? void 0 : _a.astNode;
        yield Object.assign(Object.assign({}, partialContext), { node: parentNode, tokenOffset: ruleStart, tokenEndOffset: ruleEnd, features: this.findFeaturesAt(textDocument, ruleStart) });
      }
      const { nextTokenStart, nextTokenEnd, previousTokenStart, previousTokenEnd } = this.backtrackToAnyToken(text, offset);
      let astNodeOffset = nextTokenStart;
      if (offset <= nextTokenStart && previousTokenStart !== void 0) {
        astNodeOffset = previousTokenStart;
      }
      const astNode = (_b = findLeafNodeBeforeOffset(cst, astNodeOffset)) === null || _b === void 0 ? void 0 : _b.astNode;
      let performNextCompletion = true;
      if (previousTokenStart !== void 0 && previousTokenEnd !== void 0 && previousTokenEnd === offset) {
        yield Object.assign(Object.assign({}, partialContext), { node: astNode, tokenOffset: previousTokenStart, tokenEndOffset: previousTokenEnd, features: this.findFeaturesAt(textDocument, previousTokenStart) });
        performNextCompletion = this.performNextTokenCompletion(document, text.substring(previousTokenStart, previousTokenEnd), previousTokenStart, previousTokenEnd);
        if (performNextCompletion) {
          yield Object.assign(Object.assign({}, partialContext), { node: astNode, tokenOffset: previousTokenEnd, tokenEndOffset: previousTokenEnd, features: this.findFeaturesAt(textDocument, previousTokenEnd) });
        }
      }
      if (!astNode) {
        const parserRule = getEntryRule(this.grammar);
        if (!parserRule) {
          throw new Error("Missing entry parser rule");
        }
        yield Object.assign(Object.assign({}, partialContext), { tokenOffset: nextTokenStart, tokenEndOffset: nextTokenEnd, features: findFirstFeatures(parserRule.definition) });
      } else if (performNextCompletion) {
        yield Object.assign(Object.assign({}, partialContext), { node: astNode, tokenOffset: nextTokenStart, tokenEndOffset: nextTokenEnd, features: this.findFeaturesAt(textDocument, nextTokenStart) });
      }
    }
    performNextTokenCompletion(document, text, _offset, _end) {
      return /\P{L}$/u.test(text);
    }
    findDataTypeRuleStart(cst, offset) {
      var _a, _b;
      let containerNode = findDeclarationNodeAtOffset(cst, offset, this.grammarConfig.nameRegexp);
      let isDataTypeNode2 = Boolean((_a = getContainerOfType(containerNode === null || containerNode === void 0 ? void 0 : containerNode.grammarSource, isParserRule)) === null || _a === void 0 ? void 0 : _a.dataType);
      if (isDataTypeNode2) {
        while (isDataTypeNode2) {
          containerNode = containerNode === null || containerNode === void 0 ? void 0 : containerNode.container;
          isDataTypeNode2 = Boolean((_b = getContainerOfType(containerNode === null || containerNode === void 0 ? void 0 : containerNode.grammarSource, isParserRule)) === null || _b === void 0 ? void 0 : _b.dataType);
        }
        if (containerNode) {
          return [containerNode.offset, containerNode.end];
        }
      }
      return void 0;
    }
    /**
     * Indicates whether the completion should continue to process the next completion context.
     *
     * The default implementation continues the completion only if there are currently no proposed completion items.
     */
    continueCompletion(items) {
      return items.length === 0;
    }
    /**
     * This method returns two sets of token offset information.
     *
     * The `nextToken*` offsets are related to the token at the cursor position.
     * If there is none, both offsets are simply set to `offset`.
     *
     * The `previousToken*` offsets are related to the last token before the current token at the cursor position.
     * They are `undefined`, if there is no token before the cursor position.
     */
    backtrackToAnyToken(text, offset) {
      const tokens = this.lexer.tokenize(text).tokens;
      if (tokens.length === 0) {
        return {
          nextTokenStart: offset,
          nextTokenEnd: offset
        };
      }
      let previousToken;
      for (const token of tokens) {
        if (token.startOffset >= offset) {
          return {
            nextTokenStart: offset,
            nextTokenEnd: offset,
            previousTokenStart: previousToken ? previousToken.startOffset : void 0,
            previousTokenEnd: previousToken ? previousToken.endOffset + 1 : void 0
          };
        }
        if (token.endOffset >= offset) {
          return {
            nextTokenStart: token.startOffset,
            nextTokenEnd: token.endOffset + 1,
            previousTokenStart: previousToken ? previousToken.startOffset : void 0,
            previousTokenEnd: previousToken ? previousToken.endOffset + 1 : void 0
          };
        }
        previousToken = token;
      }
      return {
        nextTokenStart: offset,
        nextTokenEnd: offset,
        previousTokenStart: previousToken ? previousToken.startOffset : void 0,
        previousTokenEnd: previousToken ? previousToken.endOffset + 1 : void 0
      };
    }
    completionFor(context, next, acceptor) {
      if (isKeyword(next.feature)) {
        return this.completionForKeyword(context, next.feature, acceptor);
      } else if (isCrossReference(next.feature) && context.node) {
        return this.completionForCrossReference(context, next, acceptor);
      }
    }
    completionForCrossReference(context, next, acceptor) {
      const assignment = getContainerOfType(next.feature, isAssignment);
      let node = context.node;
      if (assignment && node) {
        if (next.type) {
          node = {
            $type: next.type,
            $container: node,
            $containerProperty: next.property
          };
          assignMandatoryProperties(this.astReflection, node);
        }
        const refInfo = {
          reference: {
            $refText: ""
          },
          container: node,
          property: assignment.feature
        };
        try {
          this.getReferenceCandidates(refInfo, context).forEach((c) => acceptor(context, this.createReferenceCompletionItem(c)));
        } catch (err) {
          console.error(err);
        }
      }
    }
    /**
     * Override this method to change how the stream of candidates is determined for a reference.
     * This way completion-specific modifications and refinements can be added to the proposals computation
     *  beyond the rules being implemented in the scope provider, e.g. filtering.
     *
     * @param refInfo Information about the reference for which the candidates are requested.
     * @param _context Information about the completion request including document, cursor position, token under cursor, etc.
     * @returns A stream of all elements being valid for the given reference.
     */
    getReferenceCandidates(refInfo, _context) {
      return this.scopeProvider.getScope(refInfo).getAllElements();
    }
    /**
     * Override this method to change how reference completion items are created.
     * To change the `kind` of a completion item, override the `NodeKindProvider` service instead.
     *
     * @param nodeDescription The description of a reference candidate
     * @returns A partial completion item
     */
    createReferenceCompletionItem(nodeDescription) {
      return {
        nodeDescription,
        kind: this.nodeKindProvider.getCompletionItemKind(nodeDescription),
        detail: nodeDescription.type,
        sortText: "0"
      };
    }
    completionForKeyword(context, keyword, acceptor) {
      if (!this.filterKeyword(context, keyword)) {
        return;
      }
      acceptor(context, {
        label: keyword.value,
        kind: import_vscode_languageserver.CompletionItemKind.Keyword,
        detail: "Keyword",
        sortText: "1"
      });
    }
    filterKeyword(context, keyword) {
      return /\p{L}/u.test(keyword.value);
    }
    fillCompletionItem(context, item) {
      var _a, _b;
      let label;
      if (typeof item.label === "string") {
        label = item.label;
      } else if ("node" in item) {
        const name = this.nameProvider.getName(item.node);
        if (!name) {
          return void 0;
        }
        label = name;
      } else if ("nodeDescription" in item) {
        label = item.nodeDescription.name;
      } else {
        return void 0;
      }
      let insertText;
      if (typeof ((_a = item.textEdit) === null || _a === void 0 ? void 0 : _a.newText) === "string") {
        insertText = item.textEdit.newText;
      } else if (typeof item.insertText === "string") {
        insertText = item.insertText;
      } else {
        insertText = label;
      }
      const textEdit = (_b = item.textEdit) !== null && _b !== void 0 ? _b : this.buildCompletionTextEdit(context, label, insertText);
      if (!textEdit) {
        return void 0;
      }
      const completionItem = {
        additionalTextEdits: item.additionalTextEdits,
        command: item.command,
        commitCharacters: item.commitCharacters,
        data: item.data,
        detail: item.detail,
        documentation: item.documentation,
        filterText: item.filterText,
        insertText: item.insertText,
        insertTextFormat: item.insertTextFormat,
        insertTextMode: item.insertTextMode,
        kind: item.kind,
        labelDetails: item.labelDetails,
        preselect: item.preselect,
        sortText: item.sortText,
        tags: item.tags,
        textEditText: item.textEditText,
        textEdit,
        label
      };
      return completionItem;
    }
    buildCompletionTextEdit(context, label, newText) {
      const content = context.textDocument.getText();
      const identifier = content.substring(context.tokenOffset, context.offset);
      if (this.fuzzyMatcher.match(identifier, label)) {
        const start = context.textDocument.positionAt(context.tokenOffset);
        const end = context.position;
        return {
          newText,
          range: {
            start,
            end
          }
        };
      } else {
        return void 0;
      }
    }
  };

  // ../node_modules/langium/lib/lsp/call-hierarchy-provider.js
  var import_vscode_languageserver2 = __toESM(require_main3(), 1);

  // ../node_modules/langium/lib/lsp/definition-provider.js
  var import_vscode_languageserver3 = __toESM(require_main3(), 1);
  var DefaultDefinitionProvider = class {
    constructor(services) {
      this.nameProvider = services.references.NameProvider;
      this.references = services.references.References;
      this.grammarConfig = services.parser.GrammarConfig;
    }
    getDefinition(document, params) {
      const rootNode = document.parseResult.value;
      if (rootNode.$cstNode) {
        const cst = rootNode.$cstNode;
        const sourceCstNode = findDeclarationNodeAtOffset(cst, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
        if (sourceCstNode) {
          return this.collectLocationLinks(sourceCstNode, params);
        }
      }
      return void 0;
    }
    collectLocationLinks(sourceCstNode, _params) {
      var _a;
      const goToLink = this.findLink(sourceCstNode);
      if (goToLink) {
        return [import_vscode_languageserver3.LocationLink.create(goToLink.targetDocument.textDocument.uri, ((_a = goToLink.target.astNode.$cstNode) !== null && _a !== void 0 ? _a : goToLink.target).range, goToLink.target.range, goToLink.source.range)];
      }
      return void 0;
    }
    findLink(source) {
      const target = this.references.findDeclarationNode(source);
      if (target === null || target === void 0 ? void 0 : target.astNode) {
        const targetDocument = getDocument(target.astNode);
        if (target && targetDocument) {
          return { source, target, targetDocument };
        }
      }
      return void 0;
    }
  };

  // ../node_modules/langium/lib/lsp/default-lsp-module.js
  var import_vscode_languageserver10 = __toESM(require_main3(), 1);

  // ../node_modules/langium/lib/lsp/document-highlight-provider.js
  var import_vscode_languageserver4 = __toESM(require_main3(), 1);
  var DefaultDocumentHighlightProvider = class {
    constructor(services) {
      this.references = services.references.References;
      this.nameProvider = services.references.NameProvider;
      this.grammarConfig = services.parser.GrammarConfig;
    }
    getDocumentHighlight(document, params) {
      const rootNode = document.parseResult.value.$cstNode;
      if (!rootNode) {
        return void 0;
      }
      const selectedNode = findDeclarationNodeAtOffset(rootNode, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
      if (!selectedNode) {
        return void 0;
      }
      const targetAstNode = this.references.findDeclaration(selectedNode);
      if (targetAstNode) {
        const includeDeclaration = UriUtils.equals(getDocument(targetAstNode).uri, document.uri);
        const options = { documentUri: document.uri, includeDeclaration };
        const references = this.references.findReferences(targetAstNode, options);
        return references.map((ref) => this.createDocumentHighlight(ref)).toArray();
      }
      return void 0;
    }
    /**
    * Override this method to determine the highlight kind of the given reference.
    */
    createDocumentHighlight(reference) {
      return import_vscode_languageserver4.DocumentHighlight.create(reference.segment.range);
    }
  };

  // ../node_modules/langium/lib/lsp/document-symbol-provider.js
  var DefaultDocumentSymbolProvider = class {
    constructor(services) {
      this.nameProvider = services.references.NameProvider;
      this.nodeKindProvider = services.shared.lsp.NodeKindProvider;
    }
    getSymbols(document) {
      return this.getSymbol(document, document.parseResult.value);
    }
    getSymbol(document, astNode) {
      const node = astNode.$cstNode;
      const nameNode = this.nameProvider.getNameNode(astNode);
      if (nameNode && node) {
        const name = this.nameProvider.getName(astNode);
        return [{
          kind: this.nodeKindProvider.getSymbolKind(astNode),
          name: name !== null && name !== void 0 ? name : nameNode.text,
          range: node.range,
          selectionRange: nameNode.range,
          children: this.getChildSymbols(document, astNode)
        }];
      } else {
        return this.getChildSymbols(document, astNode) || [];
      }
    }
    getChildSymbols(document, astNode) {
      const children = [];
      for (const child of streamContents(astNode)) {
        const result = this.getSymbol(document, child);
        children.push(...result);
      }
      if (children.length > 0) {
        return children;
      }
      return void 0;
    }
  };

  // ../node_modules/langium/lib/lsp/document-update-handler.js
  var import_vscode_languageserver5 = __toESM(require_main3(), 1);
  var DefaultDocumentUpdateHandler = class {
    constructor(services) {
      this.workspaceManager = services.workspace.WorkspaceManager;
      this.documentBuilder = services.workspace.DocumentBuilder;
      this.workspaceLock = services.workspace.WorkspaceLock;
      let canRegisterFileWatcher = false;
      services.lsp.LanguageServer.onInitialize((params) => {
        var _a, _b;
        canRegisterFileWatcher = Boolean((_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.didChangeWatchedFiles) === null || _b === void 0 ? void 0 : _b.dynamicRegistration);
      });
      services.lsp.LanguageServer.onInitialized((_params) => {
        if (canRegisterFileWatcher) {
          this.registerFileWatcher(services);
        }
      });
    }
    registerFileWatcher(services) {
      const fileExtensions = stream(services.ServiceRegistry.all).flatMap((language) => language.LanguageMetaData.fileExtensions).map((ext) => ext.startsWith(".") ? ext.substring(1) : ext).distinct().toArray();
      if (fileExtensions.length > 0) {
        const connection2 = services.lsp.Connection;
        const options = {
          watchers: [{
            globPattern: fileExtensions.length === 1 ? `**/*.${fileExtensions[0]}` : `**/*.{${fileExtensions.join(",")}}`
          }]
        };
        connection2 === null || connection2 === void 0 ? void 0 : connection2.client.register(import_vscode_languageserver5.DidChangeWatchedFilesNotification.type, options);
      }
    }
    fireDocumentUpdate(changed, deleted) {
      this.workspaceManager.ready.then(() => {
        this.workspaceLock.write((token) => this.documentBuilder.update(changed, deleted, token));
      }).catch((err) => {
        console.error("Workspace initialization failed. Could not perform document update.", err);
      });
    }
    didChangeContent(change) {
      this.fireDocumentUpdate([URI2.parse(change.document.uri)], []);
    }
    didChangeWatchedFiles(params) {
      const changedUris = stream(params.changes).filter((c) => c.type !== import_vscode_languageserver5.FileChangeType.Deleted).distinct((c) => c.uri).map((c) => URI2.parse(c.uri)).toArray();
      const deletedUris = stream(params.changes).filter((c) => c.type === import_vscode_languageserver5.FileChangeType.Deleted).distinct((c) => c.uri).map((c) => URI2.parse(c.uri)).toArray();
      this.fireDocumentUpdate(changedUris, deletedUris);
    }
  };

  // ../node_modules/langium/lib/lsp/folding-range-provider.js
  var import_vscode_languageserver6 = __toESM(require_main3(), 1);
  var DefaultFoldingRangeProvider = class {
    constructor(services) {
      this.commentNames = services.parser.GrammarConfig.multilineCommentRules;
    }
    getFoldingRanges(document) {
      const foldings = [];
      const acceptor = (foldingRange) => foldings.push(foldingRange);
      this.collectFolding(document, acceptor);
      return foldings;
    }
    collectFolding(document, acceptor) {
      var _a;
      const root2 = (_a = document.parseResult) === null || _a === void 0 ? void 0 : _a.value;
      if (root2) {
        if (this.shouldProcessContent(root2)) {
          const treeIterator = streamAllContents(root2).iterator();
          let result;
          do {
            result = treeIterator.next();
            if (!result.done) {
              const node = result.value;
              if (this.shouldProcess(node)) {
                this.collectObjectFolding(document, node, acceptor);
              }
              if (!this.shouldProcessContent(node)) {
                treeIterator.prune();
              }
            }
          } while (!result.done);
        }
        this.collectCommentFolding(document, root2, acceptor);
      }
    }
    /**
     * Template method to determine whether the specified `AstNode` should be handled by the folding range provider.
     * Returns true by default for all nodes. Returning false only ignores the specified node and not its content.
     * To ignore the content of a node use `shouldProcessContent`.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldProcess(node) {
      return true;
    }
    /**
     * Template method to determine whether the content/children of the specified `AstNode` should be handled by the folding range provider.
     * Returns true by default for all nodes. Returning false ignores _all_ content of this node, even transitive ones.
     * For more precise control over foldings use the `shouldProcess` method.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldProcessContent(node) {
      return true;
    }
    collectObjectFolding(document, node, acceptor) {
      const cstNode = node.$cstNode;
      if (cstNode) {
        const foldingRange = this.toFoldingRange(document, cstNode);
        if (foldingRange) {
          acceptor(foldingRange);
        }
      }
    }
    collectCommentFolding(document, node, acceptor) {
      const cstNode = node.$cstNode;
      if (cstNode) {
        for (const node2 of flattenCst(cstNode)) {
          if (this.commentNames.includes(node2.tokenType.name)) {
            const foldingRange = this.toFoldingRange(document, node2, import_vscode_languageserver6.FoldingRangeKind.Comment);
            if (foldingRange) {
              acceptor(foldingRange);
            }
          }
        }
      }
    }
    toFoldingRange(document, node, kind) {
      const range = node.range;
      const start = range.start;
      let end = range.end;
      if (end.line - start.line < 2) {
        return void 0;
      }
      if (!this.includeLastFoldingLine(node, kind)) {
        end = document.textDocument.positionAt(document.textDocument.offsetAt({ line: end.line, character: 0 }) - 1);
      }
      return import_vscode_languageserver6.FoldingRange.create(start.line, end.line, start.character, end.character, kind);
    }
    /**
     * Template method to determine whether the folding range for this cst node should include its last line.
     * Returns false by default for ast nodes which end in braces and for comments.
     */
    includeLastFoldingLine(node, kind) {
      if (kind === import_vscode_languageserver6.FoldingRangeKind.Comment) {
        return false;
      }
      const nodeText = node.text;
      const endChar = nodeText.charAt(nodeText.length - 1);
      if (endChar === "}" || endChar === ")" || endChar === "]") {
        return false;
      }
      return true;
    }
  };

  // ../node_modules/langium/lib/lsp/fuzzy-matcher.js
  var DefaultFuzzyMatcher = class {
    match(query, text) {
      if (query.length === 0) {
        return true;
      }
      text = text.toLowerCase();
      let matchedFirstCharacter = false;
      let previous;
      let character = 0;
      const len = text.length;
      for (let i = 0; i < len; i++) {
        const strChar = text.charCodeAt(i);
        const testChar = query.charCodeAt(character);
        if (strChar === testChar || this.toUpperCharCode(strChar) === this.toUpperCharCode(testChar)) {
          matchedFirstCharacter || (matchedFirstCharacter = previous === void 0 || // Beginning of word
          this.isWordTransition(previous, strChar));
          if (matchedFirstCharacter) {
            character++;
          }
          if (character === query.length) {
            return true;
          }
        }
        previous = strChar;
      }
      return false;
    }
    isWordTransition(previous, current) {
      return a <= previous && previous <= z && A <= current && current <= Z || // camelCase transition
      previous === _ && current !== _;
    }
    toUpperCharCode(charCode) {
      if (a <= charCode && charCode <= z) {
        return charCode - 32;
      }
      return charCode;
    }
  };
  var a = "a".charCodeAt(0);
  var z = "z".charCodeAt(0);
  var A = "A".charCodeAt(0);
  var Z = "Z".charCodeAt(0);
  var _ = "_".charCodeAt(0);

  // ../node_modules/langium/lib/lsp/hover-provider.js
  var AstNodeHoverProvider = class {
    constructor(services) {
      this.references = services.references.References;
      this.grammarConfig = services.parser.GrammarConfig;
    }
    getHoverContent(document, params) {
      var _a, _b;
      const rootNode = (_b = (_a = document.parseResult) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.$cstNode;
      if (rootNode) {
        const offset = document.textDocument.offsetAt(params.position);
        const cstNode = findDeclarationNodeAtOffset(rootNode, offset, this.grammarConfig.nameRegexp);
        if (cstNode && cstNode.offset + cstNode.length > offset) {
          const targetNode = this.references.findDeclaration(cstNode);
          if (targetNode) {
            return this.getAstNodeHoverContent(targetNode);
          }
        }
      }
      return void 0;
    }
  };
  var MultilineCommentHoverProvider = class extends AstNodeHoverProvider {
    constructor(services) {
      super(services);
      this.documentationProvider = services.documentation.DocumentationProvider;
    }
    getAstNodeHoverContent(node) {
      const content = this.documentationProvider.getDocumentation(node);
      if (content) {
        return {
          contents: {
            kind: "markdown",
            value: content
          }
        };
      }
      return void 0;
    }
  };

  // ../node_modules/langium/lib/lsp/language-server.js
  var import_vscode_languageserver_protocol = __toESM(require_main2(), 1);

  // ../node_modules/langium/lib/lsp/semantic-token-provider.js
  var import_vscode_languageserver7 = __toESM(require_main3(), 1);
  var AllSemanticTokenTypes = {
    [import_vscode_languageserver7.SemanticTokenTypes.class]: 0,
    [import_vscode_languageserver7.SemanticTokenTypes.comment]: 1,
    [import_vscode_languageserver7.SemanticTokenTypes.enum]: 2,
    [import_vscode_languageserver7.SemanticTokenTypes.enumMember]: 3,
    [import_vscode_languageserver7.SemanticTokenTypes.event]: 4,
    [import_vscode_languageserver7.SemanticTokenTypes.function]: 5,
    [import_vscode_languageserver7.SemanticTokenTypes.interface]: 6,
    [import_vscode_languageserver7.SemanticTokenTypes.keyword]: 7,
    [import_vscode_languageserver7.SemanticTokenTypes.macro]: 8,
    [import_vscode_languageserver7.SemanticTokenTypes.method]: 9,
    [import_vscode_languageserver7.SemanticTokenTypes.modifier]: 10,
    [import_vscode_languageserver7.SemanticTokenTypes.namespace]: 11,
    [import_vscode_languageserver7.SemanticTokenTypes.number]: 12,
    [import_vscode_languageserver7.SemanticTokenTypes.operator]: 13,
    [import_vscode_languageserver7.SemanticTokenTypes.parameter]: 14,
    [import_vscode_languageserver7.SemanticTokenTypes.property]: 15,
    [import_vscode_languageserver7.SemanticTokenTypes.regexp]: 16,
    [import_vscode_languageserver7.SemanticTokenTypes.string]: 17,
    [import_vscode_languageserver7.SemanticTokenTypes.struct]: 18,
    [import_vscode_languageserver7.SemanticTokenTypes.type]: 19,
    [import_vscode_languageserver7.SemanticTokenTypes.typeParameter]: 20,
    [import_vscode_languageserver7.SemanticTokenTypes.variable]: 21,
    [import_vscode_languageserver7.SemanticTokenTypes.decorator]: 22
  };
  var AllSemanticTokenModifiers = {
    [import_vscode_languageserver7.SemanticTokenModifiers.abstract]: 1 << 0,
    [import_vscode_languageserver7.SemanticTokenModifiers.async]: 1 << 1,
    [import_vscode_languageserver7.SemanticTokenModifiers.declaration]: 1 << 2,
    [import_vscode_languageserver7.SemanticTokenModifiers.defaultLibrary]: 1 << 3,
    [import_vscode_languageserver7.SemanticTokenModifiers.definition]: 1 << 4,
    [import_vscode_languageserver7.SemanticTokenModifiers.deprecated]: 1 << 5,
    [import_vscode_languageserver7.SemanticTokenModifiers.documentation]: 1 << 6,
    [import_vscode_languageserver7.SemanticTokenModifiers.modification]: 1 << 7,
    [import_vscode_languageserver7.SemanticTokenModifiers.readonly]: 1 << 8,
    [import_vscode_languageserver7.SemanticTokenModifiers.static]: 1 << 9
  };
  var DefaultSemanticTokenOptions = {
    legend: {
      tokenTypes: Object.keys(AllSemanticTokenTypes),
      tokenModifiers: Object.keys(AllSemanticTokenModifiers)
    },
    full: {
      delta: true
    },
    range: true
  };
  var SemanticTokensBuilder = class extends import_vscode_languageserver7.SemanticTokensBuilder {
    constructor() {
      super(...arguments);
      this._tokens = [];
    }
    push(line, char, length, tokenType, tokenModifiers) {
      this._tokens.push({
        line,
        char,
        length,
        tokenType,
        tokenModifiers
      });
    }
    build() {
      this.applyTokens();
      return super.build();
    }
    buildEdits() {
      this.applyTokens();
      return super.buildEdits();
    }
    /**
     * Flushes the cached delta token values
     */
    flush() {
      this.previousResult(this.id);
    }
    applyTokens() {
      for (const token of this._tokens.sort(this.compareTokens)) {
        super.push(token.line, token.char, token.length, token.tokenType, token.tokenModifiers);
      }
      this._tokens = [];
    }
    compareTokens(a2, b) {
      if (a2.line === b.line) {
        return a2.char - b.char;
      }
      return a2.line - b.line;
    }
  };
  var AbstractSemanticTokenProvider = class {
    constructor(services) {
      this.tokensBuilders = /* @__PURE__ */ new Map();
      services.shared.workspace.TextDocuments.onDidClose((e) => {
        this.tokensBuilders.delete(e.document.uri);
      });
      services.shared.lsp.LanguageServer.onInitialize((params) => {
        var _a;
        this.initialize((_a = params.capabilities.textDocument) === null || _a === void 0 ? void 0 : _a.semanticTokens);
      });
    }
    initialize(clientCapabilities) {
      this.clientCapabilities = clientCapabilities;
    }
    async semanticHighlight(document, _params, cancelToken = cancellation_exports.CancellationToken.None) {
      this.currentRange = void 0;
      this.currentDocument = document;
      this.currentTokensBuilder = this.getDocumentTokensBuilder(document);
      this.currentTokensBuilder.flush();
      await this.computeHighlighting(document, this.createAcceptor(), cancelToken);
      return this.currentTokensBuilder.build();
    }
    async semanticHighlightRange(document, params, cancelToken = cancellation_exports.CancellationToken.None) {
      this.currentRange = params.range;
      this.currentDocument = document;
      this.currentTokensBuilder = this.getDocumentTokensBuilder(document);
      this.currentTokensBuilder.flush();
      await this.computeHighlighting(document, this.createAcceptor(), cancelToken);
      return this.currentTokensBuilder.build();
    }
    async semanticHighlightDelta(document, params, cancelToken = cancellation_exports.CancellationToken.None) {
      this.currentRange = void 0;
      this.currentDocument = document;
      this.currentTokensBuilder = this.getDocumentTokensBuilder(document);
      this.currentTokensBuilder.previousResult(params.previousResultId);
      await this.computeHighlighting(document, this.createAcceptor(), cancelToken);
      return this.currentTokensBuilder.buildEdits();
    }
    createAcceptor() {
      const acceptor = (options) => {
        if ("line" in options) {
          this.highlightToken({
            range: {
              start: {
                line: options.line,
                character: options.char
              },
              end: {
                line: options.line,
                character: options.char + options.length
              }
            },
            type: options.type,
            modifier: options.modifier
          });
        } else if ("range" in options) {
          this.highlightToken(options);
        } else if ("keyword" in options) {
          this.highlightKeyword(options);
        } else if ("property" in options) {
          this.highlightProperty(options);
        } else {
          this.highlightNode({
            node: options.cst,
            type: options.type,
            modifier: options.modifier
          });
        }
      };
      return acceptor;
    }
    getDocumentTokensBuilder(document) {
      const existing = this.tokensBuilders.get(document.uri.toString());
      if (existing) {
        return existing;
      }
      const builder = new SemanticTokensBuilder();
      this.tokensBuilders.set(document.uri.toString(), builder);
      return builder;
    }
    async computeHighlighting(document, acceptor, cancelToken) {
      const root2 = document.parseResult.value;
      const treeIterator = streamAst(root2, { range: this.currentRange }).iterator();
      let result;
      do {
        result = treeIterator.next();
        if (!result.done) {
          await interruptAndCheck(cancelToken);
          const node = result.value;
          if (this.highlightElement(node, acceptor) === "prune") {
            treeIterator.prune();
          }
        }
      } while (!result.done);
    }
    highlightToken(options) {
      var _a;
      const { range, type } = options;
      let modifiers = options.modifier;
      if (this.currentRange && !inRange(range, this.currentRange) || !this.currentDocument || !this.currentTokensBuilder) {
        return;
      }
      const intType = AllSemanticTokenTypes[type];
      let totalModifier = 0;
      if (modifiers !== void 0) {
        if (typeof modifiers === "string") {
          modifiers = [modifiers];
        }
        for (const modifier of modifiers) {
          const intModifier = AllSemanticTokenModifiers[modifier];
          totalModifier |= intModifier;
        }
      }
      const startLine = range.start.line;
      const endLine = range.end.line;
      if (startLine === endLine) {
        const char = range.start.character;
        const length = range.end.character - char;
        this.currentTokensBuilder.push(startLine, char, length, intType, totalModifier);
      } else if ((_a = this.clientCapabilities) === null || _a === void 0 ? void 0 : _a.multilineTokenSupport) {
        const startChar = range.start.character;
        const startOffset = this.currentDocument.textDocument.offsetAt(range.start);
        const endOffset = this.currentDocument.textDocument.offsetAt(range.end);
        this.currentTokensBuilder.push(startLine, startChar, endOffset - startOffset, intType, totalModifier);
      } else {
        const firstLineStart = range.start;
        let nextLineOffset = this.currentDocument.textDocument.offsetAt({
          line: startLine + 1,
          character: 0
        });
        this.currentTokensBuilder.push(firstLineStart.line, firstLineStart.character, nextLineOffset - firstLineStart.character - 1, intType, totalModifier);
        for (let i = startLine + 1; i < endLine; i++) {
          const currentLineOffset = nextLineOffset;
          nextLineOffset = this.currentDocument.textDocument.offsetAt({
            line: i + 1,
            character: 0
          });
          this.currentTokensBuilder.push(i, 0, nextLineOffset - currentLineOffset - 1, intType, totalModifier);
        }
        this.currentTokensBuilder.push(endLine, 0, range.end.character, intType, totalModifier);
      }
    }
    highlightProperty(options) {
      const nodes = [];
      if (typeof options.index === "number") {
        const node = findNodeForProperty(options.node.$cstNode, options.property, options.index);
        if (node) {
          nodes.push(node);
        }
      } else {
        nodes.push(...findNodesForProperty(options.node.$cstNode, options.property));
      }
      const { type, modifier } = options;
      for (const node of nodes) {
        this.highlightNode({
          node,
          type,
          modifier
        });
      }
    }
    highlightKeyword(options) {
      const { node, keyword, type, index, modifier } = options;
      const nodes = [];
      if (typeof index === "number") {
        const keywordNode = findNodeForKeyword(node.$cstNode, keyword, index);
        if (keywordNode) {
          nodes.push(keywordNode);
        }
      } else {
        nodes.push(...findNodesForKeyword(node.$cstNode, keyword));
      }
      for (const keywordNode of nodes) {
        this.highlightNode({
          node: keywordNode,
          type,
          modifier
        });
      }
    }
    highlightNode(options) {
      const { node, type, modifier } = options;
      const range = node.range;
      this.highlightToken({
        range,
        type,
        modifier
      });
    }
  };
  var SemanticTokensDecoder;
  (function(SemanticTokensDecoder2) {
    function decode(tokens, document) {
      const typeMap = /* @__PURE__ */ new Map();
      Object.entries(AllSemanticTokenTypes).forEach(([type, index]) => typeMap.set(index, type));
      let line = 0;
      let character = 0;
      return sliceIntoChunks(tokens.data, 5).map((t) => {
        line += t[0];
        if (t[0] !== 0) {
          character = 0;
        }
        character += t[1];
        const length = t[2];
        const offset = document.textDocument.offsetAt({ line, character });
        return {
          offset,
          tokenType: typeMap.get(t[3]),
          tokenModifiers: t[4],
          text: document.textDocument.getText({ start: { line, character }, end: { line, character: character + length } })
        };
      });
    }
    SemanticTokensDecoder2.decode = decode;
    function sliceIntoChunks(arr, chunkSize) {
      const res = [];
      for (let i = 0; i < arr.length; i += chunkSize) {
        const chunk = arr.slice(i, i + chunkSize);
        res.push(chunk);
      }
      return res;
    }
  })(SemanticTokensDecoder || (SemanticTokensDecoder = {}));

  // ../node_modules/langium/lib/lsp/signature-help-provider.js
  function mergeSignatureHelpOptions(options) {
    const triggerCharacters = [];
    const retriggerCharacters = [];
    options.forEach((option2) => {
      if (option2 === null || option2 === void 0 ? void 0 : option2.triggerCharacters) {
        triggerCharacters.push(...option2.triggerCharacters);
      }
      if (option2 === null || option2 === void 0 ? void 0 : option2.retriggerCharacters) {
        retriggerCharacters.push(...option2.retriggerCharacters);
      }
    });
    const mergedOptions = {
      triggerCharacters: triggerCharacters.length > 0 ? Array.from(new Set(triggerCharacters)).sort() : void 0,
      retriggerCharacters: retriggerCharacters.length > 0 ? Array.from(new Set(retriggerCharacters)).sort() : void 0
    };
    return mergedOptions.triggerCharacters ? mergedOptions : void 0;
  }

  // ../node_modules/langium/lib/lsp/language-server.js
  var DefaultLanguageServer = class {
    constructor(services) {
      this.onInitializeEmitter = new import_vscode_languageserver_protocol.Emitter();
      this.onInitializedEmitter = new import_vscode_languageserver_protocol.Emitter();
      this.services = services;
    }
    get onInitialize() {
      return this.onInitializeEmitter.event;
    }
    get onInitialized() {
      return this.onInitializedEmitter.event;
    }
    async initialize(params) {
      this.eagerLoadServices();
      this.fireInitializeOnDefaultServices(params);
      this.onInitializeEmitter.fire(params);
      this.onInitializeEmitter.dispose();
      return this.buildInitializeResult(params);
    }
    /**
     * Eagerly loads all services before emitting the `onInitialize` event.
     * Ensures that all services are able to catch the event.
     */
    eagerLoadServices() {
      eagerLoad(this.services);
      this.services.ServiceRegistry.all.forEach((language) => eagerLoad(language));
    }
    hasService(callback) {
      const allServices = this.services.ServiceRegistry.all;
      return allServices.some((services) => callback(services) !== void 0);
    }
    buildInitializeResult(_params) {
      var _a, _b, _c, _d;
      const fileOperationOptions = (_a = this.services.lsp.FileOperationHandler) === null || _a === void 0 ? void 0 : _a.fileOperationOptions;
      const allServices = this.services.ServiceRegistry.all;
      const hasFormattingService = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.Formatter;
      });
      const formattingOnTypeOptions = allServices.map((e) => {
        var _a2, _b2;
        return (_b2 = (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.Formatter) === null || _b2 === void 0 ? void 0 : _b2.formatOnTypeOptions;
      }).find((e) => Boolean(e));
      const hasCodeActionProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.CodeActionProvider;
      });
      const hasSemanticTokensProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.SemanticTokenProvider;
      });
      const commandNames = (_c = (_b = this.services.lsp) === null || _b === void 0 ? void 0 : _b.ExecuteCommandHandler) === null || _c === void 0 ? void 0 : _c.commands;
      const hasDocumentLinkProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.DocumentLinkProvider;
      });
      const signatureHelpOptions = mergeSignatureHelpOptions(allServices.map((e) => {
        var _a2, _b2;
        return (_b2 = (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.SignatureHelp) === null || _b2 === void 0 ? void 0 : _b2.signatureHelpOptions;
      }));
      const hasGoToTypeProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.TypeProvider;
      });
      const hasGoToImplementationProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.ImplementationProvider;
      });
      const hasCompletionProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.CompletionProvider;
      });
      const completionOptions = mergeCompletionProviderOptions(allServices.map((e) => {
        var _a2, _b2;
        return (_b2 = (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.CompletionProvider) === null || _b2 === void 0 ? void 0 : _b2.completionOptions;
      }));
      const hasReferencesProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.ReferencesProvider;
      });
      const hasDocumentSymbolProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.DocumentSymbolProvider;
      });
      const hasDefinitionProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.DefinitionProvider;
      });
      const hasDocumentHighlightProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.DocumentHighlightProvider;
      });
      const hasFoldingRangeProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.FoldingRangeProvider;
      });
      const hasHoverProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.HoverProvider;
      });
      const hasRenameProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.RenameProvider;
      });
      const hasCallHierarchyProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.CallHierarchyProvider;
      });
      const hasTypeHierarchyProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.TypeHierarchyProvider;
      });
      const hasCodeLensProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.CodeLensProvider;
      });
      const hasDeclarationProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.DeclarationProvider;
      });
      const hasInlayHintProvider = this.hasService((e) => {
        var _a2;
        return (_a2 = e.lsp) === null || _a2 === void 0 ? void 0 : _a2.InlayHintProvider;
      });
      const workspaceSymbolProvider = (_d = this.services.lsp) === null || _d === void 0 ? void 0 : _d.WorkspaceSymbolProvider;
      const result = {
        capabilities: {
          workspace: {
            workspaceFolders: {
              supported: true
            },
            fileOperations: fileOperationOptions
          },
          executeCommandProvider: commandNames && {
            commands: commandNames
          },
          textDocumentSync: import_vscode_languageserver_protocol.TextDocumentSyncKind.Incremental,
          completionProvider: hasCompletionProvider ? completionOptions : void 0,
          referencesProvider: hasReferencesProvider,
          documentSymbolProvider: hasDocumentSymbolProvider,
          definitionProvider: hasDefinitionProvider,
          typeDefinitionProvider: hasGoToTypeProvider,
          documentHighlightProvider: hasDocumentHighlightProvider,
          codeActionProvider: hasCodeActionProvider,
          documentFormattingProvider: hasFormattingService,
          documentRangeFormattingProvider: hasFormattingService,
          documentOnTypeFormattingProvider: formattingOnTypeOptions,
          foldingRangeProvider: hasFoldingRangeProvider,
          hoverProvider: hasHoverProvider,
          renameProvider: hasRenameProvider ? {
            prepareProvider: true
          } : void 0,
          semanticTokensProvider: hasSemanticTokensProvider ? DefaultSemanticTokenOptions : void 0,
          signatureHelpProvider: signatureHelpOptions,
          implementationProvider: hasGoToImplementationProvider,
          callHierarchyProvider: hasCallHierarchyProvider ? {} : void 0,
          typeHierarchyProvider: hasTypeHierarchyProvider ? {} : void 0,
          documentLinkProvider: hasDocumentLinkProvider ? { resolveProvider: false } : void 0,
          codeLensProvider: hasCodeLensProvider ? { resolveProvider: false } : void 0,
          declarationProvider: hasDeclarationProvider,
          inlayHintProvider: hasInlayHintProvider ? { resolveProvider: false } : void 0,
          workspaceSymbolProvider: workspaceSymbolProvider ? { resolveProvider: Boolean(workspaceSymbolProvider.resolveSymbol) } : void 0
        }
      };
      return result;
    }
    initialized(params) {
      this.fireInitializedOnDefaultServices(params);
      this.onInitializedEmitter.fire(params);
      this.onInitializedEmitter.dispose();
    }
    fireInitializeOnDefaultServices(params) {
      this.services.workspace.ConfigurationProvider.initialize(params);
      this.services.workspace.WorkspaceManager.initialize(params);
    }
    fireInitializedOnDefaultServices(params) {
      const connection2 = this.services.lsp.Connection;
      const configurationParams = connection2 ? Object.assign(Object.assign({}, params), { register: (params2) => connection2.client.register(import_vscode_languageserver_protocol.DidChangeConfigurationNotification.type, params2), fetchConfiguration: (params2) => connection2.workspace.getConfiguration(params2) }) : params;
      this.services.workspace.ConfigurationProvider.initialized(configurationParams).catch((err) => console.error("Error in ConfigurationProvider initialization:", err));
      this.services.workspace.WorkspaceManager.initialized(params).catch((err) => console.error("Error in WorkspaceManager initialization:", err));
    }
  };
  function startLanguageServer(services) {
    const connection2 = services.lsp.Connection;
    if (!connection2) {
      throw new Error("Starting a language server requires the languageServer.Connection service to be set.");
    }
    addDocumentUpdateHandler(connection2, services);
    addFileOperationHandler(connection2, services);
    addDiagnosticsHandler(connection2, services);
    addCompletionHandler(connection2, services);
    addFindReferencesHandler(connection2, services);
    addDocumentSymbolHandler(connection2, services);
    addGotoDefinitionHandler(connection2, services);
    addGoToTypeDefinitionHandler(connection2, services);
    addGoToImplementationHandler(connection2, services);
    addDocumentHighlightsHandler(connection2, services);
    addFoldingRangeHandler(connection2, services);
    addFormattingHandler(connection2, services);
    addCodeActionHandler(connection2, services);
    addRenameHandler(connection2, services);
    addHoverHandler(connection2, services);
    addInlayHintHandler(connection2, services);
    addSemanticTokenHandler(connection2, services);
    addExecuteCommandHandler(connection2, services);
    addSignatureHelpHandler(connection2, services);
    addCallHierarchyHandler(connection2, services);
    addTypeHierarchyHandler(connection2, services);
    addCodeLensHandler(connection2, services);
    addDocumentLinkHandler(connection2, services);
    addConfigurationChangeHandler(connection2, services);
    addGoToDeclarationHandler(connection2, services);
    addWorkspaceSymbolHandler(connection2, services);
    connection2.onInitialize((params) => {
      return services.lsp.LanguageServer.initialize(params);
    });
    connection2.onInitialized((params) => {
      services.lsp.LanguageServer.initialized(params);
    });
    const documents = services.workspace.TextDocuments;
    documents.listen(connection2);
    connection2.listen();
  }
  function addDocumentUpdateHandler(connection2, services) {
    const handler = services.lsp.DocumentUpdateHandler;
    const documents = services.workspace.TextDocuments;
    documents.onDidChangeContent((change) => handler.didChangeContent(change));
    connection2.onDidChangeWatchedFiles((params) => handler.didChangeWatchedFiles(params));
  }
  function addFileOperationHandler(connection2, services) {
    const handler = services.lsp.FileOperationHandler;
    if (!handler) {
      return;
    }
    if (handler.didCreateFiles) {
      connection2.workspace.onDidCreateFiles((params) => handler.didCreateFiles(params));
    }
    if (handler.didRenameFiles) {
      connection2.workspace.onDidRenameFiles((params) => handler.didRenameFiles(params));
    }
    if (handler.didDeleteFiles) {
      connection2.workspace.onDidDeleteFiles((params) => handler.didDeleteFiles(params));
    }
    if (handler.willCreateFiles) {
      connection2.workspace.onWillCreateFiles((params) => handler.willCreateFiles(params));
    }
    if (handler.willRenameFiles) {
      connection2.workspace.onWillRenameFiles((params) => handler.willRenameFiles(params));
    }
    if (handler.willDeleteFiles) {
      connection2.workspace.onWillDeleteFiles((params) => handler.willDeleteFiles(params));
    }
  }
  function addDiagnosticsHandler(connection2, services) {
    const documentBuilder = services.workspace.DocumentBuilder;
    documentBuilder.onBuildPhase(DocumentState.Validated, async (documents, cancelToken) => {
      for (const document of documents) {
        if (document.diagnostics) {
          connection2.sendDiagnostics({
            uri: document.uri.toString(),
            diagnostics: document.diagnostics
          });
        }
        if (cancelToken.isCancellationRequested) {
          return;
        }
      }
    });
  }
  function addCompletionHandler(connection2, services) {
    connection2.onCompletion(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.CompletionProvider) === null || _b === void 0 ? void 0 : _b.getCompletion(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addFindReferencesHandler(connection2, services) {
    connection2.onReferences(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.ReferencesProvider) === null || _b === void 0 ? void 0 : _b.findReferences(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addCodeActionHandler(connection2, services) {
    connection2.onCodeAction(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.CodeActionProvider) === null || _b === void 0 ? void 0 : _b.getCodeActions(document, params, cancelToken);
    }, services, DocumentState.Validated));
  }
  function addDocumentSymbolHandler(connection2, services) {
    connection2.onDocumentSymbol(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.DocumentSymbolProvider) === null || _b === void 0 ? void 0 : _b.getSymbols(document, params, cancelToken);
    }, services, DocumentState.Parsed));
  }
  function addGotoDefinitionHandler(connection2, services) {
    connection2.onDefinition(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.DefinitionProvider) === null || _b === void 0 ? void 0 : _b.getDefinition(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addGoToTypeDefinitionHandler(connection2, services) {
    connection2.onTypeDefinition(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.TypeProvider) === null || _b === void 0 ? void 0 : _b.getTypeDefinition(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addGoToImplementationHandler(connection2, services) {
    connection2.onImplementation(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.ImplementationProvider) === null || _b === void 0 ? void 0 : _b.getImplementation(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addGoToDeclarationHandler(connection2, services) {
    connection2.onDeclaration(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.DeclarationProvider) === null || _b === void 0 ? void 0 : _b.getDeclaration(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addDocumentHighlightsHandler(connection2, services) {
    connection2.onDocumentHighlight(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.DocumentHighlightProvider) === null || _b === void 0 ? void 0 : _b.getDocumentHighlight(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addHoverHandler(connection2, services) {
    connection2.onHover(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.HoverProvider) === null || _b === void 0 ? void 0 : _b.getHoverContent(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addFoldingRangeHandler(connection2, services) {
    connection2.onFoldingRanges(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.FoldingRangeProvider) === null || _b === void 0 ? void 0 : _b.getFoldingRanges(document, params, cancelToken);
    }, services, DocumentState.Parsed));
  }
  function addFormattingHandler(connection2, services) {
    connection2.onDocumentFormatting(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.Formatter) === null || _b === void 0 ? void 0 : _b.formatDocument(document, params, cancelToken);
    }, services, DocumentState.Parsed));
    connection2.onDocumentRangeFormatting(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.Formatter) === null || _b === void 0 ? void 0 : _b.formatDocumentRange(document, params, cancelToken);
    }, services, DocumentState.Parsed));
    connection2.onDocumentOnTypeFormatting(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.Formatter) === null || _b === void 0 ? void 0 : _b.formatDocumentOnType(document, params, cancelToken);
    }, services, DocumentState.Parsed));
  }
  function addRenameHandler(connection2, services) {
    connection2.onRenameRequest(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.RenameProvider) === null || _b === void 0 ? void 0 : _b.rename(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
    connection2.onPrepareRename(createRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.RenameProvider) === null || _b === void 0 ? void 0 : _b.prepareRename(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addInlayHintHandler(connection2, services) {
    connection2.languages.inlayHint.on(createServerRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.InlayHintProvider) === null || _b === void 0 ? void 0 : _b.getInlayHints(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addSemanticTokenHandler(connection2, services) {
    const emptyResult = { data: [] };
    connection2.languages.semanticTokens.on(createServerRequestHandler((services2, document, params, cancelToken) => {
      var _a;
      if ((_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.SemanticTokenProvider) {
        return services2.lsp.SemanticTokenProvider.semanticHighlight(document, params, cancelToken);
      }
      return emptyResult;
    }, services, DocumentState.IndexedReferences));
    connection2.languages.semanticTokens.onDelta(createServerRequestHandler((services2, document, params, cancelToken) => {
      var _a;
      if ((_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.SemanticTokenProvider) {
        return services2.lsp.SemanticTokenProvider.semanticHighlightDelta(document, params, cancelToken);
      }
      return emptyResult;
    }, services, DocumentState.IndexedReferences));
    connection2.languages.semanticTokens.onRange(createServerRequestHandler((services2, document, params, cancelToken) => {
      var _a;
      if ((_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.SemanticTokenProvider) {
        return services2.lsp.SemanticTokenProvider.semanticHighlightRange(document, params, cancelToken);
      }
      return emptyResult;
    }, services, DocumentState.IndexedReferences));
  }
  function addConfigurationChangeHandler(connection2, services) {
    connection2.onDidChangeConfiguration((change) => {
      if (change.settings) {
        services.workspace.ConfigurationProvider.updateConfiguration(change);
      }
    });
  }
  function addExecuteCommandHandler(connection2, services) {
    const commandHandler = services.lsp.ExecuteCommandHandler;
    if (commandHandler) {
      connection2.onExecuteCommand(async (params, token) => {
        var _a;
        try {
          return await commandHandler.executeCommand(params.command, (_a = params.arguments) !== null && _a !== void 0 ? _a : [], token);
        } catch (err) {
          return responseError(err);
        }
      });
    }
  }
  function addDocumentLinkHandler(connection2, services) {
    connection2.onDocumentLinks(createServerRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.DocumentLinkProvider) === null || _b === void 0 ? void 0 : _b.getDocumentLinks(document, params, cancelToken);
    }, services, DocumentState.Parsed));
  }
  function addSignatureHelpHandler(connection2, services) {
    connection2.onSignatureHelp(createServerRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.SignatureHelp) === null || _b === void 0 ? void 0 : _b.provideSignatureHelp(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addCodeLensHandler(connection2, services) {
    connection2.onCodeLens(createServerRequestHandler((services2, document, params, cancelToken) => {
      var _a, _b;
      return (_b = (_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.CodeLensProvider) === null || _b === void 0 ? void 0 : _b.provideCodeLens(document, params, cancelToken);
    }, services, DocumentState.IndexedReferences));
  }
  function addWorkspaceSymbolHandler(connection2, services) {
    var _a;
    const workspaceSymbolProvider = services.lsp.WorkspaceSymbolProvider;
    if (workspaceSymbolProvider) {
      const documentBuilder = services.workspace.DocumentBuilder;
      connection2.onWorkspaceSymbol(async (params, token) => {
        try {
          await documentBuilder.waitUntil(DocumentState.IndexedContent, token);
          return await workspaceSymbolProvider.getSymbols(params, token);
        } catch (err) {
          return responseError(err);
        }
      });
      const resolveWorkspaceSymbol = (_a = workspaceSymbolProvider.resolveSymbol) === null || _a === void 0 ? void 0 : _a.bind(workspaceSymbolProvider);
      if (resolveWorkspaceSymbol) {
        connection2.onWorkspaceSymbolResolve(async (workspaceSymbol, token) => {
          try {
            await documentBuilder.waitUntil(DocumentState.IndexedContent, token);
            return await resolveWorkspaceSymbol(workspaceSymbol, token);
          } catch (err) {
            return responseError(err);
          }
        });
      }
    }
  }
  function addCallHierarchyHandler(connection2, services) {
    connection2.languages.callHierarchy.onPrepare(createServerRequestHandler(async (services2, document, params, cancelToken) => {
      var _a;
      if ((_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.CallHierarchyProvider) {
        const result = await services2.lsp.CallHierarchyProvider.prepareCallHierarchy(document, params, cancelToken);
        return result !== null && result !== void 0 ? result : null;
      }
      return null;
    }, services, DocumentState.IndexedReferences));
    connection2.languages.callHierarchy.onIncomingCalls(createHierarchyRequestHandler(async (services2, params, cancelToken) => {
      var _a;
      if ((_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.CallHierarchyProvider) {
        const result = await services2.lsp.CallHierarchyProvider.incomingCalls(params, cancelToken);
        return result !== null && result !== void 0 ? result : null;
      }
      return null;
    }, services));
    connection2.languages.callHierarchy.onOutgoingCalls(createHierarchyRequestHandler(async (services2, params, cancelToken) => {
      var _a;
      if ((_a = services2.lsp) === null || _a === void 0 ? void 0 : _a.CallHierarchyProvider) {
        const result = await services2.lsp.CallHierarchyProvider.outgoingCalls(params, cancelToken);
        return result !== null && result !== void 0 ? result : null;
      }
      return null;
    }, services));
  }
  function addTypeHierarchyHandler(connection2, sharedServices) {
    if (!sharedServices.ServiceRegistry.all.some((services) => {
      var _a;
      return (_a = services.lsp) === null || _a === void 0 ? void 0 : _a.TypeHierarchyProvider;
    })) {
      return;
    }
    connection2.languages.typeHierarchy.onPrepare(createServerRequestHandler(async (services, document, params, cancelToken) => {
      var _a, _b;
      const result = await ((_b = (_a = services.lsp) === null || _a === void 0 ? void 0 : _a.TypeHierarchyProvider) === null || _b === void 0 ? void 0 : _b.prepareTypeHierarchy(document, params, cancelToken));
      return result !== null && result !== void 0 ? result : null;
    }, sharedServices, DocumentState.IndexedReferences));
    connection2.languages.typeHierarchy.onSupertypes(createHierarchyRequestHandler(async (services, params, cancelToken) => {
      var _a, _b;
      const result = await ((_b = (_a = services.lsp) === null || _a === void 0 ? void 0 : _a.TypeHierarchyProvider) === null || _b === void 0 ? void 0 : _b.supertypes(params, cancelToken));
      return result !== null && result !== void 0 ? result : null;
    }, sharedServices));
    connection2.languages.typeHierarchy.onSubtypes(createHierarchyRequestHandler(async (services, params, cancelToken) => {
      var _a, _b;
      const result = await ((_b = (_a = services.lsp) === null || _a === void 0 ? void 0 : _a.TypeHierarchyProvider) === null || _b === void 0 ? void 0 : _b.subtypes(params, cancelToken));
      return result !== null && result !== void 0 ? result : null;
    }, sharedServices));
  }
  function createHierarchyRequestHandler(serviceCall, sharedServices) {
    const serviceRegistry = sharedServices.ServiceRegistry;
    return async (params, cancelToken) => {
      const uri = URI2.parse(params.item.uri);
      const cancellationError = await waitUntilPhase(sharedServices, cancelToken, uri, DocumentState.IndexedReferences);
      if (cancellationError) {
        return cancellationError;
      }
      const language = serviceRegistry.getServices(uri);
      if (!language) {
        const message = `Could not find service instance for uri: '${uri.toString()}'`;
        console.error(message);
        throw new Error(message);
      }
      try {
        return await serviceCall(language, params, cancelToken);
      } catch (err) {
        return responseError(err);
      }
    };
  }
  function createServerRequestHandler(serviceCall, sharedServices, targetState) {
    const documents = sharedServices.workspace.LangiumDocuments;
    const serviceRegistry = sharedServices.ServiceRegistry;
    return async (params, cancelToken) => {
      const uri = URI2.parse(params.textDocument.uri);
      const cancellationError = await waitUntilPhase(sharedServices, cancelToken, uri, targetState);
      if (cancellationError) {
        return cancellationError;
      }
      const language = serviceRegistry.getServices(uri);
      if (!language) {
        const errorText = `Could not find service instance for uri: '${uri}'`;
        console.error(errorText);
        throw new Error(errorText);
      }
      const document = await documents.getOrCreateDocument(uri);
      try {
        return await serviceCall(language, document, params, cancelToken);
      } catch (err) {
        return responseError(err);
      }
    };
  }
  function createRequestHandler(serviceCall, sharedServices, targetState) {
    const documents = sharedServices.workspace.LangiumDocuments;
    const serviceRegistry = sharedServices.ServiceRegistry;
    return async (params, cancelToken) => {
      const uri = URI2.parse(params.textDocument.uri);
      const cancellationError = await waitUntilPhase(sharedServices, cancelToken, uri, targetState);
      if (cancellationError) {
        return cancellationError;
      }
      const language = serviceRegistry.getServices(uri);
      if (!language) {
        console.error(`Could not find service instance for uri: '${uri.toString()}'`);
        return null;
      }
      const document = documents.getDocument(uri);
      if (!document) {
        return null;
      }
      try {
        return await serviceCall(language, document, params, cancelToken);
      } catch (err) {
        return responseError(err);
      }
    };
  }
  async function waitUntilPhase(services, cancelToken, uri, targetState) {
    if (targetState !== void 0) {
      const documentBuilder = services.workspace.DocumentBuilder;
      try {
        await documentBuilder.waitUntil(targetState, uri, cancelToken);
      } catch (err) {
        return responseError(err);
      }
    }
    return void 0;
  }
  function responseError(err) {
    if (isOperationCancelled(err)) {
      return new import_vscode_languageserver_protocol.ResponseError(import_vscode_languageserver_protocol.LSPErrorCodes.RequestCancelled, "The request has been cancelled.");
    }
    if (err instanceof import_vscode_languageserver_protocol.ResponseError) {
      return err;
    }
    throw err;
  }

  // ../node_modules/langium/lib/lsp/node-kind-provider.js
  var import_vscode_languageserver8 = __toESM(require_main3(), 1);
  var DefaultNodeKindProvider = class {
    getSymbolKind() {
      return import_vscode_languageserver8.SymbolKind.Field;
    }
    getCompletionItemKind() {
      return import_vscode_languageserver8.CompletionItemKind.Reference;
    }
  };

  // ../node_modules/langium/lib/lsp/references-provider.js
  var import_vscode_languageserver9 = __toESM(require_main3(), 1);
  var DefaultReferencesProvider = class {
    constructor(services) {
      this.nameProvider = services.references.NameProvider;
      this.references = services.references.References;
      this.grammarConfig = services.parser.GrammarConfig;
    }
    findReferences(document, params) {
      const rootNode = document.parseResult.value.$cstNode;
      if (!rootNode) {
        return [];
      }
      const selectedNode = findDeclarationNodeAtOffset(rootNode, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
      if (!selectedNode) {
        return [];
      }
      return this.getReferences(selectedNode, params, document);
    }
    getReferences(selectedNode, params, _document) {
      const locations = [];
      const targetAstNode = this.references.findDeclaration(selectedNode);
      if (targetAstNode) {
        const options = { includeDeclaration: params.context.includeDeclaration };
        this.references.findReferences(targetAstNode, options).forEach((reference) => {
          locations.push(import_vscode_languageserver9.Location.create(reference.sourceUri.toString(), reference.segment.range));
        });
      }
      return locations;
    }
  };

  // ../node_modules/langium/lib/lsp/rename-provider.js
  init_main();
  var DefaultRenameProvider = class {
    constructor(services) {
      this.references = services.references.References;
      this.nameProvider = services.references.NameProvider;
      this.grammarConfig = services.parser.GrammarConfig;
    }
    async rename(document, params) {
      const changes = {};
      const rootNode = document.parseResult.value.$cstNode;
      if (!rootNode)
        return void 0;
      const offset = document.textDocument.offsetAt(params.position);
      const leafNode = findDeclarationNodeAtOffset(rootNode, offset, this.grammarConfig.nameRegexp);
      if (!leafNode)
        return void 0;
      const targetNode = this.references.findDeclaration(leafNode);
      if (!targetNode)
        return void 0;
      const options = { onlyLocal: false, includeDeclaration: true };
      const references = this.references.findReferences(targetNode, options);
      references.forEach((ref) => {
        const change = TextEdit.replace(ref.segment.range, params.newName);
        const uri = ref.sourceUri.toString();
        if (changes[uri]) {
          changes[uri].push(change);
        } else {
          changes[uri] = [change];
        }
      });
      return { changes };
    }
    prepareRename(document, params) {
      return this.renameNodeRange(document, params.position);
    }
    renameNodeRange(doc, position) {
      const rootNode = doc.parseResult.value.$cstNode;
      const offset = doc.textDocument.offsetAt(position);
      if (rootNode && offset) {
        const leafNode = findDeclarationNodeAtOffset(rootNode, offset, this.grammarConfig.nameRegexp);
        if (!leafNode) {
          return void 0;
        }
        const isCrossRef = this.references.findDeclaration(leafNode);
        if (isCrossRef || this.isNameNode(leafNode)) {
          return leafNode.range;
        }
      }
      return void 0;
    }
    isNameNode(leafNode) {
      return (leafNode === null || leafNode === void 0 ? void 0 : leafNode.astNode) && isNamed(leafNode.astNode) && leafNode === this.nameProvider.getNameNode(leafNode.astNode);
    }
  };

  // ../node_modules/langium/lib/lsp/workspace-symbol-provider.js
  var DefaultWorkspaceSymbolProvider = class {
    constructor(services) {
      this.indexManager = services.workspace.IndexManager;
      this.nodeKindProvider = services.lsp.NodeKindProvider;
      this.fuzzyMatcher = services.lsp.FuzzyMatcher;
    }
    async getSymbols(params, cancelToken = cancellation_exports.CancellationToken.None) {
      const workspaceSymbols = [];
      const query = params.query.toLowerCase();
      for (const description of this.indexManager.allElements()) {
        await interruptAndCheck(cancelToken);
        if (this.fuzzyMatcher.match(query, description.name)) {
          const symbol = this.getWorkspaceSymbol(description);
          if (symbol) {
            workspaceSymbols.push(symbol);
          }
        }
      }
      return workspaceSymbols;
    }
    getWorkspaceSymbol(astDescription) {
      const nameSegment = astDescription.nameSegment;
      if (nameSegment) {
        return {
          kind: this.nodeKindProvider.getSymbolKind(astDescription),
          name: astDescription.name,
          location: {
            range: nameSegment.range,
            uri: astDescription.documentUri.toString()
          }
        };
      } else {
        return void 0;
      }
    }
  };

  // ../node_modules/langium/lib/lsp/default-lsp-module.js
  function createDefaultModule(context) {
    return Module.merge(createDefaultCoreModule(context), createDefaultLSPModule(context));
  }
  function createDefaultLSPModule(context) {
    return {
      lsp: {
        CompletionProvider: (services) => new DefaultCompletionProvider(services),
        DocumentSymbolProvider: (services) => new DefaultDocumentSymbolProvider(services),
        HoverProvider: (services) => new MultilineCommentHoverProvider(services),
        FoldingRangeProvider: (services) => new DefaultFoldingRangeProvider(services),
        ReferencesProvider: (services) => new DefaultReferencesProvider(services),
        DefinitionProvider: (services) => new DefaultDefinitionProvider(services),
        DocumentHighlightProvider: (services) => new DefaultDocumentHighlightProvider(services),
        RenameProvider: (services) => new DefaultRenameProvider(services)
      },
      shared: () => context.shared
    };
  }
  function createDefaultSharedModule(context) {
    return Module.merge(createDefaultSharedCoreModule(context), createDefaultSharedLSPModule(context));
  }
  function createDefaultSharedLSPModule(context) {
    return {
      lsp: {
        Connection: () => context.connection,
        LanguageServer: (services) => new DefaultLanguageServer(services),
        DocumentUpdateHandler: (services) => new DefaultDocumentUpdateHandler(services),
        WorkspaceSymbolProvider: (services) => new DefaultWorkspaceSymbolProvider(services),
        NodeKindProvider: () => new DefaultNodeKindProvider(),
        FuzzyMatcher: () => new DefaultFuzzyMatcher()
      },
      workspace: {
        TextDocuments: () => new import_vscode_languageserver10.TextDocuments(TextDocument2)
      }
    };
  }

  // ../node_modules/langium/lib/lsp/formatter.js
  var Formatting;
  (function(Formatting2) {
    function fit(...formattings) {
      return {
        options: {},
        moves: formattings.flatMap((e) => e.moves).sort(compareMoves)
      };
    }
    Formatting2.fit = fit;
    function noSpace(options) {
      return spaces(0, options);
    }
    Formatting2.noSpace = noSpace;
    function oneSpace(options) {
      return spaces(1, options);
    }
    Formatting2.oneSpace = oneSpace;
    function spaces(count, options) {
      return {
        options: options !== null && options !== void 0 ? options : {},
        moves: [{
          characters: count
        }]
      };
    }
    Formatting2.spaces = spaces;
    function newLine(options) {
      return newLines(1, options);
    }
    Formatting2.newLine = newLine;
    function newLines(count, options) {
      return {
        options: options !== null && options !== void 0 ? options : {},
        moves: [{
          lines: count
        }]
      };
    }
    Formatting2.newLines = newLines;
    function indent(options) {
      return {
        options: options !== null && options !== void 0 ? options : {},
        moves: [{
          tabs: 1,
          lines: 1
        }]
      };
    }
    Formatting2.indent = indent;
    function noIndent(options) {
      return {
        options: options !== null && options !== void 0 ? options : {},
        moves: [{
          tabs: 0
        }]
      };
    }
    Formatting2.noIndent = noIndent;
    function compareMoves(a2, b) {
      var _a, _b, _c, _d, _e, _f;
      const aLines = (_a = a2.lines) !== null && _a !== void 0 ? _a : 0;
      const bLines = (_b = b.lines) !== null && _b !== void 0 ? _b : 0;
      const aTabs = (_c = a2.tabs) !== null && _c !== void 0 ? _c : 0;
      const bTabs = (_d = b.tabs) !== null && _d !== void 0 ? _d : 0;
      const aSpaces = (_e = a2.characters) !== null && _e !== void 0 ? _e : 0;
      const bSpaces = (_f = b.characters) !== null && _f !== void 0 ? _f : 0;
      if (aLines < bLines) {
        return -1;
      } else if (aLines > bLines) {
        return 1;
      } else if (aTabs < bTabs) {
        return -1;
      } else if (aTabs > bTabs) {
        return 1;
      } else if (aSpaces < bSpaces) {
        return -1;
      } else if (aSpaces > bSpaces) {
        return 1;
      } else {
        return 0;
      }
    }
  })(Formatting || (Formatting = {}));

  // ../node_modules/langium/lib/lsp/type-hierarchy-provider.js
  var import_vscode_languageserver11 = __toESM(require_main3(), 1);

  // assets/scripts/sql/language-server.ts
  var import_browser = __toESM(require_browser5(), 1);

  // ../node_modules/langium-sql/lib/generated/ast.js
  var ColumnNameSource = "ColumnNameSource";
  var DataTypeArgument = "DataTypeArgument";
  var Definition = "Definition";
  function isDefinition(item) {
    return reflection2.isInstance(item, Definition);
  }
  var DefinitionRule = "DefinitionRule";
  var Expression = "Expression";
  function isExpression(item) {
    return reflection2.isInstance(item, Expression);
  }
  var FrameBetween = "FrameBetween";
  var FrameExtent = "FrameExtent";
  var FrameRange = "FrameRange";
  var ReferenceDefinition = "ReferenceDefinition";
  var SelectElement = "SelectElement";
  var SelectTableExpression = "SelectTableExpression";
  var SourceItem = "SourceItem";
  var Statement = "Statement";
  var TableContentDefinition = "TableContentDefinition";
  var TableLike = "TableLike";
  function isTableLike(item) {
    return reflection2.isInstance(item, TableLike);
  }
  var TableVariableSource = "TableVariableSource";
  var Type2 = "Type";
  function isType2(item) {
    return reflection2.isInstance(item, Type2);
  }
  var AllStar = "AllStar";
  function isAllStar(item) {
    return reflection2.isInstance(item, AllStar);
  }
  var AllTable = "AllTable";
  function isAllTable(item) {
    return reflection2.isInstance(item, AllTable);
  }
  var BetweenExpression = "BetweenExpression";
  function isBetweenExpression(item) {
    return reflection2.isInstance(item, BetweenExpression);
  }
  var BinaryExpression = "BinaryExpression";
  function isBinaryExpression(item) {
    return reflection2.isInstance(item, BinaryExpression);
  }
  var BinaryTableExpression = "BinaryTableExpression";
  function isBinaryTableExpression(item) {
    return reflection2.isInstance(item, BinaryTableExpression);
  }
  var BooleanLiteral2 = "BooleanLiteral";
  function isBooleanLiteral2(item) {
    return reflection2.isInstance(item, BooleanLiteral2);
  }
  var CastExpression = "CastExpression";
  function isCastExpression(item) {
    return reflection2.isInstance(item, CastExpression);
  }
  var CatalogDefinition = "CatalogDefinition";
  function isCatalogDefinition(item) {
    return reflection2.isInstance(item, CatalogDefinition);
  }
  var ColumnDefinition = "ColumnDefinition";
  function isColumnDefinition(item) {
    return reflection2.isInstance(item, ColumnDefinition);
  }
  var ColumnNameExpression = "ColumnNameExpression";
  function isColumnNameExpression(item) {
    return reflection2.isInstance(item, ColumnNameExpression);
  }
  var CommonTableExpression = "CommonTableExpression";
  function isCommonTableExpression(item) {
    return reflection2.isInstance(item, CommonTableExpression);
  }
  var ConstraintDefinition = "ConstraintDefinition";
  function isConstraintDefinition(item) {
    return reflection2.isInstance(item, ConstraintDefinition);
  }
  var CteColumnName = "CteColumnName";
  function isCteColumnName(item) {
    return reflection2.isInstance(item, CteColumnName);
  }
  var DataType = "DataType";
  function isDataType2(item) {
    return reflection2.isInstance(item, DataType);
  }
  var ExpressionQuery = "ExpressionQuery";
  function isExpressionQuery(item) {
    return reflection2.isInstance(item, ExpressionQuery);
  }
  var FunctionCall = "FunctionCall";
  function isFunctionCall(item) {
    return reflection2.isInstance(item, FunctionCall);
  }
  var FunctionDefinition = "FunctionDefinition";
  function isFunctionDefinition(item) {
    return reflection2.isInstance(item, FunctionDefinition);
  }
  var GlobalReference = "GlobalReference";
  function isGlobalReference(item) {
    return reflection2.isInstance(item, GlobalReference);
  }
  var HexStringLiteral = "HexStringLiteral";
  function isHexStringLiteral(item) {
    return reflection2.isInstance(item, HexStringLiteral);
  }
  var IdentifierAsStringLiteral = "IdentifierAsStringLiteral";
  function isIdentifierAsStringLiteral(item) {
    return reflection2.isInstance(item, IdentifierAsStringLiteral);
  }
  var IndexDefinition = "IndexDefinition";
  function isIndexDefinition(item) {
    return reflection2.isInstance(item, IndexDefinition);
  }
  var KeyDefinition = "KeyDefinition";
  function isKeyDefinition(item) {
    return reflection2.isInstance(item, KeyDefinition);
  }
  var NegatableExpression = "NegatableExpression";
  function isNegatableExpression(item) {
    return reflection2.isInstance(item, NegatableExpression);
  }
  var NullLiteral = "NullLiteral";
  function isNullLiteral(item) {
    return reflection2.isInstance(item, NullLiteral);
  }
  var NumberLiteral2 = "NumberLiteral";
  function isNumberLiteral2(item) {
    return reflection2.isInstance(item, NumberLiteral2);
  }
  var OverClause = "OverClause";
  function isOverClause(item) {
    return reflection2.isInstance(item, OverClause);
  }
  var ParenthesesSelectTableExpression = "ParenthesesSelectTableExpression";
  function isParenthesesSelectTableExpression(item) {
    return reflection2.isInstance(item, ParenthesesSelectTableExpression);
  }
  var ParenthesisOrListExpression = "ParenthesisOrListExpression";
  function isParenthesisOrListExpression(item) {
    return reflection2.isInstance(item, ParenthesisOrListExpression);
  }
  var PrimaryKeyDefinition = "PrimaryKeyDefinition";
  function isPrimaryKeyDefinition(item) {
    return reflection2.isInstance(item, PrimaryKeyDefinition);
  }
  var RootLevelSelectStatement = "RootLevelSelectStatement";
  var SchemaDefinition = "SchemaDefinition";
  function isSchemaDefinition(item) {
    return reflection2.isInstance(item, SchemaDefinition);
  }
  var SimpleSelectStatement = "SimpleSelectStatement";
  function isSimpleSelectStatement(item) {
    return reflection2.isInstance(item, SimpleSelectStatement);
  }
  var SimpleSelectTableExpression = "SimpleSelectTableExpression";
  function isSimpleSelectTableExpression(item) {
    return reflection2.isInstance(item, SimpleSelectTableExpression);
  }
  var SqlFile = "SqlFile";
  function isSqlFile(item) {
    return reflection2.isInstance(item, SqlFile);
  }
  var StringLiteral2 = "StringLiteral";
  function isStringLiteral2(item) {
    return reflection2.isInstance(item, StringLiteral2);
  }
  var SubQueryExpression = "SubQueryExpression";
  function isSubQueryExpression(item) {
    return reflection2.isInstance(item, SubQueryExpression);
  }
  var SubQuerySourceItem = "SubQuerySourceItem";
  function isSubQuerySourceItem(item) {
    return reflection2.isInstance(item, SubQuerySourceItem);
  }
  var TableDefinition = "TableDefinition";
  function isTableDefinition(item) {
    return reflection2.isInstance(item, TableDefinition);
  }
  var TableRelatedColumnExpression = "TableRelatedColumnExpression";
  function isTableRelatedColumnExpression(item) {
    return reflection2.isInstance(item, TableRelatedColumnExpression);
  }
  var TableSourceItem = "TableSourceItem";
  function isTableSourceItem(item) {
    return reflection2.isInstance(item, TableSourceItem);
  }
  var UnaryExpression = "UnaryExpression";
  function isUnaryExpression(item) {
    return reflection2.isInstance(item, UnaryExpression);
  }
  var WindowSpec = "WindowSpec";
  function isWindowSpec(item) {
    return reflection2.isInstance(item, WindowSpec);
  }
  var WithClause = "WithClause";
  function isWithClause(item) {
    return reflection2.isInstance(item, WithClause);
  }
  var FrameClause = "FrameClause";
  var OrderByClause = "OrderByClause";
  var PartitionClause = "PartitionClause";
  var SqlAstReflection = class extends AbstractAstReflection {
    getAllTypes() {
      return ["AllStar", "AllTable", "BetweenExpression", "BinaryExpression", "BinaryTableExpression", "BooleanLiteral", "CastExpression", "CatalogDefinition", "ColumnDefinition", "ColumnNameExpression", "ColumnNameSource", "CommonTableExpression", "ConstraintDefinition", "CteColumnName", "DataType", "DataTypeArgument", "Definition", "DefinitionRule", "Expression", "ExpressionQuery", "FetchFirstClause", "FormalParameterDefinition", "FrameBetween", "FrameClause", "FrameExtent", "FrameRange", "FromClause", "FunctionCall", "FunctionDefinition", "GlobalReference", "GroupByClause", "HavingClause", "HexStringLiteral", "IdentifierAsStringLiteral", "IndexDefinition", "JoinPart", "KeyDefinition", "LimitClause", "NegatableExpression", "NullLiteral", "NumberLiteral", "OrderByClause", "OrderBySpec", "OverClause", "ParenthesesSelectTableExpression", "ParenthesisOrListExpression", "PartitionClause", "PrimaryKeyDefinition", "ReferenceDefinition", "RootLevelSelectStatement", "SchemaDefinition", "SelectElement", "SelectElements", "SelectTableExpression", "SetOperator", "SimpleSelectStatement", "SimpleSelectTableExpression", "SourceItem", "SqlFile", "Statement", "StringLiteral", "SubQueryExpression", "SubQuerySourceItem", "TableContentDefinition", "TableDefinition", "TableLike", "TableRelatedColumnExpression", "TableSource", "TableSourceItem", "TableSources", "TableVariableSource", "TopClause", "Type", "UnaryExpression", "WhereClause", "WindowSpec", "WithClause"];
    }
    computeIsSubtype(subtype, supertype) {
      switch (subtype) {
        case AllStar:
        case AllTable: {
          return this.isSubtype(SelectElement, supertype);
        }
        case BetweenExpression:
        case BinaryExpression:
        case BooleanLiteral2:
        case CastExpression:
        case ColumnNameExpression:
        case FunctionCall:
        case HexStringLiteral:
        case IdentifierAsStringLiteral:
        case NegatableExpression:
        case NullLiteral:
        case ParenthesisOrListExpression:
        case SubQueryExpression:
        case TableRelatedColumnExpression:
        case UnaryExpression: {
          return this.isSubtype(Expression, supertype);
        }
        case BinaryTableExpression:
        case ParenthesesSelectTableExpression:
        case SimpleSelectTableExpression: {
          return this.isSubtype(SelectTableExpression, supertype);
        }
        case CatalogDefinition: {
          return this.isSubtype(Definition, supertype) || this.isSubtype(DefinitionRule, supertype);
        }
        case ColumnDefinition: {
          return this.isSubtype(ColumnNameSource, supertype) || this.isSubtype(TableContentDefinition, supertype);
        }
        case CommonTableExpression: {
          return this.isSubtype(TableLike, supertype);
        }
        case ConstraintDefinition:
        case IndexDefinition:
        case KeyDefinition:
        case PrimaryKeyDefinition: {
          return this.isSubtype(TableContentDefinition, supertype);
        }
        case DataType: {
          return this.isSubtype(Type2, supertype);
        }
        case DefinitionRule:
        case RootLevelSelectStatement: {
          return this.isSubtype(Statement, supertype);
        }
        case Expression: {
          return this.isSubtype(FrameRange, supertype);
        }
        case ExpressionQuery: {
          return this.isSubtype(ColumnNameSource, supertype) || this.isSubtype(SelectElement, supertype);
        }
        case FrameBetween: {
          return this.isSubtype(FrameExtent, supertype);
        }
        case FrameClause:
        case OrderByClause:
        case PartitionClause: {
          return this.isSubtype(WindowSpec, supertype);
        }
        case FrameRange: {
          return this.isSubtype(FrameBetween, supertype) || this.isSubtype(FrameExtent, supertype);
        }
        case FunctionDefinition:
        case SchemaDefinition: {
          return this.isSubtype(Definition, supertype) || this.isSubtype(DefinitionRule, supertype) || this.isSubtype(ReferenceDefinition, supertype);
        }
        case NumberLiteral2:
        case StringLiteral2: {
          return this.isSubtype(DataTypeArgument, supertype) || this.isSubtype(Expression, supertype);
        }
        case SubQuerySourceItem:
        case TableSourceItem: {
          return this.isSubtype(SourceItem, supertype) || this.isSubtype(TableVariableSource, supertype);
        }
        case TableDefinition: {
          return this.isSubtype(DefinitionRule, supertype) || this.isSubtype(ReferenceDefinition, supertype) || this.isSubtype(TableLike, supertype);
        }
        case TableLike: {
          return this.isSubtype(Definition, supertype);
        }
        default: {
          return false;
        }
      }
    }
    getReferenceType(refInfo) {
      const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
      switch (referenceId) {
        case "AllTable:variableName": {
          return TableVariableSource;
        }
        case "ColumnNameExpression:columnName":
        case "TableRelatedColumnExpression:columnName": {
          return ColumnNameSource;
        }
        case "ConstraintDefinition:from":
        case "ConstraintDefinition:to":
        case "IndexDefinition:indexes":
        case "KeyDefinition:keys":
        case "PrimaryKeyDefinition:primaryKeys": {
          return ColumnDefinition;
        }
        case "GlobalReference:element": {
          return Definition;
        }
        case "OverClause:windowName": {
          return WindowSpec;
        }
        case "TableRelatedColumnExpression:variableName": {
          return SourceItem;
        }
        default: {
          throw new Error(`${referenceId} is not a valid reference id.`);
        }
      }
    }
    getTypeMetaData(type) {
      switch (type) {
        case "AllTable": {
          return {
            name: "AllTable",
            properties: [
              { name: "variableName" }
            ]
          };
        }
        case "BetweenExpression": {
          return {
            name: "BetweenExpression",
            properties: [
              { name: "left" },
              { name: "negated", defaultValue: false },
              { name: "right" },
              { name: "subExpr" }
            ]
          };
        }
        case "BinaryExpression": {
          return {
            name: "BinaryExpression",
            properties: [
              { name: "left" },
              { name: "operator" },
              { name: "right" }
            ]
          };
        }
        case "BinaryTableExpression": {
          return {
            name: "BinaryTableExpression",
            properties: [
              { name: "left" },
              { name: "operator" },
              { name: "right" }
            ]
          };
        }
        case "BooleanLiteral": {
          return {
            name: "BooleanLiteral",
            properties: [
              { name: "value", defaultValue: false }
            ]
          };
        }
        case "CastExpression": {
          return {
            name: "CastExpression",
            properties: [
              { name: "expr" },
              { name: "type" }
            ]
          };
        }
        case "CatalogDefinition": {
          return {
            name: "CatalogDefinition",
            properties: [
              { name: "catalogSyntax", defaultValue: false },
              { name: "name" }
            ]
          };
        }
        case "ColumnDefinition": {
          return {
            name: "ColumnDefinition",
            properties: [
              { name: "dataType" },
              { name: "name" },
              { name: "negated", defaultValue: false },
              { name: "null", defaultValue: false }
            ]
          };
        }
        case "ColumnNameExpression": {
          return {
            name: "ColumnNameExpression",
            properties: [
              { name: "columnName" }
            ]
          };
        }
        case "CommonTableExpression": {
          return {
            name: "CommonTableExpression",
            properties: [
              { name: "columnNames", defaultValue: [] },
              { name: "name" },
              { name: "statement" }
            ]
          };
        }
        case "ConstraintDefinition": {
          return {
            name: "ConstraintDefinition",
            properties: [
              { name: "cascadeDeletion", defaultValue: false },
              { name: "from" },
              { name: "name" },
              { name: "table" },
              { name: "to" }
            ]
          };
        }
        case "CteColumnName": {
          return {
            name: "CteColumnName",
            properties: [
              { name: "name" }
            ]
          };
        }
        case "DataType": {
          return {
            name: "DataType",
            properties: [
              { name: "arguments", defaultValue: [] },
              { name: "dataTypeNames" }
            ]
          };
        }
        case "ExpressionQuery": {
          return {
            name: "ExpressionQuery",
            properties: [
              { name: "expr" },
              { name: "name" }
            ]
          };
        }
        case "FetchFirstClause": {
          return {
            name: "FetchFirstClause",
            properties: [
              { name: "first", defaultValue: false },
              { name: "limit" },
              { name: "offset" },
              { name: "offsetRows", defaultValue: false },
              { name: "only", defaultValue: false }
            ]
          };
        }
        case "FormalParameterDefinition": {
          return {
            name: "FormalParameterDefinition",
            properties: [
              { name: "dataType" },
              { name: "name" }
            ]
          };
        }
        case "FromClause": {
          return {
            name: "FromClause",
            properties: [
              { name: "sources" }
            ]
          };
        }
        case "FunctionCall": {
          return {
            name: "FunctionCall",
            properties: [
              { name: "function" },
              { name: "overClause" },
              { name: "params" }
            ]
          };
        }
        case "FunctionDefinition": {
          return {
            name: "FunctionDefinition",
            properties: [
              { name: "params", defaultValue: [] },
              { name: "reference" },
              { name: "replace", defaultValue: false },
              { name: "returnType" }
            ]
          };
        }
        case "GlobalReference": {
          return {
            name: "GlobalReference",
            properties: [
              { name: "element" },
              { name: "previous" }
            ]
          };
        }
        case "GroupByClause": {
          return {
            name: "GroupByClause",
            properties: [
              { name: "specs", defaultValue: [] }
            ]
          };
        }
        case "HavingClause": {
          return {
            name: "HavingClause",
            properties: [
              { name: "groupCondition" }
            ]
          };
        }
        case "HexStringLiteral": {
          return {
            name: "HexStringLiteral",
            properties: [
              { name: "value" }
            ]
          };
        }
        case "IdentifierAsStringLiteral": {
          return {
            name: "IdentifierAsStringLiteral",
            properties: [
              { name: "value" }
            ]
          };
        }
        case "IndexDefinition": {
          return {
            name: "IndexDefinition",
            properties: [
              { name: "indexes", defaultValue: [] }
            ]
          };
        }
        case "JoinPart": {
          return {
            name: "JoinPart",
            properties: [
              { name: "joinOn" },
              { name: "leftJoin", defaultValue: false },
              { name: "nextItem" },
              { name: "rightJoin", defaultValue: false },
              { name: "usingOn" }
            ]
          };
        }
        case "KeyDefinition": {
          return {
            name: "KeyDefinition",
            properties: [
              { name: "keys", defaultValue: [] },
              { name: "name" },
              { name: "unique", defaultValue: false }
            ]
          };
        }
        case "LimitClause": {
          return {
            name: "LimitClause",
            properties: [
              { name: "limit" },
              { name: "offset" }
            ]
          };
        }
        case "NegatableExpression": {
          return {
            name: "NegatableExpression",
            properties: [
              { name: "left" },
              { name: "negated", defaultValue: false },
              { name: "operator" },
              { name: "right" }
            ]
          };
        }
        case "NumberLiteral": {
          return {
            name: "NumberLiteral",
            properties: [
              { name: "value" }
            ]
          };
        }
        case "OrderBySpec": {
          return {
            name: "OrderBySpec",
            properties: [
              { name: "scalar" }
            ]
          };
        }
        case "OverClause": {
          return {
            name: "OverClause",
            properties: [
              { name: "spec" },
              { name: "windowName" }
            ]
          };
        }
        case "ParenthesesSelectTableExpression": {
          return {
            name: "ParenthesesSelectTableExpression",
            properties: [
              { name: "value" }
            ]
          };
        }
        case "ParenthesisOrListExpression": {
          return {
            name: "ParenthesisOrListExpression",
            properties: [
              { name: "items", defaultValue: [] }
            ]
          };
        }
        case "PrimaryKeyDefinition": {
          return {
            name: "PrimaryKeyDefinition",
            properties: [
              { name: "primaryKeys", defaultValue: [] }
            ]
          };
        }
        case "RootLevelSelectStatement": {
          return {
            name: "RootLevelSelectStatement",
            properties: [
              { name: "select" },
              { name: "with" }
            ]
          };
        }
        case "SchemaDefinition": {
          return {
            name: "SchemaDefinition",
            properties: [
              { name: "reference" }
            ]
          };
        }
        case "SelectElements": {
          return {
            name: "SelectElements",
            properties: [
              { name: "distinct", defaultValue: false },
              { name: "elements", defaultValue: [] }
            ]
          };
        }
        case "SetOperator": {
          return {
            name: "SetOperator",
            properties: [
              { name: "distinct", defaultValue: false },
              { name: "operator" }
            ]
          };
        }
        case "SimpleSelectStatement": {
          return {
            name: "SimpleSelectStatement",
            properties: [
              { name: "fetchFirst" },
              { name: "from" },
              { name: "groupBy" },
              { name: "having" },
              { name: "limit" },
              { name: "orderBy" },
              { name: "select" },
              { name: "top" },
              { name: "where" }
            ]
          };
        }
        case "SimpleSelectTableExpression": {
          return {
            name: "SimpleSelectTableExpression",
            properties: [
              { name: "select" }
            ]
          };
        }
        case "SqlFile": {
          return {
            name: "SqlFile",
            properties: [
              { name: "statements", defaultValue: [] }
            ]
          };
        }
        case "StringLiteral": {
          return {
            name: "StringLiteral",
            properties: [
              { name: "value" }
            ]
          };
        }
        case "SubQueryExpression": {
          return {
            name: "SubQueryExpression",
            properties: [
              { name: "subQuery" }
            ]
          };
        }
        case "SubQuerySourceItem": {
          return {
            name: "SubQuerySourceItem",
            properties: [
              { name: "name" },
              { name: "subQuery" }
            ]
          };
        }
        case "TableDefinition": {
          return {
            name: "TableDefinition",
            properties: [
              { name: "columns", defaultValue: [] },
              { name: "reference" },
              { name: "trailingComma", defaultValue: false }
            ]
          };
        }
        case "TableRelatedColumnExpression": {
          return {
            name: "TableRelatedColumnExpression",
            properties: [
              { name: "columnName" },
              { name: "variableName" }
            ]
          };
        }
        case "TableSource": {
          return {
            name: "TableSource",
            properties: [
              { name: "item" },
              { name: "joins", defaultValue: [] }
            ]
          };
        }
        case "TableSourceItem": {
          return {
            name: "TableSourceItem",
            properties: [
              { name: "name" },
              { name: "table" }
            ]
          };
        }
        case "TableSources": {
          return {
            name: "TableSources",
            properties: [
              { name: "list", defaultValue: [] }
            ]
          };
        }
        case "TopClause": {
          return {
            name: "TopClause",
            properties: [
              { name: "percent", defaultValue: false },
              { name: "value" }
            ]
          };
        }
        case "UnaryExpression": {
          return {
            name: "UnaryExpression",
            properties: [
              { name: "operator" },
              { name: "value" }
            ]
          };
        }
        case "WhereClause": {
          return {
            name: "WhereClause",
            properties: [
              { name: "rowCondition" }
            ]
          };
        }
        case "WindowSpec": {
          return {
            name: "WindowSpec",
            properties: [
              { name: "name" }
            ]
          };
        }
        case "WithClause": {
          return {
            name: "WithClause",
            properties: [
              { name: "ctes", defaultValue: [] }
            ]
          };
        }
        case "FrameClause": {
          return {
            name: "FrameClause",
            properties: [
              { name: "extent" },
              { name: "name" },
              { name: "units" }
            ]
          };
        }
        case "OrderByClause": {
          return {
            name: "OrderByClause",
            properties: [
              { name: "name" },
              { name: "specs", defaultValue: [] }
            ]
          };
        }
        case "PartitionClause": {
          return {
            name: "PartitionClause",
            properties: [
              { name: "exprs", defaultValue: [] },
              { name: "name" }
            ]
          };
        }
        default: {
          return {
            name: type,
            properties: []
          };
        }
      }
    }
  };
  var reflection2 = new SqlAstReflection();

  // ../node_modules/langium-sql/lib/sql-data-types.js
  function toString3(dataType) {
    const name = `${dataType.names.join(" ")}`;
    if (dataType.arguments.length > 0) {
      const args = `(${dataType.arguments.map((arg) => `${arg.type}${arg.optional ? "?" : ""}`).join(", ")})`;
      return `${name}${args}`;
    }
    return name;
  }
  function isCompatibleWithDefinition(ast, required) {
    if (ast.dataTypeNames.length !== required.names.length) {
      return false;
    }
    for (let i = 0; i < ast.dataTypeNames.length; i++) {
      if (ast.dataTypeNames[i].toUpperCase() !== required.names[i].toUpperCase()) {
        return false;
      }
    }
    if (ast.arguments.length > required.arguments.length) {
      return false;
    }
    for (let i = 0; i < ast.arguments.length; i++) {
      const arg = ast.arguments[i];
      const requiredArg = required.arguments[i];
      if (isNumberLiteral2(arg)) {
        switch (requiredArg.type) {
          case "integer":
            if (!Number.isInteger(arg.value)) {
              return false;
            }
            break;
          case "real":
            break;
          case "size":
            if (!Number.isInteger(arg.value) || arg.value < 0) {
              return false;
            }
            break;
          default:
            return false;
        }
      }
      if (isStringLiteral2(arg) && requiredArg.type !== "string") {
        return false;
      }
    }
    for (let i = ast.arguments.length; i < required.arguments.length; i++) {
      if (!required.arguments[i].optional) {
        return false;
      }
    }
    return true;
  }
  function parseRequiredType(str) {
    const namesExpression = /^(\w+)(\s+(\w+))*\s*(\([^\)]+\))?$/;
    const namesMatch = str.match(namesExpression);
    if (!namesMatch) {
      throw new Error(`Invalid type string: ${str}`);
    }
    const names = [];
    for (let index = 1; index < namesMatch.length; index += 2) {
      const name = namesMatch[index];
      name && names.push(name);
    }
    const args = [];
    const argsString = namesMatch[namesMatch.length - 1];
    if (argsString) {
      const trimmedArgsString = argsString.substring(1, argsString.length - 1).split(",").map((s) => s.trim());
      for (const arg of trimmedArgsString) {
        const match = arg.match(/^(string|real|integer|size)(\?)?$/);
        if (match) {
          args.push({
            type: match[1],
            optional: match[2] === "?"
          });
        } else {
          throw new Error(`Invalid argument type: ${arg}`);
        }
      }
    }
    return {
      names,
      arguments: args
    };
  }
  var DialectTypes = class {
    constructor(types) {
      this.types = Object.entries(types).reduce((acc, [key, value]) => {
        acc[key] = value.map(parseRequiredType);
        return acc;
      }, {});
    }
    isStringDataType(dataType) {
      return this.types.strings.some((t) => isCompatibleWithDefinition(dataType, t));
    }
    isIntegerDataType(dataType) {
      return this.types.integers.some((t) => isCompatibleWithDefinition(dataType, t));
    }
    isRealDataType(dataType) {
      return this.types.reals.some((t) => isCompatibleWithDefinition(dataType, t));
    }
    isDateTimeDataType(dataType) {
      return this.types.dateTimes.some((t) => isCompatibleWithDefinition(dataType, t));
    }
    isBooleanDataType(dataType) {
      return this.types.booleans.some((t) => isCompatibleWithDefinition(dataType, t));
    }
    isBlobDataType(dataType) {
      return this.types.blobs.some((t) => isCompatibleWithDefinition(dataType, t));
    }
    isEnumDataType(dataType) {
      return this.types.enums.some((t) => isCompatibleWithDefinition(dataType, t));
    }
    allTypes() {
      return [
        ...this.types.strings,
        ...this.types.integers,
        ...this.types.reals,
        ...this.types.dateTimes,
        ...this.types.booleans,
        ...this.types.blobs,
        ...this.types.enums
      ];
    }
  };
  function typesExtend(a2, b) {
    return {
      strings: [...a2.strings, ...b.strings],
      integers: [...a2.integers, ...b.integers],
      reals: [...a2.reals, ...b.reals],
      dateTimes: [...a2.dateTimes, ...b.dateTimes],
      booleans: [...a2.booleans, ...b.booleans],
      blobs: [...a2.blobs, ...b.blobs],
      enums: [...a2.enums, ...b.enums]
    };
  }

  // ../node_modules/langium-sql/lib/sql-completion-provider.js
  var import_vscode_languageserver12 = __toESM(require_main10(), 1);

  // ../node_modules/langium-sql/lib/sql-type-utilities.js
  function getFromGlobalReference(reference, is) {
    var _a;
    const element = (_a = reference === null || reference === void 0 ? void 0 : reference.element) === null || _a === void 0 ? void 0 : _a.ref;
    if (element && is(element)) {
      return element;
    } else {
      return void 0;
    }
  }
  function getDefinitionType(element) {
    if (isCatalogDefinition(element)) {
      return DefinitionType.Catalog;
    } else if (isSchemaDefinition(element)) {
      return DefinitionType.Schema;
    } else {
      return DefinitionType.Table;
    }
  }
  function getDefinitionTypeName(element) {
    if (isCatalogDefinition(element)) {
      return "DATABASE";
    } else if (isSchemaDefinition(element)) {
      return "SCHEMA";
    } else if (isTableLike(element)) {
      return "TABLE";
    } else if (isFunctionDefinition(element)) {
      return "FUNCTION";
    } else {
      return "UNKNOWN";
    }
  }
  var DefinitionType;
  (function(DefinitionType2) {
    DefinitionType2[DefinitionType2["Catalog"] = 0] = "Catalog";
    DefinitionType2[DefinitionType2["Schema"] = 1] = "Schema";
    DefinitionType2[DefinitionType2["Table"] = 2] = "Table";
  })(DefinitionType = DefinitionType || (DefinitionType = {}));
  function getColumnsForSelectTableExpression(selectTableExpression, onlyAliases = false) {
    if (isBinaryTableExpression(selectTableExpression)) {
      const lhs = getColumnsForSelectTableExpression(selectTableExpression.left, onlyAliases);
      return lhs;
    } else if (isParenthesesSelectTableExpression(selectTableExpression)) {
      return getColumnsForSelectTableExpression(selectTableExpression.value);
    } else if (isSimpleSelectTableExpression(selectTableExpression)) {
      return getColumnsSimpleSelectStatement(selectTableExpression.select, onlyAliases);
    } else if (!selectTableExpression) {
      return [];
    } else {
      assertUnreachable(selectTableExpression);
    }
  }
  function getColumnsSimpleSelectStatement(simpleSelectStatement, onlyAliases) {
    if (!simpleSelectStatement || !simpleSelectStatement.select) {
      return [];
    }
    return simpleSelectStatement.select.elements.flatMap((e) => {
      var _a;
      if (isAllStar(e)) {
        if (onlyAliases) {
          return [];
        }
        const fromAllSources = getColumnCandidatesForSimpleSelectStatement(simpleSelectStatement);
        return fromAllSources.flatMap((t) => t);
      } else if (isAllTable(e)) {
        if (onlyAliases) {
          return [];
        }
        if (!simpleSelectStatement.from) {
          return [];
        }
        const ref = e.variableName.ref;
        if (isTableSourceItem(ref)) {
          const tableLike = getFromGlobalReference(ref.table, isTableLike);
          if (isTableDefinition(tableLike)) {
            const columns = (_a = tableLike.columns.filter(isColumnDefinition)) !== null && _a !== void 0 ? _a : [];
            return columns.map((c) => ({
              name: c.name,
              typedNode: c.dataType,
              node: c,
              isScopedByVariable: true
            }));
          } else if (isCommonTableExpression(tableLike)) {
            const columns = getColumnsForSelectTableExpression(tableLike.statement);
            if (tableLike.columnNames.length > 0) {
              return columns.map((c, i) => Object.assign(Object.assign({}, c), { name: tableLike.columnNames[i].name }));
            }
            return columns;
          } else if (tableLike) {
            assertUnreachable(tableLike);
          }
        } else if (isSubQuerySourceItem(ref)) {
          return getColumnsForSelectTableExpression(ref.subQuery);
        } else {
          assertUnreachable(ref);
        }
      } else if (isExpressionQuery(e)) {
        if (e.name) {
          return [{
            name: e.name,
            typedNode: e.expr,
            node: e,
            isScopedByVariable: false
          }];
        } else {
          if (onlyAliases) {
            return [];
          }
          const expr = e.expr;
          if (isTableRelatedColumnExpression(expr)) {
            return resolveColumnNameTypedNode(e, expr.columnName);
          } else if (isFunctionCall(expr)) {
            const functionLike = getFromGlobalReference(expr.function, isFunctionDefinition);
            if (functionLike) {
              const name = expr.function.element.$refText;
              return [{
                name,
                isScopedByVariable: false,
                node: e,
                typedNode: functionLike.returnType
              }];
            } else {
              return [];
            }
          } else if (isColumnNameExpression(expr)) {
            const fromAllSources = getColumnCandidatesForSimpleSelectStatement(simpleSelectStatement);
            const name = expr.columnName.$refText;
            const column = fromAllSources.find((s) => !s.isScopedByVariable && s.name === name);
            if (column) {
              return [column];
            } else {
              return resolveColumnNameTypedNode(expr, expr.columnName);
            }
          } else if (isSubQueryExpression(expr)) {
            const columns = getColumnsForSelectTableExpression(expr.subQuery);
            return [columns[0]];
          } else {
            return [{
              node: e,
              typedNode: e.expr,
              isScopedByVariable: false
            }];
          }
        }
      } else {
        assertUnreachable(e);
      }
      return [];
    });
  }
  function resolveColumnNameTypedNode(expression, columnName) {
    const ref = columnName.ref;
    let typed = expression;
    if (isExpressionQuery(ref)) {
      typed = ref.expr;
    } else if (isColumnDefinition(ref)) {
      typed = ref.dataType;
    }
    return [{
      name: ref === null || ref === void 0 ? void 0 : ref.name,
      isScopedByVariable: false,
      node: expression,
      typedNode: typed
    }];
  }
  function getColumnCandidatesForSelectTableExpression(selectTableExpression) {
    if (isBinaryTableExpression(selectTableExpression)) {
      const lhs = getColumnCandidatesForSelectTableExpression(selectTableExpression.left);
      return lhs;
    } else if (isParenthesesSelectTableExpression(selectTableExpression)) {
      return getColumnCandidatesForSelectTableExpression(selectTableExpression.value);
    } else if (isSimpleSelectTableExpression(selectTableExpression)) {
      return getColumnCandidatesForSimpleSelectStatement(selectTableExpression.select);
    } else if (!selectTableExpression) {
      return [];
    }
    {
      assertUnreachable(selectTableExpression);
    }
  }
  function getColumnCandidatesForSimpleSelectStatement(selectStatement) {
    var _a, _b;
    const selectElementColumns = getColumnsSimpleSelectStatement(selectStatement, true);
    const fromComputedColumns = (_b = (_a = selectStatement === null || selectStatement === void 0 ? void 0 : selectStatement.from) === null || _a === void 0 ? void 0 : _a.sources.list.flatMap(getColumnsForTableSource)) !== null && _b !== void 0 ? _b : [];
    return selectElementColumns.concat(fromComputedColumns);
  }
  function getColumnsForTableSource(source) {
    const items = [source.item].concat(source.joins.map((j) => j.nextItem));
    return items.flatMap((item) => {
      if (isTableSourceItem(item)) {
        const tableLike = getFromGlobalReference(item.table, isTableLike);
        if (isTableDefinition(tableLike)) {
          return tableLike.columns.filter(isColumnDefinition).map((column) => ({
            name: column.name,
            typedNode: column.dataType,
            node: column,
            isScopedByVariable: item.name != null
          }));
        } else if (isCommonTableExpression(tableLike)) {
          let columns = getColumnsForSelectTableExpression(tableLike.statement);
          if ((tableLike === null || tableLike === void 0 ? void 0 : tableLike.columnNames.length) > 0) {
            columns = columns.map((c, i) => {
              var _a;
              return Object.assign(Object.assign({}, c), { name: (_a = tableLike.columnNames[i]) === null || _a === void 0 ? void 0 : _a.name });
            });
          }
          return columns;
        }
        return [];
      } else if (isSubQuerySourceItem(item)) {
        return getColumnsForSelectTableExpression(item.subQuery);
      } else {
        assertUnreachable(item);
      }
    });
  }

  // ../node_modules/langium-sql/lib/sql-completion-provider.js
  var SqlCompletionProvider = class extends DefaultCompletionProvider {
    constructor(services) {
      super(services);
      this.completionOptions = {
        triggerCharacters: ["."]
      };
      this.dataTypes = services.dialect.dataTypes.allTypes();
    }
    getCompletion(document, params) {
      return super.getCompletion(document, params);
    }
    completionFor(context, next, acceptor) {
      var _a;
      if (isDataType2(context.node) && next.property === "dataTypeNames") {
        this.completeWithDataTypes(context, acceptor);
      } else if (isSimpleSelectStatement(context.node) && next.type === "SelectElements") {
        const columnDescriptors = getColumnCandidatesForSelectTableExpression(context.node.$container);
        for (const columnDescriptor of columnDescriptors) {
          const text = (_a = columnDescriptor.name) !== null && _a !== void 0 ? _a : isNamed(columnDescriptor.node) ? columnDescriptor.node.name : void 0;
          acceptor(context, {
            kind: import_vscode_languageserver12.CompletionItemKind.Field,
            label: text,
            insertText: text
          });
        }
      }
      return super.completionFor(context, next, acceptor);
    }
    completeWithDataTypes(context, acceptor) {
      for (const dataType of this.dataTypes) {
        acceptor(context, {
          label: toString3(dataType),
          kind: import_vscode_languageserver12.CompletionItemKind.Class,
          insertText: toString3(dataType)
        });
      }
    }
  };

  // ../node_modules/langium-sql/lib/sql-container-manager.js
  var SqlContainerManager = class {
    constructor(services) {
      this.children = new MultiMap();
      this.langiumDocuments = services.workspace.LangiumDocuments;
      services.workspace.DocumentBuilder.onBuildPhase(DocumentState.ComputedScopes, (_5, cancelToken) => this.rebuild(cancelToken));
    }
    getChildren(definition) {
      return this.children.get(definition);
    }
    putChild(definition, child) {
      this.children.add(definition, child);
    }
    async rebuild(cancelToken) {
      this.children.clear();
      const documents = this.langiumDocuments.all;
      const sink = {
        schemas: [],
        tables: [],
        functions: []
      };
      for (const document of documents) {
        const value = document.parseResult.value;
        if (isSqlFile(value)) {
          await this.collectDocument(value, sink, cancelToken);
        }
      }
      await this.collectElements(sink.schemas, cancelToken);
      await this.collectElements(sink.tables, cancelToken);
      await this.collectElements(sink.functions, cancelToken);
    }
    async collectElements(elements, cancelToken) {
      var _a;
      for (const element of elements) {
        await interruptAndCheck(cancelToken);
        const reference = element.reference;
        if (reference === null || reference === void 0 ? void 0 : reference.previous) {
          const previousElement = (_a = reference.previous.element) === null || _a === void 0 ? void 0 : _a.ref;
          if (previousElement) {
            this.putChild(previousElement, element);
          }
        }
      }
    }
    async collectDocument(file, sink, cancelToken) {
      for (const statement of file.statements) {
        await interruptAndCheck(cancelToken);
        if (isSchemaDefinition(statement)) {
          sink.schemas.push(statement);
        } else if (isTableDefinition(statement)) {
          sink.tables.push(statement);
        } else if (isFunctionDefinition(statement)) {
          sink.functions.push(statement);
        }
      }
    }
  };

  // ../node_modules/langium-sql/lib/sql-error-codes.js
  var SqlErrorFactory = class {
    static create(code, severity, messageGenerator, diagnosticGenerator) {
      const reporter = (node, props, accept) => {
        accept(severity, messageGenerator(props), ((node2) => {
          const info = diagnosticGenerator(node2);
          info.code = code;
          return info;
        })(node));
      };
      reporter.Code = code;
      return reporter;
    }
  };
  var ReportAs = {
    DuplicatedVariableName: SqlErrorFactory.create("SQL00001", "error", ({ name }) => `Duplicated variable name '${name}'.`, (node) => ({ node, property: "name" })),
    NumericValueIsNotInteger: SqlErrorFactory.create("SQL00002", "error", ({ value }) => `Value '${value}' is not an integer.`, (node) => ({ node, property: "value" })),
    BinaryOperatorNotDefinedForGivenExpressions: SqlErrorFactory.create("SQL00003", "error", ({ op, left, right }) => `Binary operator '${op}' is not defined for ('${left.discriminator}', '${right.discriminator}').`, (node) => ({ node, property: "operator" })),
    UnaryOperatorNotDefinedForGivenExpression: SqlErrorFactory.create("SQL00004", "error", ({ op, operand }) => `Unary operator '${op}' is not defined for '${operand.discriminator}'.`, (node) => ({ node, property: "operator" })),
    ExpressionMustReturnABoolean: SqlErrorFactory.create("SQL00005", "error", (operand) => `Expression must return a boolean, not a '${operand.discriminator}'.`, (node) => ({ node })),
    AllStarSelectionRequiresTableSources: SqlErrorFactory.create("SQL00006", "error", () => `All-star selection requires table sources (FROM is missing).`, (node) => ({ node })),
    TableDefinitionRequiresAtLeastOneColumn: SqlErrorFactory.create("SQL00007", "error", () => `Table definition requires at least one column.`, (node) => ({ node, property: "element" })),
    SubQueriesWithinSelectStatementsMustHaveExactlyOneColumn: SqlErrorFactory.create("SQL00008", "error", () => `Sub queries within select statements must have exactly one column.`, (node) => ({ node, property: "subQuery" })),
    CannotDeriveTypeOfExpression: SqlErrorFactory.create("SQL00009", "error", () => `Unable to derive the type of the expression.`, (node) => ({ node })),
    TableOperationUsesTablesWithDifferentColumnCounts: SqlErrorFactory.create("SQL00010", "error", () => `This operation uses tables with different amounts of columns, which is forbidden. Please add the missing columns.`, (node) => ({ node, property: "operator" })),
    TableOperationUsesTablesWithDifferentColumnTypes: SqlErrorFactory.create("SQL00011", "error", ({ columnIndex }) => `This operation uses tables with different columns types! Compare the columns at index ${columnIndex}. They are not convertable to each other.`, (node) => ({ node, property: "operator" })),
    IncorrectGlobalReferenceTarget: SqlErrorFactory.create("SQL00012", "error", ({ expected, received }) => `Expected definition of type '${expected}' but received '${received}'.`, (node) => ({ node, property: "element" })),
    UnknownDataType: SqlErrorFactory.create("SQL00013", "error", ({ dataType }) => `Unknown data type '${dataType.dataTypeNames.join(" ")}(${dataType.arguments.map((dt) => dt.value).join(", ")})'.`, (node) => ({ node }))
  };

  // ../node_modules/langium-sql/lib/dialects/sql-server/data-types.js
  var SqlServerDialectTypes = {
    strings: ["TEXT"],
    integers: ["INTEGER", "INT"],
    reals: ["REAL"],
    booleans: ["BOOLEAN", "BOOL"],
    blobs: ["BLOB"],
    enums: [],
    dateTimes: ["DATETIME"]
  };

  // ../node_modules/langium-sql/lib/generated/grammar.js
  var loadedSqlGrammar;
  var SqlGrammar = () => loadedSqlGrammar !== null && loadedSqlGrammar !== void 0 ? loadedSqlGrammar : loadedSqlGrammar = loadGrammarFromJson(`{
  "$type": "Grammar",
  "isDeclared": true,
  "name": "Sql",
  "rules": [
    {
      "$type": "ParserRule",
      "name": "SqlFile",
      "entry": true,
      "definition": {
        "$type": "Assignment",
        "feature": "statements",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@1"
          },
          "arguments": []
        },
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Statement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@2"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@16"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefinitionRule",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@4"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@5"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@14"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CatalogDefinition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CREATE"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "catalogSyntax",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "CATALOG"
                }
              },
              {
                "$type": "Keyword",
                "value": "DATABASE"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@63"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false,
      "$comment": "/**\\n * A catalog is the top most layer inside of a database. In most sql dialects, it's expressed as\\n * \\n * \`\`\`sql\\n * CREATE DATABASE X;\\n * \`\`\`\\n * \\n * Some dialects use the \`CATALOG\` keyword instead to initialize a catalog.\\n */"
    },
    {
      "$type": "ParserRule",
      "name": "SchemaDefinition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CREATE"
          },
          {
            "$type": "Keyword",
            "value": "SCHEMA"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@6"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TableDefinition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CREATE"
          },
          {
            "$type": "Keyword",
            "value": "TABLE"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@6"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "columns",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@8"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "columns",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@8"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Assignment",
                "feature": "trailingComma",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": ","
                },
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReferenceNamed",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "reference",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@7"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GlobalReference",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "element",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/types@0"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@63"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "GlobalReference"
                },
                "feature": "previous",
                "operator": "="
              },
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "Assignment",
                "feature": "element",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@0"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@63"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TableContentDefinition",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@9"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@10"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@11"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@12"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@13"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ColumnDefinition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@63"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "dataType",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@68"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "negated",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "NOT"
                },
                "cardinality": "?"
              },
              {
                "$type": "Assignment",
                "feature": "null",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "NULL"
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrimaryKeyDefinition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "PRIMARY"
          },
          {
            "$type": "Keyword",
            "value": "KEY"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "primaryKeys",
            "operator": "+=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@9"
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "primaryKeys",
                "operator": "+=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/rules@9"
                  },
                  "deprecatedSyntax": false
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IndexDefinition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "INDEX"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "indexes",
            "operator": "+=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@9"
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "indexes",
                "operator": "+=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/rules@9"
                  },
                  "deprecatedSyntax": false
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "KeyDefinition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "unique",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "UNIQUE"
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "KEY"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@63"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "keys",
            "operator": "+=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@9"
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "keys",
                "operator": "+=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/rules@9"
                  },
                  "deprecatedSyntax": false
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConstraintDefinition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CONSTRAINT"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@63"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "FOREIGN"
          },
          {
            "$type": "Keyword",
            "value": "KEY"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "from",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@9"
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Keyword",
            "value": "REFERENCES"
          },
          {
            "$type": "Assignment",
            "feature": "table",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@7"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "to",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@9"
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "ON"
              },
              {
                "$type": "Keyword",
                "value": "DELETE"
              },
              {
                "$type": "Assignment",
                "feature": "cascadeDeletion",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "CASCADE"
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FunctionDefinition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CREATE"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "OR"
              },
              {
                "$type": "Assignment",
                "feature": "replace",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "REPLACE"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "FUNCTION"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@6"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "params",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@15"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "params",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@15"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Keyword",
            "value": "AS"
          },
          {
            "$type": "Assignment",
            "feature": "returnType",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@68"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FormalParameterDefinition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@63"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "dataType",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@68"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RootLevelSelectStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "with",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@27"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "select",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SelectStatementRootExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "SelectTableExpression"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@18"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SelectStatementUnionExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "SelectTableExpression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@19"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BinaryTableExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@21"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@19"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SelectStatementIntersectExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "SelectTableExpression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@20"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BinaryTableExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@22"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@20"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SelectStatementPrimaryExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "SelectTableExpression"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "SimpleSelectTableExpression"
                }
              },
              {
                "$type": "Assignment",
                "feature": "select",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@23"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ParenthesesSelectTableExpression"
                }
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "value",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@17"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnionSetOperator",
      "inferredType": {
        "$type": "InferredType",
        "name": "SetOperator"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "operator",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "UNION"
                },
                {
                  "$type": "Keyword",
                  "value": "EXCEPT"
                },
                {
                  "$type": "Keyword",
                  "value": "MINUS"
                }
              ]
            }
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "ALL"
              },
              {
                "$type": "Assignment",
                "feature": "distinct",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "DISTINCT"
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IntersectSetOperator",
      "inferredType": {
        "$type": "InferredType",
        "name": "SetOperator"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "operator",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "INTERSECT"
            }
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "ALL"
              },
              {
                "$type": "Assignment",
                "feature": "distinct",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "DISTINCT"
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SimpleSelectStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "SELECT"
          },
          {
            "$type": "Assignment",
            "feature": "top",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@24"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "select",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@35"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "from",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@37"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "where",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@30"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "groupBy",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@32"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "having",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@31"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "orderBy",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@33"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "limit",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@25"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "fetchFirst",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@26"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TopClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "TOP"
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@78"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "percent",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "PERCENT"
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false,
      "$comment": "/**\\n * SQL Server \`FETCH FIRST\` syntax\\n */"
    },
    {
      "$type": "ParserRule",
      "name": "LimitClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "LIMIT"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "offset",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@78"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "limit",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@78"
                      },
                      "arguments": []
                    }
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "limit",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@78"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "OFFSET"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "offset",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@78"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false,
      "$comment": "/**\\n * MySQL/PostreSQL \`FETCH FIRST\` syntax\\n */"
    },
    {
      "$type": "ParserRule",
      "name": "FetchFirstClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "OFFSET"
              },
              {
                "$type": "Assignment",
                "feature": "offset",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@78"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "offsetRows",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "ROWS"
                },
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "FETCH"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "first",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "FIRST"
                }
              },
              {
                "$type": "Keyword",
                "value": "NEXT"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "limit",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@78"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "ROWS"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "only",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "ONLY"
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "WITH"
                  },
                  {
                    "$type": "Keyword",
                    "value": "TIES"
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false,
      "$comment": "/**\\n * Oracle/Standard \`FETCH FIRST\` syntax\\n */"
    },
    {
      "$type": "ParserRule",
      "name": "WithClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "WITH"
          },
          {
            "$type": "Keyword",
            "value": "RECURSIVE",
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "ctes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@29"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "ctes",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@29"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CteColumnName",
      "definition": {
        "$type": "Assignment",
        "feature": "name",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@63"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CommonTableExpression",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@63"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "columnNames",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@28"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "columnNames",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@28"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "AS"
          },
          {
            "$type": "Assignment",
            "feature": "statement",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "WhereClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "WHERE"
          },
          {
            "$type": "Assignment",
            "feature": "rowCondition",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@42"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "HavingClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "HAVING"
          },
          {
            "$type": "Assignment",
            "feature": "groupCondition",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@42"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GroupByClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "GROUP"
          },
          {
            "$type": "Keyword",
            "value": "BY"
          },
          {
            "$type": "Assignment",
            "feature": "specs",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@42"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "specs",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@42"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrderByClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "ORDER"
          },
          {
            "$type": "Keyword",
            "value": "BY"
          },
          {
            "$type": "Assignment",
            "feature": "specs",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@34"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "specs",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@34"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrderBySpec",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "scalar",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@42"
              },
              "arguments": []
            }
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "ASC"
              },
              {
                "$type": "Keyword",
                "value": "DESC"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SelectElements",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "ALL"
              },
              {
                "$type": "Assignment",
                "feature": "distinct",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "DISTINCT"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "elements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@36"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@36"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SelectElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "SelectElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "AllStar"
                }
              },
              {
                "$type": "Keyword",
                "value": "*"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "AllTable"
                }
              },
              {
                "$type": "Assignment",
                "feature": "variableName",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@2"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@63"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "Keyword",
                "value": "*"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ExpressionQuery"
                }
              },
              {
                "$type": "Assignment",
                "feature": "expr",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@42"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "AS",
                    "cardinality": "?"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "name",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@63"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FromClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "FROM"
          },
          {
            "$type": "Assignment",
            "feature": "sources",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@38"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TableSources",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "list",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@39"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "list",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@39"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TableSource",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "item",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@41"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "joins",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@40"
              },
              "arguments": []
            },
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "JoinPart",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "leftJoin",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "LEFT"
                }
              },
              {
                "$type": "Assignment",
                "feature": "rightJoin",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "RIGHT"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "JOIN"
          },
          {
            "$type": "Assignment",
            "feature": "nextItem",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@41"
              },
              "arguments": []
            }
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "ON"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "joinOn",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@42"
                      },
                      "arguments": []
                    }
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "USING"
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "usingOn",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@42"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SourceItem",
      "inferredType": {
        "$type": "InferredType",
        "name": "SourceItem"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "TableSourceItem"
                }
              },
              {
                "$type": "Assignment",
                "feature": "table",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@7"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "AS",
                    "cardinality": "?"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "name",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@63"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "SubQuerySourceItem"
                }
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "subQuery",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@17"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "AS",
                    "cardinality": "?"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "name",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@63"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Expression",
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@43"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConcatExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@44"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BinaryExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "||"
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@44"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@45"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BinaryExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "OR"
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@45"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AndExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@46"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BinaryExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "AND"
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@46"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EqExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@47"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BinaryExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "="
                    },
                    {
                      "$type": "Keyword",
                      "value": "<>"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@47"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationalExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@48"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BinaryExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "<="
                    },
                    {
                      "$type": "Keyword",
                      "value": ">="
                    },
                    {
                      "$type": "Keyword",
                      "value": "<"
                    },
                    {
                      "$type": "Keyword",
                      "value": ">"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@48"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NegatableExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@49"
                },
                "arguments": []
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "inferredType": {
                      "$type": "InferredType",
                      "name": "NegatableExpression"
                    },
                    "feature": "left",
                    "operator": "="
                  },
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Assignment",
                            "feature": "operator",
                            "operator": "=",
                            "terminal": {
                              "$type": "Keyword",
                              "value": "IS"
                            }
                          },
                          {
                            "$type": "Assignment",
                            "feature": "negated",
                            "operator": "?=",
                            "terminal": {
                              "$type": "Keyword",
                              "value": "NOT"
                            },
                            "cardinality": "?"
                          }
                        ]
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Assignment",
                            "feature": "negated",
                            "operator": "?=",
                            "terminal": {
                              "$type": "Keyword",
                              "value": "NOT"
                            },
                            "cardinality": "?"
                          },
                          {
                            "$type": "Assignment",
                            "feature": "operator",
                            "operator": "=",
                            "terminal": {
                              "$type": "Alternatives",
                              "elements": [
                                {
                                  "$type": "Keyword",
                                  "value": "IN"
                                },
                                {
                                  "$type": "Keyword",
                                  "value": "LIKE"
                                }
                              ]
                            }
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "$type": "Assignment",
                    "feature": "right",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@49"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@49"
                },
                "arguments": []
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "inferredType": {
                      "$type": "InferredType",
                      "name": "BetweenExpression"
                    },
                    "feature": "subExpr",
                    "operator": "="
                  },
                  {
                    "$type": "Assignment",
                    "feature": "negated",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "NOT"
                    },
                    "cardinality": "?"
                  },
                  {
                    "$type": "Keyword",
                    "value": "BETWEEN"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "left",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@49"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "AND"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "right",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@49"
                      },
                      "arguments": []
                    }
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AdditiveExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@50"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BinaryExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "+"
                    },
                    {
                      "$type": "Keyword",
                      "value": "-"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@50"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicativeExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@51"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BinaryExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "*"
                    },
                    {
                      "$type": "Keyword",
                      "value": "/"
                    },
                    {
                      "$type": "Keyword",
                      "value": "%"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@51"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "JsonExtractExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@53"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BinaryExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "::$"
                    },
                    {
                      "$type": "Keyword",
                      "value": "::%"
                    },
                    {
                      "$type": "Keyword",
                      "value": "::"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@65"
                      },
                      "arguments": []
                    },
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@64"
                      },
                      "arguments": []
                    },
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@52"
                      },
                      "arguments": []
                    }
                  ]
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IdentifierAsStringLiteral",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "IdentifierAsStringLiteral"
            }
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@63"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrimaryExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "StringLiteral"
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@65"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "TableRelatedColumnExpression"
                }
              },
              {
                "$type": "Assignment",
                "feature": "variableName",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/rules@41/inferredType"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@63"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "Assignment",
                "feature": "columnName",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@4"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@63"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "NumberLiteral"
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@64"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BooleanLiteral"
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@66"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "CastExpression"
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@62"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "UnaryExpression"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "NOT"
                    },
                    {
                      "$type": "Keyword",
                      "value": "-"
                    },
                    {
                      "$type": "Keyword",
                      "value": "+"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "value",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@53"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ParenthesisOrListExpression"
                }
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "items",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@42"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "items",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@42"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "SubQueryExpression"
                }
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "subQuery",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@17"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "FunctionCall"
                }
              },
              {
                "$type": "Assignment",
                "feature": "function",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@7"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "params",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@35"
                  },
                  "arguments": []
                },
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ")"
              },
              {
                "$type": "Assignment",
                "feature": "overClause",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@54"
                  },
                  "arguments": []
                },
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ColumnNameExpression"
                }
              },
              {
                "$type": "Assignment",
                "feature": "columnName",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@4"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@63"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "NullLiteral"
                }
              },
              {
                "$type": "Keyword",
                "value": "NULL"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "HexStringLiteral"
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@67"
                },
                "arguments": []
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OverClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "OVER"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "spec",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@55"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "windowName",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/rules@55"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@63"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "WindowSpec",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@63"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@61"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@33"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@56"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FrameClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "units",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@57"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "extent",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@58"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FrameUnits",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "ROWS"
          },
          {
            "$type": "Keyword",
            "value": "RANGE"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FrameExtent",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@60"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@59"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FrameBetween",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "BETWEEN"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@60"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "AND"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@60"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FrameRange",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "CURRENT"
              },
              {
                "$type": "Keyword",
                "value": "ROW"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "UNBOUNDED"
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "PRECEDING"
                  },
                  {
                    "$type": "Keyword",
                    "value": "FOLLOWING"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@42"
                },
                "arguments": []
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "PRECEDING"
                  },
                  {
                    "$type": "Keyword",
                    "value": "FOLLOWING"
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PartitionClause",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "PARTITION"
          },
          {
            "$type": "Keyword",
            "value": "BY"
          },
          {
            "$type": "Assignment",
            "feature": "exprs",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@42"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "exprs",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@42"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CastExpression",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CAST"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "expr",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@42"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "AS"
          },
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@68"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Identifier",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@77"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@76"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@74"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@75"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NumberLiteral",
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@78"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StringLiteral",
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@73"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BooleanLiteral",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "TRUE"
            }
          },
          {
            "$type": "Keyword",
            "value": "FALSE"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "HexStringLiteral",
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@72"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Type",
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@69"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DataType",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "dataTypeNames",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@77"
              },
              "arguments": []
            },
            "cardinality": "+"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "arguments",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@70"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "arguments",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@70"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DataTypeArgument",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@64"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "WS",
      "definition": {
        "$type": "RegexToken",
        "regex": "/\\\\s+/"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "name": "HEX_STRING",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "/x\\\\'[A-Fa-f0-9]+\\\\'/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "STRING",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "/'(\\\\\\\\.|[^'\\\\\\\\])*'/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "TICK_STRING",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "/\\\\\`(\\\\\\\\.|\\\\\\\\\\\\\\\\|[^\`\\\\\\\\])*\\\\\`/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "BRACKET_STRING",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "/\\\\[(\\\\\\\\.|\\\\\\\\\\\\\\\\|[^[\\\\\\\\])*\\\\]/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "QUOTED_ID",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "/\\\\\\"(\\\\\\\\.|\\\\\\\\\\\\\\\\|[^\\"\\\\\\\\])*\\\\\\"/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "ID",
      "definition": {
        "$type": "RegexToken",
        "regex": "/[_a-zA-Z][\\\\w_]*/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "NUMBER",
      "type": {
        "$type": "ReturnType",
        "name": "number"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "/\\\\d+((\\\\.\\\\d+)?([eE][\\\\-+]?\\\\d+)?)?/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "ML_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "/\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\//"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "TICK_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "/\\\\-\\\\-[^\\\\n\\\\r]*/"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "SL_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "/\\\\/\\\\/[^\\\\n\\\\r]*/"
      },
      "fragment": false
    }
  ],
  "types": [
    {
      "$type": "Type",
      "name": "Definition",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@3"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@4"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/types@3"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@14"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "ReferenceDefinition",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@4"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@5"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@14"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "TableVariableSource",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@41/definition/elements@0/elements@0/inferredType"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@41/definition/elements@1/elements@0/inferredType"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "TableLike",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@5"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@29"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "ColumnNameSource",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@9"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@36/definition/elements@2/elements@0/inferredType"
            }
          }
        ]
      }
    }
  ],
  "definesHiddenTokens": false,
  "hiddenTokens": [],
  "imports": [],
  "interfaces": [],
  "usedGrammars": []
}`);

  // ../node_modules/langium-sql/lib/generated/module.js
  var SqlLanguageMetaData = {
    languageId: "sql",
    fileExtensions: [".sql"],
    caseInsensitive: true
  };
  var SqlGeneratedSharedModule = {
    AstReflection: () => new SqlAstReflection()
  };
  var SqlGeneratedModule = {
    Grammar: () => SqlGrammar(),
    LanguageMetaData: () => SqlLanguageMetaData,
    parser: {}
  };

  // ../node_modules/langium-sql/lib/sql-name-provider.js
  var SqlNameProvider = class extends DefaultNameProvider {
    getName(node) {
      if (isSchemaDefinition(node) || isTableDefinition(node) || isFunctionDefinition(node)) {
        return this.getDefinitionName(node.reference);
      } else {
        return super.getName(node);
      }
    }
    getNameNode(node) {
      if (isSchemaDefinition(node) || isTableDefinition(node) || isFunctionDefinition(node)) {
        return this.getDefinitionNode(node.reference);
      } else {
        return super.getNameNode(node);
      }
    }
    getDefinitionName(reference) {
      var _a;
      return ((_a = reference === null || reference === void 0 ? void 0 : reference.element) === null || _a === void 0 ? void 0 : _a.$refText) || void 0;
    }
    getDefinitionNode(reference) {
      var _a;
      return (_a = reference === null || reference === void 0 ? void 0 : reference.element) === null || _a === void 0 ? void 0 : _a.$refNode;
    }
  };

  // ../node_modules/langium-sql/lib/sql-scope-computation.js
  var SqlScopeComputation = class extends DefaultScopeComputation {
    exportNode(node, exports2, document) {
      if (isCatalogDefinition(node) || isSchemaDefinition(node) || isTableDefinition(node) || isFunctionDefinition(node)) {
        if (isCatalogDefinition(node)) {
          super.exportNode(node, exports2, document);
        } else {
          const reference = node.reference;
          if (reference && !reference.previous) {
            super.exportNode(node, exports2, document);
          }
        }
      }
    }
    processNode(node, document, scopes) {
      const container = node.$container;
      if (isWithClause(container)) {
        const selectStatement = container.$container;
        for (const cte of container.ctes) {
          const name = this.nameProvider.getName(cte);
          if (name) {
            scopes.add(selectStatement, this.descriptions.createDescription(cte, name, document));
          }
        }
      } else if (isDefinition(container)) {
        return;
      } else {
        super.processNode(node, document, scopes);
      }
    }
  };

  // ../node_modules/langium-sql/lib/sql-scope-provider.js
  var SqlScopeProvider = class extends DefaultScopeProvider {
    constructor(services) {
      super(services);
      this.astNodeDescriptionProvider = services.workspace.AstNodeDescriptionProvider;
      this.astNodeLocator = services.workspace.AstNodeLocator;
      this.langiumDocuments = services.shared.workspace.LangiumDocuments;
      this.containerManager = services.shared.workspace.ContainerManager;
    }
    getScope(context) {
      var _a, _b, _c;
      const container = context.container;
      if (isGlobalReference(container)) {
        const previous = container.previous;
        if (previous) {
          const element = (_a = previous.element) === null || _a === void 0 ? void 0 : _a.ref;
          if (element) {
            return this.createScopeForNodes(this.containerManager.getChildren(element));
          } else {
            return EMPTY_SCOPE;
          }
        } else {
          return super.getScope(context);
        }
      } else if (isPrimaryKeyDefinition(container)) {
        const property2 = context.property;
        switch (property2) {
          case "primaryKeys":
            const tableDef = ast_utils_exports.getContainerOfType(container, isTableDefinition);
            return this.streamColumnDefinitions(tableDef.columns.filter(isColumnDefinition));
          default:
            assertUnreachable(property2);
        }
      } else if (isIndexDefinition(container)) {
        const property2 = context.property;
        switch (property2) {
          case "indexes":
            const tableDef = ast_utils_exports.getContainerOfType(container, isTableDefinition);
            return this.streamColumnDefinitions(tableDef.columns.filter(isColumnDefinition));
          default:
            assertUnreachable(property2);
        }
      } else if (isKeyDefinition(container)) {
        const property2 = context.property;
        switch (property2) {
          case "keys":
            const tableDef = ast_utils_exports.getContainerOfType(container, isTableDefinition);
            return this.streamColumnDefinitions(tableDef.columns.filter(isColumnDefinition));
          default:
            assertUnreachable(property2);
        }
      } else if (isConstraintDefinition(container)) {
        const property2 = context.property;
        switch (property2) {
          case "from": {
            const columns = ast_utils_exports.getContainerOfType(container, isTableDefinition).columns.filter(isColumnDefinition);
            return this.streamColumnDefinitions(columns);
          }
          case "to": {
            const columns = (_b = getFromGlobalReference(container.table, isTableDefinition)) === null || _b === void 0 ? void 0 : _b.columns.filter(isColumnDefinition);
            return this.streamColumnDefinitions(columns !== null && columns !== void 0 ? columns : []);
          }
          default:
            assertUnreachable(property2);
        }
      } else if (isAllTable(container)) {
        const property2 = context.property;
        switch (property2) {
          case "variableName": {
            const selectStatement = ast_utils_exports.getContainerOfType(container, isSimpleSelectStatement);
            return this.newCaseInsensitiveScope(stream(this.getTableVariablesForSelectStatement(selectStatement)));
          }
          default:
            assertUnreachable(property2);
        }
      } else if (isTableRelatedColumnExpression(container)) {
        const property2 = context.property;
        switch (property2) {
          case "variableName":
            const selectStatement = ast_utils_exports.getContainerOfType(container, isSimpleSelectStatement);
            return this.getTableVariablesForSelectStatementRecursively(context, selectStatement);
          case "columnName":
            const sourceItem = (_c = container.variableName) === null || _c === void 0 ? void 0 : _c.ref;
            if (sourceItem) {
              if (isTableSourceItem(sourceItem)) {
                const tableLike = getFromGlobalReference(sourceItem.table, isTableLike);
                if (tableLike) {
                  if (isTableDefinition(tableLike)) {
                    return this.streamColumnDefinitions(tableLike.columns.filter(isColumnDefinition));
                  } else if (isCommonTableExpression(tableLike)) {
                    const candidates = getColumnCandidatesForSelectTableExpression(tableLike.statement);
                    return this.streamColumnDescriptors(candidates);
                  } else {
                    assertUnreachable(tableLike);
                  }
                }
              } else if (isSubQuerySourceItem(sourceItem)) {
                const selectStatement2 = sourceItem.subQuery;
                const candidates = getColumnCandidatesForSelectTableExpression(selectStatement2);
                return this.streamColumnDescriptors(candidates);
              } else {
                assertUnreachable(sourceItem);
              }
            }
            break;
          default:
            assertUnreachable(property2);
        }
      } else if (isColumnNameExpression(container)) {
        const property2 = context.property;
        switch (property2) {
          case "columnName":
            const selectStatement = ast_utils_exports.getContainerOfType(container, isSimpleSelectStatement);
            const candidates = getColumnCandidatesForSimpleSelectStatement(selectStatement);
            return this.streamColumnDescriptors(candidates);
          default:
            assertUnreachable(property2);
        }
      } else if (isOverClause(container)) {
        const property2 = context.property;
        switch (property2) {
          case "windowName":
            const selectStatement = ast_utils_exports.getContainerOfType(container, isSimpleSelectStatement);
            const nodes = ast_utils_exports.streamAllContents(selectStatement).filter(isWindowSpec).toArray();
            return this.packToDescriptions(nodes);
        }
      } else {
        assertUnreachable(container);
      }
      return super.getScope(context);
    }
    getTableVariablesForSelectStatementRecursively(context, selectStatement) {
      let outerScope = void 0;
      if (selectStatement && ast_utils_exports.hasContainerOfType(selectStatement.$container, isSimpleSelectStatement)) {
        const outerSelectStatement = ast_utils_exports.getContainerOfType(selectStatement.$container, isSimpleSelectStatement);
        outerScope = this.getTableVariablesForSelectStatementRecursively(context, outerSelectStatement);
      }
      const descriptions = this.getTableVariablesForSelectStatement(selectStatement);
      return this.newCaseInsensitiveScope(stream(descriptions), outerScope);
    }
    getTableVariablesForSelectStatement(selectStatement) {
      if (selectStatement === null || selectStatement === void 0 ? void 0 : selectStatement.from) {
        const astDescriptions = [];
        for (const source of selectStatement.from.sources.list) {
          const items = [source.item].concat(source.joins.map((j) => j.nextItem));
          for (const item of items) {
            if (item.name) {
              astDescriptions.push(this.astNodeDescriptionProvider.createDescription(item, item.name));
            } else {
              if (isTableSourceItem(item)) {
                const tableLike = getFromGlobalReference(item.table, isTableLike);
                if (tableLike) {
                  const name = this.nameProvider.getName(tableLike);
                  if (name) {
                    astDescriptions.push(this.astNodeDescriptionProvider.createDescription(item, name));
                  }
                }
              } else if (!isSubQuerySourceItem(item)) {
                assertUnreachable(item);
              }
            }
          }
        }
        return astDescriptions;
      }
      return [];
    }
    getGlobalScope(nodeType, _context) {
      return this.newCaseInsensitiveScope(this.indexManager.allElements(nodeType));
    }
    packToDescriptions(nodes) {
      return this.newCaseInsensitiveScope(stream(nodes.map((c) => this.astNodeDescriptionProvider.createDescription(c, c.name))));
    }
    streamColumnDescriptors(columns) {
      return this.newCaseInsensitiveScope(stream(columns.filter((c) => c.name).map((c) => this.astNodeDescriptionProvider.createDescription(c.node, c.name))));
    }
    streamColumnDefinitions(columns) {
      return this.packToDescriptions(columns);
    }
    newCaseInsensitiveScope(stream2, outerScope = void 0) {
      return new StreamScope(stream2, outerScope, { caseInsensitive: true });
    }
  };

  // ../node_modules/langium-sql/lib/sql-semantic-token-provider.js
  var import_vscode_languageserver13 = __toESM(require_main10(), 1);
  var SqlSemanticTokenProvider = class extends AbstractSemanticTokenProvider {
    highlightElement(node, acceptor) {
      if (isDataType2(node)) {
        acceptor({
          node,
          property: "dataTypeNames",
          type: import_vscode_languageserver13.SemanticTokenTypes.type
        });
      } else if (isStringLiteral2(node)) {
        acceptor({
          node,
          property: "value",
          type: import_vscode_languageserver13.SemanticTokenTypes.string
        });
      } else if (isNumberLiteral2(node)) {
        acceptor({
          node,
          property: "value",
          type: import_vscode_languageserver13.SemanticTokenTypes.number
        });
      }
    }
  };

  // ../node_modules/langium-sql/lib/sql-type-conversion.js
  var Identity = { kind: "implicit", convert: (v) => v };
  function Implicit(convert) {
    return { kind: "implicit", convert };
  }
  function Explicit(convert) {
    return { kind: "explicit", convert };
  }
  var Forbidden = void 0;
  var ConversionTable = {
    "boolean->unknown": Identity,
    "boolean->boolean": Identity,
    "boolean->integer": Implicit((v) => {
      return {
        type: "integer",
        value: BigInt(v.value ? 1 : 0)
      };
    }),
    "boolean->real": Implicit((v) => {
      return {
        type: "real",
        value: v.value ? 1 : 0
      };
    }),
    "boolean->text": Implicit((v) => {
      return {
        type: "text",
        value: v.value ? "TRUE" : "FALSE"
      };
    }),
    "integer->unknown": Identity,
    "integer->boolean": Explicit((v) => {
      return {
        type: "boolean",
        value: v.value !== BigInt(0)
      };
    }),
    "integer->integer": Identity,
    "integer->real": Implicit((v) => {
      return {
        type: "real",
        value: Number(v.value)
      };
    }),
    "integer->text": Implicit((v) => {
      return {
        type: "text",
        value: v.value.toString()
      };
    }),
    "real->unknown": Identity,
    "real->boolean": Explicit((v) => {
      return {
        type: "boolean",
        value: v.value !== 0
      };
    }),
    "real->integer": Explicit((v) => {
      return {
        type: "integer",
        value: BigInt(v.value)
      };
    }),
    "real->real": Identity,
    "real->text": Explicit((v) => {
      return {
        type: "text",
        value: v.value.toString()
      };
    }),
    "text->unknown": Identity,
    "text->boolean": Explicit((v) => {
      if (typeof v.value !== "string") {
        throw new Error();
      }
      return {
        type: "boolean",
        value: v.value.length > 0
      };
    }),
    "text->integer": Explicit((v) => {
      return {
        type: "integer",
        value: BigInt(v.value)
      };
    }),
    "text->real": Explicit((v) => {
      if (typeof v.value !== "string") {
        throw new Error();
      }
      return {
        type: "real",
        value: parseFloat(v.value)
      };
    }),
    "text->text": Identity,
    "boolean->row": Forbidden,
    "text->row": Forbidden,
    "row->boolean": Forbidden,
    "row->text": Forbidden,
    "row->row": Identity,
    "row->integer": Forbidden,
    "row->real": Forbidden,
    "row->unknown": Identity,
    "integer->row": Forbidden,
    "real->row": Forbidden,
    "boolean->enum": Forbidden,
    "row->enum": Forbidden,
    "text->enum": Forbidden,
    "enum->boolean": Forbidden,
    "enum->row": Forbidden,
    "enum->text": Forbidden,
    "enum->enum": Identity,
    "enum->integer": Forbidden,
    "enum->real": Forbidden,
    "enum->unknown": Identity,
    "integer->enum": Forbidden,
    "real->enum": Forbidden,
    "boolean->datetime": Forbidden,
    "row->datetime": Forbidden,
    "text->datetime": Forbidden,
    "enum->datetime": Forbidden,
    "datetime->boolean": Forbidden,
    "datetime->row": Forbidden,
    "datetime->text": Forbidden,
    "datetime->enum": Forbidden,
    "datetime->datetime": Identity,
    "datetime->integer": Forbidden,
    "datetime->real": Forbidden,
    "datetime->unknown": Identity,
    "integer->datetime": Forbidden,
    "real->datetime": Forbidden,
    "boolean->null": Forbidden,
    "row->null": Forbidden,
    "enum->null": Forbidden,
    "text->null": Forbidden,
    "null->boolean": Forbidden,
    "null->row": Forbidden,
    "null->enum": Forbidden,
    "null->text": Forbidden,
    "null->null": Identity,
    "null->datetime": Forbidden,
    "null->real": Forbidden,
    "null->integer": Forbidden,
    "null->unknown": Identity,
    "datetime->null": Forbidden,
    "real->null": Forbidden,
    "integer->null": Forbidden,
    "boolean->array": Forbidden,
    "datetime->array": Forbidden,
    "array->boolean": Forbidden,
    "array->datetime": Forbidden,
    "array->array": Identity,
    "array->null": Forbidden,
    "array->text": Forbidden,
    "array->row": Forbidden,
    "array->enum": Forbidden,
    "array->integer": Forbidden,
    "array->real": Forbidden,
    "array->unknown": Identity,
    "null->array": Forbidden,
    "text->array": Forbidden,
    "row->array": Forbidden,
    "enum->array": Forbidden,
    "integer->array": Forbidden,
    "real->array": Forbidden,
    "boolean->blob": Forbidden,
    "integer->blob": Forbidden,
    "real->blob": Forbidden,
    "text->blob": Forbidden,
    "row->blob": Forbidden,
    "enum->blob": Forbidden,
    "datetime->blob": Forbidden,
    "null->blob": Forbidden,
    "array->blob": Forbidden,
    "blob->boolean": Forbidden,
    "blob->integer": Forbidden,
    "blob->real": Forbidden,
    "blob->text": Forbidden,
    "blob->row": Forbidden,
    "blob->enum": Forbidden,
    "blob->datetime": Forbidden,
    "blob->null": Forbidden,
    "blob->array": Forbidden,
    "blob->blob": Identity,
    "blob->unknown": Identity,
    "unknown->array": Identity,
    "unknown->blob": Identity,
    "unknown->boolean": Identity,
    "unknown->datetime": Identity,
    "unknown->enum": Identity,
    "unknown->integer": Identity,
    "unknown->null": Identity,
    "unknown->real": Identity,
    "unknown->row": Identity,
    "unknown->text": Identity,
    "unknown->unknown": Identity
  };
  function canConvert(source, target, kind = "implicit") {
    const entry = ConversionTable[`${source.discriminator}->${target.discriminator}`];
    if (entry != null && (kind === "explicit" || entry.kind === "implicit")) {
      return true;
    } else {
      return false;
    }
  }

  // ../node_modules/langium-sql/lib/sql-type-descriptors.js
  var import_lodash = __toESM(require_lodash(), 1);
  function isTypeABoolean(type) {
    return type.discriminator === "boolean";
  }
  var Types = {
    Unknown: {
      discriminator: "unknown"
    },
    Null: {
      discriminator: "null"
    },
    ArrayOf(elementType) {
      return {
        discriminator: "array",
        elementType
      };
    },
    Boolean: {
      discriminator: "boolean"
    },
    Blob: {
      discriminator: "blob"
    },
    Integer: {
      discriminator: "integer"
    },
    Real: {
      discriminator: "real"
    },
    DateTime: {
      discriminator: "datetime"
    },
    Char(length = 100) {
      return {
        discriminator: "text",
        length
      };
    },
    Enum(members) {
      return { discriminator: "enum", members: members.filter((e) => typeof e === "string") };
    }
  };
  function areTypesEqual(lhs, rhs) {
    return import_lodash.default.isEqual(lhs, rhs);
  }

  // ../node_modules/langium-sql/lib/sql-type-operators.js
  var import_lodash2 = __toESM(require_lodash(), 1);
  var IntegerReturnsInteger = {
    operandType: Types.Integer,
    returnType: Types.Integer
  };
  var RealReturnsReal = {
    operandType: Types.Real,
    returnType: Types.Real
  };
  var BooleanReturnsBoolean = {
    operandType: Types.Boolean,
    returnType: Types.Boolean
  };
  var ReversedUnaryOperators = /* @__PURE__ */ new Map();
  ReversedUnaryOperators.set(IntegerReturnsInteger, ["+", "-"]);
  ReversedUnaryOperators.set(RealReturnsReal, ["+", "-"]);
  ReversedUnaryOperators.set(BooleanReturnsBoolean, ["NOT"]);
  var unaries = [...ReversedUnaryOperators.entries()].flatMap(([descr, operators]) => {
    return operators.map((op) => [op, descr]);
  });
  function emptUnaryTable() {
    const result = {};
    const indices = ["+", "-", "NOT"];
    indices.forEach((op) => result[op] = []);
    return result;
  }
  var UnaryOperators = Object.entries(import_lodash2.default.groupBy(unaries, ([op]) => op)).reduce((lhs, rhs) => {
    const key = rhs[0];
    lhs[key] = lhs[key].concat(rhs[1].map((descr) => descr[1]));
    return lhs;
  }, emptUnaryTable());
  var IntegerIntegerReturnsInteger = {
    left: Types.Integer,
    right: Types.Integer,
    returnType: Types.Integer
  };
  var RealRealReturnsReal = {
    left: Types.Real,
    right: Types.Real,
    returnType: Types.Real
  };
  var IntegerIntegerReturnsBoolean = {
    left: Types.Integer,
    right: Types.Integer,
    returnType: Types.Boolean
  };
  var RealRealReturnsBoolean = {
    left: Types.Real,
    right: Types.Real,
    returnType: Types.Boolean
  };
  var BooleanBooleanReturnsBoolean = {
    left: Types.Boolean,
    right: Types.Boolean,
    returnType: Types.Boolean
  };
  var CharCharReturnsBoolean = {
    left: Types.Char(),
    right: Types.Char(),
    returnType: Types.Boolean
  };
  var CharCharReturnsChar = {
    left: Types.Char(),
    right: Types.Char(),
    returnType: Types.Char()
  };
  var CharCharReturnsReal = {
    left: Types.Char(),
    right: Types.Char(),
    returnType: Types.Real
  };
  var ReversedBinaryOperators = /* @__PURE__ */ new Map();
  ReversedBinaryOperators.set(IntegerIntegerReturnsInteger, ["%", "*", "+", "-", "/"]);
  ReversedBinaryOperators.set(RealRealReturnsReal, ["%", "*", "+", "-", "/"]);
  ReversedBinaryOperators.set(IntegerIntegerReturnsBoolean, ["<", "<=", "<>", "=", ">", ">="]);
  ReversedBinaryOperators.set(RealRealReturnsBoolean, ["<", "<=", "<>", "=", ">", ">="]);
  ReversedBinaryOperators.set(CharCharReturnsBoolean, ["<", "<=", "<>", "=", ">", ">=", "LIKE"]);
  ReversedBinaryOperators.set(BooleanBooleanReturnsBoolean, ["<", "<=", "<>", "=", ">", ">=", "AND", "OR"]);
  ReversedBinaryOperators.set(CharCharReturnsChar, ["||", "LIKE", "::$", "::"]);
  ReversedBinaryOperators.set(CharCharReturnsReal, ["::%"]);
  var flatMap2 = [...ReversedBinaryOperators.entries()].flatMap(([descr, operators]) => {
    return operators.map((op) => [op, descr]);
  });
  function emptyBinaryTable() {
    const result = {};
    const indices = ["%", "*", "+", "-", "/", "<", "<=", "<>", "=", ">", ">=", "AND", "OR", "||", "IS", "LIKE", "IN", "::", "::$", "::%"];
    indices.forEach((op) => result[op] = []);
    return result;
  }
  var BinaryOperators = Object.entries(import_lodash2.default.groupBy(flatMap2, ([op]) => op)).reduce((lhs, rhs) => {
    const key = rhs[0];
    lhs[key] = lhs[key].concat(rhs[1].map((descr) => descr[1]));
    return lhs;
  }, emptyBinaryTable());

  // ../node_modules/langium-sql/lib/sql-type-computation.js
  var SqlTypeComputer = class {
    constructor(services) {
      this.dataTypes = services.dialect.dataTypes;
    }
    computeType(node) {
      if (isExpression(node)) {
        return this.computeTypeOfExpression(node);
      } else if (isType2(node)) {
        return this.computeTypeOfDataType(node);
      }
      return void 0;
    }
    computeTypeOfExpression(node) {
      if (isCastExpression(node)) {
        const source = this.computeType(node.expr);
        const target = this.computeTypeOfDataType(node.type);
        return source && target && canConvert(source, target, "explicit") ? target : void 0;
      }
      if (isNumberLiteral2(node)) {
        return this.computeTypeOfNumericLiteral(node.$cstNode.text);
      }
      if (isNullLiteral(node)) {
        return Types.Null;
      }
      if (isHexStringLiteral(node)) {
        return Types.Integer;
      }
      if (isTableRelatedColumnExpression(node)) {
        const varRef = node.variableName.ref;
        if (!varRef) {
          return void 0;
        } else if (isTableSourceItem(varRef)) {
          const ref = node.columnName.ref;
          if (!isColumnDefinition(ref)) {
            return void 0;
          }
          return this.computeType(ref.dataType);
        } else if (isSubQuerySourceItem(varRef)) {
          const ref = node.columnName.ref;
          if (!isExpressionQuery(ref)) {
            return void 0;
          }
          return this.computeType(ref.expr);
        } else {
          assertUnreachable(varRef);
          return void 0;
        }
      }
      if (isParenthesisOrListExpression(node)) {
        const firstType = this.computeType(node.items[0]);
        if (firstType && node.$container.$type === NegatableExpression && node.$container.operator === "IN") {
          return Types.ArrayOf(firstType);
        }
        return firstType;
      }
      if (isUnaryExpression(node)) {
        const operandType = this.computeType(node.value);
        return operandType != null ? this.computeTypeOfUnaryOperation(node.operator, operandType) : void 0;
      }
      if (isStringLiteral2(node)) {
        return Types.Char();
      }
      if (isBooleanLiteral2(node)) {
        return Types.Boolean;
      }
      if (isColumnNameExpression(node)) {
        const ref = node.columnName.ref;
        if (!ref) {
          return void 0;
        } else if (isExpressionQuery(ref)) {
          return this.computeType(ref.expr);
        } else if (isColumnDefinition(ref)) {
          return this.computeType(ref.dataType);
        } else if (isCteColumnName(ref)) {
          throw new Error("TODO");
        } else {
          assertUnreachable(ref);
        }
      }
      if (isFunctionCall(node)) {
        const functionLike = getFromGlobalReference(node.function, isFunctionDefinition);
        if (functionLike) {
          return this.computeTypeOfDataType(functionLike.returnType);
        } else {
          return void 0;
        }
      }
      if (isBinaryExpression(node) || isNegatableExpression(node)) {
        const left = this.computeType(node.left);
        const right = this.computeType(node.right);
        if (left && right) {
          return this.computeTypeOfBinaryOperation(node.operator, left, right);
        }
        return void 0;
      }
      if (isBetweenExpression(node)) {
        return Types.Boolean;
      }
      if (isSubQueryExpression(node)) {
        return this.computeTypeOfSelectStatement(node.subQuery);
      }
      if (isIdentifierAsStringLiteral(node)) {
        return Types.Char();
      }
      assertUnreachable(node);
    }
    computeTypeOfSelectStatement(selectStatement) {
      return {
        discriminator: "row",
        columnTypes: getColumnsForSelectTableExpression(selectStatement).map((c) => ({
          name: c.name,
          type: this.computeType(c.typedNode)
        }))
      };
    }
    computeTypeOfDataType(dataType) {
      if (this.dataTypes.isBooleanDataType(dataType)) {
        return Types.Boolean;
      }
      if (this.dataTypes.isIntegerDataType(dataType)) {
        return Types.Integer;
      }
      if (this.dataTypes.isRealDataType(dataType)) {
        return Types.Real;
      }
      if (this.dataTypes.isStringDataType(dataType)) {
        return Types.Char();
      }
      if (this.dataTypes.isEnumDataType(dataType)) {
        return Types.Enum(dataType.arguments.map((e) => e.value));
      }
      if (this.dataTypes.isDateTimeDataType(dataType)) {
        return Types.DateTime;
      }
      if (this.dataTypes.isBlobDataType(dataType)) {
        return Types.Blob;
      }
      return Types.Unknown;
    }
    computeTypeOfNumericLiteral(text) {
      var _a, _b, _c;
      const NumericLiteralPattern = /^(\d+)((\.(\d)+)?([eE]([\-+]?\d+))?)?$/;
      const match = NumericLiteralPattern.exec(text);
      const fractionalPart = (_b = (_a = match[4]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      const exponent = parseInt((_c = match[6]) !== null && _c !== void 0 ? _c : "0", 10);
      return Math.max(0, fractionalPart - exponent) === 0 ? Types.Integer : Types.Real;
    }
    computeTypeOfBinaryOperation(operator, left, right) {
      const candidates = BinaryOperators[operator];
      for (const candidate of candidates) {
        if (areTypesEqual(candidate.left, left) && areTypesEqual(candidate.right, right)) {
          return candidate.returnType;
        } else {
          if (canConvert(left, candidate.left, "implicit") && canConvert(right, candidate.right, "implicit")) {
            return candidate.returnType;
          }
        }
      }
      return void 0;
    }
    computeTypeOfUnaryOperation(operator, operandType) {
      const candidates = UnaryOperators[operator];
      for (const candidate of candidates) {
        if (areTypesEqual(candidate.operandType, operandType)) {
          return candidate.returnType;
        }
      }
      return void 0;
    }
  };

  // ../node_modules/langium-sql/lib/sql-validator.js
  var import_lodash3 = __toESM(require_lodash(), 1);
  var SqlValidationRegistry = class extends ValidationRegistry {
    constructor(services) {
      super(services);
      const validator = services.validation.SqlValidator;
      const checks = {
        TableDefinition: [validator.checkIfTableDefinitionHasAtLeastOneColumn],
        SimpleSelectStatement: [
          validator.checkVariableNamesAreUnique,
          validator.checkIfSelectStatementWithAllStarSelectItemHasAtLeastOneTableSource
        ],
        //Expression: [validator.checkIfExpressionHasType], //TODO uncomment when type system is bullet-proof
        BinaryTableExpression: [validator.checkBinaryTableExpressionMatches],
        NumberLiteral: [validator.checkIntegerLiteralIsWholeNumber],
        BinaryExpression: [validator.checkBinaryExpressionType],
        UnaryExpression: [validator.checkUnaryExpressionType],
        WhereClause: [validator.checkWhereIsBoolean],
        HavingClause: [validator.checkHavingIsBoolean],
        SubQueryExpression: [validator.checkIfSubQuerySelectsExactlyOneValue],
        ReferenceDefinition: [validator.checkIfReferencePointsToCorrectParent],
        FunctionCall: [validator.checkFunctionCallTarget],
        TableSourceItem: [validator.checkTableSourceItemTarget],
        ConstraintDefinition: [validator.checkConstraintTarget],
        DataType: [validator.checkIfKnownDataType]
      };
      this.register(checks, validator);
    }
  };
  var SqlValidator = class {
    constructor(services) {
      this.typeComputer = services.dialect.typeComputer;
      this.dataTypes = services.dialect.dataTypes.allTypes();
    }
    checkBinaryTableExpressionMatches(expr, accept) {
      const lhs = getColumnsForSelectTableExpression(expr.left);
      const rhs = getColumnsForSelectTableExpression(expr.right);
      if (lhs.length !== rhs.length) {
        ReportAs.TableOperationUsesTablesWithDifferentColumnCounts(expr, {}, accept);
      } else {
        lhs.forEach((left, index) => {
          const right = rhs[index];
          const leftType = this.typeComputer.computeType(left.typedNode);
          const rightType = this.typeComputer.computeType(right.typedNode);
          if (leftType && rightType) {
            if (!canConvert(leftType, rightType) && !canConvert(rightType, leftType)) {
              ReportAs.TableOperationUsesTablesWithDifferentColumnTypes(expr, { columnIndex: index }, accept);
            }
          }
        });
      }
    }
    checkIfExpressionHasType(expr, accept) {
      const type = this.typeComputer.computeType(expr);
      if (!type) {
        ReportAs.CannotDeriveTypeOfExpression(expr, {}, accept);
      }
    }
    checkWhereIsBoolean(clause, accept) {
      const type = this.typeComputer.computeType(clause.rowCondition);
      if (type && !isTypeABoolean(type)) {
        ReportAs.ExpressionMustReturnABoolean(clause.rowCondition, type, accept);
      }
    }
    checkHavingIsBoolean(clause, accept) {
      const type = this.typeComputer.computeType(clause.groupCondition);
      if (type && !isTypeABoolean(type)) {
        ReportAs.ExpressionMustReturnABoolean(clause.groupCondition, type, accept);
      }
    }
    checkBinaryExpressionType(expr, accept) {
      const left = this.typeComputer.computeType(expr.left);
      const right = this.typeComputer.computeType(expr.right);
      const returnType = this.typeComputer.computeType(expr);
      if (left && right && !returnType) {
        ReportAs.BinaryOperatorNotDefinedForGivenExpressions(expr, {
          left,
          right,
          op: expr.operator
        }, accept);
      }
    }
    checkUnaryExpressionType(expr, accept) {
      const operand = this.typeComputer.computeType(expr.value);
      const returnType = this.typeComputer.computeType(expr);
      if (operand && !returnType) {
        ReportAs.UnaryOperatorNotDefinedForGivenExpression(expr, {
          operand,
          op: expr.operator
        }, accept);
      }
    }
    checkVariableNamesAreUnique(query, accept) {
      var _a, _b;
      const groups = import_lodash3.default.groupBy((_b = (_a = query.from) === null || _a === void 0 ? void 0 : _a.sources) === null || _b === void 0 ? void 0 : _b.list, (s) => {
        var _a2;
        return (_a2 = s.item) === null || _a2 === void 0 ? void 0 : _a2.name;
      });
      for (const [key, group] of Object.entries(groups).filter((g) => g[0] && g[1].length > 1)) {
        for (const member of group.filter((e) => e.item)) {
          ReportAs.DuplicatedVariableName(member.item, { name: key }, accept);
        }
      }
    }
    checkIntegerLiteralIsWholeNumber(literal, accept) {
    }
    checkIfSelectStatementWithAllStarSelectItemHasAtLeastOneTableSource(selectStatement, accept) {
      var _a;
      if (((_a = selectStatement.select) === null || _a === void 0 ? void 0 : _a.elements.filter(isAllStar).length) > 0) {
        if (!selectStatement.from) {
          ReportAs.AllStarSelectionRequiresTableSources(selectStatement, {}, accept);
        }
      }
    }
    checkIfTableDefinitionHasAtLeastOneColumn(tableDefinition, accept) {
      if (tableDefinition.columns.length === 0) {
        ReportAs.TableDefinitionRequiresAtLeastOneColumn(tableDefinition.reference, {}, accept);
      }
    }
    checkIfReferencePointsToCorrectParent(referenceDefinition, accept) {
      this.checkReferenceParent(referenceDefinition.reference, accept);
    }
    checkReferenceParent(globalReference, accept) {
      var _a, _b, _c;
      const element = (_a = globalReference === null || globalReference === void 0 ? void 0 : globalReference.element) === null || _a === void 0 ? void 0 : _a.ref;
      if (element) {
        const parent = (_c = (_b = globalReference.previous) === null || _b === void 0 ? void 0 : _b.element) === null || _c === void 0 ? void 0 : _c.ref;
        if (parent) {
          const ownType = getDefinitionType(element);
          const parentType = getDefinitionType(parent);
          if (parentType >= ownType) {
            accept("error", `Cannot nest element of type '${getDefinitionTypeName(element)}' inside of '${getDefinitionTypeName(parent)}'`, {
              node: globalReference,
              property: "previous"
            });
          } else if (globalReference.previous) {
            this.checkReferenceParent(globalReference.previous, accept);
          }
        }
      }
    }
    //TODO does not hold for insertions! INSERT INTO employees SELECT id, name FROM xxx
    checkIfSubQuerySelectsExactlyOneValue(subQueryExpression, accept) {
      const type = this.typeComputer.computeTypeOfSelectStatement(subQueryExpression.subQuery);
      if (type.discriminator === "row" && type.columnTypes.length > 1) {
        ReportAs.SubQueriesWithinSelectStatementsMustHaveExactlyOneColumn(subQueryExpression, {}, accept);
      }
    }
    checkFunctionCallTarget(functionCall, accept) {
      var _a, _b;
      const reference = (_b = (_a = functionCall.function) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.ref;
      if (reference && !isFunctionDefinition(reference)) {
        ReportAs.IncorrectGlobalReferenceTarget(functionCall.function, {
          expected: "FUNCTION",
          received: getDefinitionTypeName(reference)
        }, accept);
      }
    }
    checkTableSourceItemTarget(tableSourceItem, accept) {
      var _a, _b;
      const reference = (_b = (_a = tableSourceItem.table) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.ref;
      if (reference && !isTableLike(reference)) {
        ReportAs.IncorrectGlobalReferenceTarget(tableSourceItem.table, {
          expected: "TABLE",
          received: getDefinitionTypeName(reference)
        }, accept);
      }
    }
    checkConstraintTarget(constraintDefinition, accept) {
      var _a, _b;
      const reference = (_b = (_a = constraintDefinition.table) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.ref;
      if (reference && !isTableDefinition(reference)) {
        ReportAs.IncorrectGlobalReferenceTarget(constraintDefinition.table, {
          expected: "TABLE",
          received: getDefinitionTypeName(reference)
        }, accept);
      }
    }
    checkIfKnownDataType(dataType, accept) {
      if (!this.dataTypes.some((dt) => isCompatibleWithDefinition(dataType, dt))) {
        ReportAs.UnknownDataType(dataType, { dataType }, accept);
      }
    }
  };

  // ../node_modules/langium-sql/lib/sql-value-converter.js
  var SqlValueConverter = class extends DefaultValueConverter {
    runConverter(rule, input, cstNode) {
      if (rule.name.toUpperCase() === "TICK_STRING" || rule.name.toUpperCase() === "STRING") {
        return input.substring(1, input.length - 1).replace(/\\(.)/g, "$1");
      }
      return super.runConverter(rule, input, cstNode);
    }
  };

  // ../node_modules/langium-sql/lib/sql-workspace-manager.js
  var SqlWorkspaceManager = class extends DefaultWorkspaceManager {
    constructor(services) {
      super(services);
      this.initializationFiles = [];
      this.factory = services.workspace.LangiumDocumentFactory;
      services.lsp.LanguageServer.onInitialize((params) => {
        var _a;
        const files = (_a = params.initializationOptions) === null || _a === void 0 ? void 0 : _a.files;
        if (Array.isArray(files)) {
          this.initializationFiles.push(...files);
        }
      });
    }
    async loadAdditionalDocuments(_folders, collector) {
      for (let i = 0; i < this.initializationFiles.length; i++) {
        const file = this.initializationFiles[i];
        const uri = URI2.parse(`inmemory:///builtin_${i}.sql`);
        const document = this.factory.fromString(file, uri);
        collector(document);
      }
    }
  };

  // ../node_modules/langium-sql/lib/sql-module.js
  var SqlSharedModule = {
    workspace: {
      WorkspaceManager: (services) => new SqlWorkspaceManager(services),
      ContainerManager: (services) => new SqlContainerManager(services)
    }
  };
  var SqlModule = {
    dialect: {
      dataTypes: () => new DialectTypes(SqlServerDialectTypes),
      typeComputer: (services) => new SqlTypeComputer(services)
    },
    parser: {
      ValueConverter: () => new SqlValueConverter()
    },
    references: {
      NameProvider: () => new SqlNameProvider(),
      ScopeComputation: (services) => new SqlScopeComputation(services),
      ScopeProvider: (services) => new SqlScopeProvider(services)
    },
    lsp: {
      SemanticTokenProvider: (services) => new SqlSemanticTokenProvider(services),
      CompletionProvider: (services) => new SqlCompletionProvider(services)
    },
    validation: {
      ValidationRegistry: (services) => new SqlValidationRegistry(services),
      SqlValidator: (services) => new SqlValidator(services)
    }
  };
  function createSqlServices(context) {
    const shared2 = inject(createDefaultSharedModule(context), SqlGeneratedSharedModule, SqlSharedModule, context.sharedModule);
    const Sql = inject(createDefaultModule({ shared: shared2 }), SqlGeneratedModule, SqlModule, context.module);
    shared2.ServiceRegistry.register(Sql);
    return { shared: shared2, Sql };
  }

  // ../node_modules/langium-sql/lib/dialects/mysql/data-types.js
  var MySqlDialectTypes = typesExtend(SqlServerDialectTypes, {
    strings: [
      "CHAR(size?)",
      "VARCHAR(size)",
      "TINYTEXT",
      "TEXT(size)",
      "MEDIUMTEXT",
      "LONGTEXT"
    ],
    integers: [
      "BIT(size)",
      "TINYINT(size)",
      "SMALLINT(size)",
      "MEDIUMINT(size)",
      "INT(size)",
      "INTEGER(size)",
      "BIGINT(size)"
    ],
    reals: [
      "DECIMAL(size?, size?)"
    ],
    dateTimes: [
      "DATE",
      "DATETIME(size?)",
      "TIMESTAMP(size?)",
      "TIME(size?)",
      "YEAR"
    ],
    booleans: [],
    blobs: [
      "BINARY(size)",
      "VARBINARY(size)",
      "TINYBLOB",
      "BLOB(size)",
      "MEDIUMBLOB",
      "LONGBLOB"
    ],
    enums: []
  });

  // assets/scripts/sql/language-server.ts
  var messageReader = new import_browser.BrowserMessageReader(self);
  var messageWriter = new import_browser.BrowserMessageWriter(self);
  var connection = (0, import_browser.createConnection)(messageReader, messageWriter);
  var { shared } = createSqlServices({
    connection,
    ...EmptyFileSystem,
    module: { dialect: { dataTypes: () => new DialectTypes(MySqlDialectTypes) } }
  });
  startLanguageServer(shared);
})();
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
